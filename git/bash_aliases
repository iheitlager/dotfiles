#!/usr/bin/env bash

print_help () {
   printf "  \033[0;33m$1\033[0m: $2\n"
}

__git_help() {
    printf "git commands\n------------\n"
    print_help 'git reset --hard' 'rollback and discard all uncommitted changes'
    print_help 'git reset --soft HEAD~1' 'undo last commit and leave changes staged'
    print_help 'git rebase HEAD~[X] -i' 'prepare to squash [X] commits - interactive'
    print_help 'git branch -D [branch_name]' 'locally delete branch [branch_name]'
    print_help 'git rebase origin/main' 'rebase on current main'

    printf "\naliases\n-------\n"
    cat $DOTFILES/git/bash_aliases | grep alias | grep -v cat | grep --color=auto git

    printf "\nshorthand\n---------\n"
    print_help 'g s' 'git status'
    print_help 'g a' 'git add .'
    print_help 'g cm' 'git commit -m'
    print_help 'g d' 'git diff'
    print_help 'g rh' 'git reset --hard'
    print_help 'g co' 'git checkout'
    print_help 'g br' 'git branch'
    print_help 'g last' 'git log -1 HEAD'
    print_help 'g cane' 'git commit --amend --no-edit'
    print_help 'g lo' 'git log --online -n 10'
    print_help 'g pr' 'git pull --rebase'
    print_help 'g unstage' 'git reset HEAD --'
    print_help 'g last' 'git log -1 HEAD'
}

# Amend the last commit and push force to current branch
__git_go() {
    git add --all
    git commit --amend --no-edit
    git push origin `git rev-parse --abbrev-ref HEAD` -f # push back active branch
}

# a smarter checkout
__git_checkout() {
    if [[ $# -gt 0 ]]; then
        # Use provided arguments
        git checkout "$@"
    else
        # Interactive selection with fzf
        local branch=$(git branch --all --format="%(refname:short)" | grep -v HEAD | fzf --height=20% --border --prompt="Select branch: ")
        if [[ -n "$branch" ]]; then
            # Remove 'origin/' prefix if it's a remote branch
            branch=${branch#origin/}
            git checkout "$branch"
        fi
    fi
}


__git_commit() {
    # Run formatters if available
    local repo_root=$(git rev-parse --show-toplevel)
    if command -v uv &> /dev/null && [[ -f "$repo_root/pyproject.toml" ]]; then
        uv run ruff format . 2>/dev/null 
        uv run ruff check --fix . 2>/dev/null
    fi
    
    # Stage formatted files
    git add .
    
    # Commit with message
    if [[ $# -gt 0 ]]; then
        # Use provided arguments
        git commit -m "$@"
    else
        git commit
    fi
}

# Branch management for Python projects
__git_newbranch() {
    local branch_name="$1"
    if [[ -z "$branch_name" ]]; then
        echo "Usage: __git_newbranch <branch-name>"
        return 1
    fi
    
    git checkout -b "$branch_name"

    # Sync dependencies if uv project
    local repo_root=$(git rev-parse --show-toplevel)
    if command -v uv &> /dev/null && [[ -f "$repo_root/pyproject.toml" ]]; then
        uv sync
    fi
}

alias g=git
alias gh='__git_help' # git help
alias ggo='__git_go' # amend the last change
alias gl='git log --oneline --graph --decorate --all' # pretty git log
alias glo='git log --oneline -n 10' # short git log
alias gd='git diff' # git diff
alias grh='git reset --hard' # git reset hard
alias gca='git commit --amend --no-edit' # git commit amend no edit
alias cb='git branch --merged main | grep -v "\* main" | xargs -n 1 git branch -d' # clear all merged branches
alias ga='git add --all' # short hand to add all changed files
alias gap='git add -p' # pick and stage
alias gb="__git_newbranch" # create new branch and switch to it (python based)
alias gu='git reset HEAD' # unstage changes
alias gp='git pull origin main' # pull main
alias gc='__git_commit' # git commit short hand
alias gco='__git_checkout' # smarter git checkout with fzf
alias pb='git push origin `git rev-parse --abbrev-ref HEAD` -f' # push back active branch
alias pd='git pull origin `git rev-parse --abbrev-ref HEAD` -f --rebase' # pull down active branch
alias gs='git status -sb' # short git status
alias gf='git fetch --all --prune' # fetch all remotes and prune deleted branches
alias grom='git rebase origin/main' # rebase on origin main
alias gwip='git add -A && git commit -m "WIP" --no-verify'  # park everything as WIP
alias gunwip='git reset HEAD~1' # undo WIP by uncommitting last commit
# =======================================================================
# Git Worktree commands
# also see aliases
#      venv=source .*/bin/activate
#      make env # a standard job to run virtualenv .package
# see https://github.com/LAB271/git-worktree
# =======================================================================

# Helper function to get main worktree path
__git_main_worktree() {
    git worktree list | head -1 | awk '{print $1}'
}

# Helper function to get worktree root (handles being in subdirectories)
__git_worktree_root() {
    git rev-parse --show-toplevel 2>/dev/null
}

# gw: Git Worktree - Create new worktree
# Usage: gw feat/authentication
#        gw bugfix/issue-123
alias gw='__git_worktree_create'
__git_worktree_create() {
    # WORKTREE_BASE: Base directory for all worktrees (relative to repo root)
    BASE=$(basename "$(__git_main_worktree)")
    DIRNAME=$(dirname "$(__git_main_worktree)")
    WORKTREE_BASE="$DIRNAME/$BASE-worktree"

    if [ -z "$1" ]; then
        echo "Usage: gw <branch-name>"
        echo "Example: gw feat/authentication"
        echo "         gw spike/authentication"
        echo "         gw fix/authentication"
        return 1
    fi

    local branch_name="$1"
    local worktree_name=$(echo "$branch_name" | sed 's/\//-/g')  # Replace / with -
    local worktree_path="${WORKTREE_BASE}/${worktree_name}"

    echo "Creating worktree: $worktree_path"
    echo "Branch: $branch_name"

    # Create worktree
    if git worktree add "$worktree_path" -b "$branch_name"; then
        echo "‚úÖ Worktree created successfully!"
        echo "To move there: wm $worktree_name"
        echo "To setup:      cd $worktree_path && make env && venv"   # virtualenv .env && source .venv/bin/activate
    else
        echo "‚ùå Failed to create worktree"
        return 1
    fi
}

# gwc: Git Worktree Create and setup - Create worktree + auto-setup environment
# Usage: gwc feat/authentication
alias gwc='__git_worktree_create_and_setup'
__git_worktree_create_and_setup() {
    # WORKTREE_BASE: Base directory for all worktrees (relative to repo root)
    BASE=$(basename "$(__git_main_worktree)")
    DIRNAME=$(dirname "$(__git_main_worktree)")
    WORKTREE_BASE="$DIRNAME/$BASE-worktree"

    if [ -z "$1" ]; then
        echo "Usage: gwc <branch-name>"
        echo "Example: gwc feat/authentication"
        echo "This creates the worktree AND runs 'make env && venv'" # virtualenv .env && source .venv/bin/activate
        return 1
    fi

    local branch_name="$1"
    local worktree_name=$(echo "$branch_name" | sed 's/\//-/g')
    local worktree_path="${WORKTREE_BASE}/${worktree_name}"

    echo "üå≥ Creating worktree: $worktree_path"
    echo "üìã Branch: $branch_name"

    # Create worktree
    if git worktree add "$worktree_path" -b "$branch_name"; then
        echo "‚úÖ Worktree created!"

        # Move to worktree
        cd "$worktree_path" || return 1
        echo "üìÇ Changed to: $(pwd)"

        # Setup environment
        echo "üîß Running 'make env'..."
        if make env; then
            echo "‚úÖ Environment setup complete!"
            echo ""
            echo "üéØ Ready to work! Run 'venv' to activate environment"
            echo ""
            # Try to activate (may not work in some shells, but worth trying)
            source .*/bin/activate 2>/dev/null && echo "‚úÖ Virtual environment activated!" || echo "Run: venv"
        else
            echo "‚ùå 'make env' failed - please check errors above"
            return 1
        fi
    else
        echo "‚ùå Failed to create worktree"
        return 1
    fi
}

# wm: Worktree Move - Move to a worktree
# Usage: wm feat-authentication
#        wm bugfix-issue-123
alias wm='__git_worktree_move'
__git_worktree_move() {
    # WORKTREE_BASE: Base directory for all worktrees (relative to repo root)
    BASE=$(basename "$(__git_main_worktree)")
    DIRNAME=$(dirname "$(__git_main_worktree)")
    WORKTREE_BASE="$DIRNAME/$BASE-worktree"

    if [ -z "$1" ]; then
        echo "Usage: wm <worktree-name>"
        _list_worktrees
        return 1
    fi


    local worktree_name=$(echo "$1" | sed 's/\//-/g')
    local worktree_path="${WORKTREE_BASE}/${worktree_name}"

    if [ -d "$worktree_path" ]; then
        cd "$worktree_path" || return 1
        echo "üìÇ Moved to: $(pwd)"
        echo "üå≥ Branch: $(git branch --show-current)"

        # Check if .virtual_env exists
        local venv_dir=$(ls -d .[^.]*/bin/python 2>/dev/null | head -n1 | cut -d'/' -f1)

        if [ -d "$venv_dir" ]; then
            echo "‚úÖ Virtual environment exists ($venv_dir/)"
        else
            echo "‚ö†Ô∏è  No virtual environment found - create local env"
        fi
    else
        echo "‚ùå Worktree not found: $worktree_path"
        _list_worktrees
        return 1
    fi
}

# lw: List Worktrees - Show all worktrees with status
alias lw='__git_list_worktrees'
__git_list_worktrees() {
    echo "Git Worktrees:"
    echo "=============="

    git worktree list | while IFS= read -r line; do
        local path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

        # Check if this is the current worktree
        local current_path=$(git rev-parse --show-toplevel 2>/dev/null)
        local marker=""
        if [ "$path" = "$current_path" ]; then
            marker="üëâ "
        fi

        # Check if .virtual_env exists in this worktree
        # local venv_dir=$(ls -d $path/.[^.]*/bin/python 2>/dev/null | head -n1 | rev | cut -d'/' -f3 | rev)
        venv_dir=""
        for potential_venv in "$path"/.*; do
            if [ -d "$potential_venv" ] && [ "$(basename "$potential_venv")" != "." ] && [ "$(basename "$potential_venv")" != ".." ]; then
                if [ -f "$potential_venv/bin/python" ]; then
                    venv_dir=$(basename "$potential_venv")
                    break
                fi
            fi
        done

        local env_status=""
        if [ -n "$venv_dir" ]; then
            env_status="[‚úÖ $venv_dir]"
        else
            env_status="[‚ùå no env]"
        fi

        echo "${marker}${path}"
        echo "   Branch: ${branch} ${env_status}"
        echo ""
    done

    echo "Use: wm <name> to move to worktree"
    echo "Use: bw to return to main"
}

# bw: Back to main Worktree
alias bw='__git_worktree_back_to_main'
__git_worktree_back_to_main() {
    local main_path=$(__git_main_worktree)

    if [ -z "$main_path" ]; then
        echo "‚ùå Could not find main worktree"
        return 1
    fi

    cd "$main_path" || return 1
    echo "üìÇ Back to main: $(pwd)"
    echo "üå≥ Branch: $(git branch --show-current)"

    # Check if .virtual_env exists
    local venv_dir=$(ls -d .[^.]*/bin/python 2>/dev/null | head -n1 | cut -d'/' -f1)

    if [ -n "$venv_dir" ]; then
        echo "‚úÖ Virtual environment exists ($venv_dir/)"
    else
        echo "‚ö†Ô∏è  No virtual environment found - run 'make env'"  # virtualenv .env
    fi
}

# rw: Remove Worktree
# Usage: rw feat-authentication
alias rw='__git_remove_worktree'
__git_remove_worktree() {
    # WORKTREE_BASE: Base directory for all worktrees (relative to repo root)
    BASE=$(basename "$(__git_main_worktree)")
    WORKTREE_BASE="../$BASE-worktree"

    if [ -z "$1" ]; then
        echo "Usage: rw <worktree-name>"
        echo "Available worktrees:"
        lw
        return 1
    fi

    local worktree_name=$(echo "$1" | sed 's/\//-/g')  # Replace / with -
    local worktree_path="${WORKTREE_BASE}/${worktree_name}"

    # Verify worktree exists
    if ! git worktree list | grep -q "$worktree_path"; then
        echo "‚ùå Worktree not found: $worktree_path"
        echo "Available worktrees:"
        lw
        return 1
    fi

    # Confirm removal
    echo "‚ö†Ô∏è  About to remove worktree:"
    echo "   Path: $worktree_path"
    echo "   Branch: $(git worktree list | grep "$worktree_path" | awk '{print $3}' | tr -d '[]')"
    echo ""
    read -p "Continue? [y/N] " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if git worktree remove "$worktree_path"; then
            git branch -D $1
            echo "‚úÖ Worktree removed: $worktree_path"
        else
            echo "‚ùå Failed to remove worktree"
            echo "Try: git worktree remove --force $worktree_path"
            return 1
        fi
    else
        echo "‚ùå Cancelled"
    fi
}

# pw: Print current Worktree path
alias pw='__git_print_worktree'
__git_print_worktree() {
    local worktree_path=$(__git_worktree_root)

    if [ -z "$worktree_path" ]; then
        echo "‚ùå Not in a git repository"
        return 1
    fi

    local branch=$(git branch --show-current)
    local is_main=$(git worktree list | head -1 | grep -q "$worktree_path" && echo "yes" || echo "no")

    echo "Current Worktree:"
    echo "================="
    echo ""
    echo "Path:   $worktree_path"
    echo "Branch: $branch"
    echo "Main:   $is_main"

    # Check if .virtual_env exists in this worktree
    local venv_dir=$(ls -d $path/.[^.]*/bin/python 2>/dev/null | head -n1 | cut -d'/' -f2)
    if [ -n $venv_dir ]; then
        echo "Env:    ‚úÖ $venv_dir exists"
        if [ -n "$VIRTUAL_ENV" ]; then
            echo "Active: ‚úÖ $(basename $VIRTUAL_ENV)"
        else
            echo "Active: ‚ùå (run: venv)"  # alias venv=source .*/bin/activate
        fi
    else
        echo "Env:    ‚ùå No .venv (run: virtualenv .PACKAGE)"
    fi
}

# cw: Cleanup removed Worktrees
alias cw='__git_cleanup_worktrees'
__cleanup_worktrees() {
    echo "Pruning removed worktrees..."
    git worktree prune -v
    echo "‚úÖ Cleanup complete"
}

# Combined alias for quick workflow
alias gww='__git_worktree_workflow'
__git_worktree_workflow() {
    echo "Git Worktree Quick Workflow:"
    echo "============================"
    echo ""
    echo "1. gw <branch>   - Create worktree"
    echo "2. gwc <branch>  - Create + setup (make env + venv)"
    echo "3. wm <name>     - Move to worktree"
    echo "4. lw            - List all worktrees"
    echo "5. bw            - Back to main"
    echo "6. rw <name>     - Remove worktree"
    echo "7. pw            - Print current worktree info"
    echo "8. cw            - Cleanup pruned worktrees"
    echo ""
    lw
}

# ======================================================================
# End Worktree commands
# ======================================================================
