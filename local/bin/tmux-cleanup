#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

# Interactive tmux cleanup tool using fzf
# Shows all sessions/windows/panes and allows killing processes or panes

set -euo pipefail

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
RESET='\033[0m'

show_help() {
    cat << 'EOF'
Usage: tmux-cleanup [OPTIONS]

Interactive tmux cleanup tool using fzf to manage sessions, windows, and panes.

OPTIONS:
    -p, --panes         Kill selected panes (default)
    -w, --windows       Kill selected windows
    -s, --sessions      Kill selected sessions
    -k, --kill-process  Kill the process in selected panes (not the pane itself)
    -a, --all           Show all tmux objects (sessions/windows/panes)
    -h, --help          Show this help message

EXAMPLES:
    tmux-cleanup                # Interactive pane selection (kill panes)
    tmux-cleanup -k             # Interactive pane selection (kill processes)
    tmux-cleanup -w             # Interactive window selection
    tmux-cleanup -s             # Interactive session selection
    tmux-cleanup -a             # Show all objects interactively

FEATURES:
    - Multi-select with Tab
    - Preview pane content
    - Shows process info (PID, command)
    - Safe: requires confirmation for session kills
    - Color-coded output

KEYBINDINGS:
    Tab         Toggle selection
    Enter       Confirm and kill selected items
    Ctrl+C      Cancel
    Ctrl+A      Select all
    Ctrl+D      Deselect all

DEPENDENCIES:
    tmux, fzf

EOF
}

# Check dependencies
check_dependencies() {
    local missing=()
    command -v tmux >/dev/null 2>&1 || missing+=("tmux")
    command -v fzf >/dev/null 2>&1 || missing+=("fzf")

    if [[ ${#missing[@]} -gt 0 ]]; then
        echo -e "${RED}Error: Missing dependencies: ${missing[*]}${RESET}" >&2
        echo "Install with: brew install ${missing[*]}" >&2
        exit 1
    fi

    # Check if we're in a tmux session
    if [[ -z "${TMUX:-}" ]]; then
        echo -e "${YELLOW}Warning: Not running inside tmux${RESET}" >&2
    fi
}

# Get list of all panes with details
list_panes() {
    tmux list-panes -a -F "#{session_name}:#{window_index}.#{pane_index}|#{pane_pid}|#{pane_current_command}|#{pane_title}|S:#{session_name} W:#{window_index}:#{window_name} P:#{pane_index}" 2>/dev/null || true
}

# Get list of all windows with details
list_windows() {
    tmux list-windows -a -F "#{session_name}:#{window_index}|#{window_panes}|#{window_name}|#{window_activity}|S:#{session_name} W:#{window_index}:#{window_name} (#{window_panes} panes)" 2>/dev/null || true
}

# Get list of all sessions with details
list_sessions() {
    tmux list-sessions -F "#{session_name}|#{session_windows}|#{session_created}|#{session_attached}|S:#{session_name} (#{session_windows} windows, attached:#{session_attached})" 2>/dev/null || true
}

# Format pane info for fzf display
format_panes() {
    while IFS='|' read -r target pid cmd title display; do
        printf "${GREEN}%-30s${RESET} ${BLUE}PID:%-8s${RESET} ${YELLOW}%-20s${RESET} ${CYAN}%s${RESET}\n" \
            "$display" "$pid" "$cmd" "$title"
    done
}

# Format window info for fzf display
format_windows() {
    while IFS='|' read -r target panes name activity display; do
        printf "${GREEN}%-40s${RESET} ${BLUE}%-15s${RESET} ${YELLOW}%s${RESET}\n" \
            "$display" "$panes panes" "$name"
    done
}

# Format session info for fzf display
format_sessions() {
    while IFS='|' read -r name windows created attached display; do
        printf "${GREEN}%-30s${RESET} ${BLUE}%-15s${RESET} ${YELLOW}Attached:%-3s${RESET}\n" \
            "$display" "$windows windows" "$attached"
    done
}

# Kill selected panes
kill_panes() {
    local kill_process=$1
    shift
    local selections=("$@")

    if [[ ${#selections[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No panes selected${RESET}"
        return 0
    fi

    for selection in "${selections[@]}"; do
        # Extract target from the formatted line
        local target=$(echo "$selection" | grep -oE '^[^[:space:]]+:[0-9]+\.[0-9]+' || true)

        if [[ -z "$target" ]]; then
            echo -e "${RED}Failed to parse: $selection${RESET}" >&2
            continue
        fi

        if [[ "$kill_process" == "true" ]]; then
            # Kill the process in the pane
            local pid=$(tmux display-message -p -t "$target" '#{pane_pid}' 2>/dev/null || true)
            if [[ -n "$pid" ]]; then
                echo -e "${YELLOW}Killing process $pid in $target${RESET}"
                kill "$pid" 2>/dev/null || echo -e "${RED}Failed to kill process $pid${RESET}" >&2
            fi
        else
            # Kill the pane itself
            echo -e "${YELLOW}Killing pane $target${RESET}"
            tmux kill-pane -t "$target" 2>/dev/null || echo -e "${RED}Failed to kill pane $target${RESET}" >&2
        fi
    done
}

# Kill selected windows
kill_windows() {
    local selections=("$@")

    if [[ ${#selections[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No windows selected${RESET}"
        return 0
    fi

    for selection in "${selections[@]}"; do
        # Extract session:window from the formatted line
        local target=$(echo "$selection" | grep -oE 'S:[^[:space:]]+\s+W:[0-9]+' | sed 's/S:\([^[:space:]]*\).*W:\([0-9]*\)/\1:\2/')

        if [[ -z "$target" ]]; then
            echo -e "${RED}Failed to parse: $selection${RESET}" >&2
            continue
        fi

        echo -e "${YELLOW}Killing window $target${RESET}"
        tmux kill-window -t "$target" 2>/dev/null || echo -e "${RED}Failed to kill window $target${RESET}" >&2
    done
}

# Kill selected sessions
kill_sessions() {
    local selections=("$@")

    if [[ ${#selections[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No sessions selected${RESET}"
        return 0
    fi

    for selection in "${selections[@]}"; do
        # Extract session name from the formatted line
        local session=$(echo "$selection" | grep -oE 'S:[^[:space:]]+' | sed 's/S://')

        if [[ -z "$session" ]]; then
            echo -e "${RED}Failed to parse: $selection${RESET}" >&2
            continue
        fi

        echo -e "${RED}Killing session $session${RESET}"
        tmux kill-session -t "$session" 2>/dev/null || echo -e "${RED}Failed to kill session $session${RESET}" >&2
    done
}

# Main interactive selection
interactive_select() {
    local mode=$1
    local kill_process=${2:-false}

    local data
    local header
    local preview_cmd

    case "$mode" in
        panes)
            data=$(list_panes | format_panes)
            header="Select panes to kill (Tab=select, Enter=confirm, Ctrl+C=cancel)"
            preview_cmd='tmux capture-pane -p -t $(echo {} | grep -oE "^[^[:space:]]+:[0-9]+\.[0-9]+") 2>/dev/null || echo "Preview not available"'
            ;;
        windows)
            data=$(list_windows | format_windows)
            header="Select windows to kill (Tab=select, Enter=confirm, Ctrl+C=cancel)"
            preview_cmd='echo "Window contents preview not available"'
            ;;
        sessions)
            data=$(list_sessions | format_sessions)
            header="Select sessions to kill (Tab=select, Enter=confirm, Ctrl+C=cancel)"
            preview_cmd='tmux list-windows -t $(echo {} | grep -oE "S:[^[:space:]]+" | sed "s/S://") 2>/dev/null || echo "Preview not available"'
            ;;
        *)
            echo -e "${RED}Invalid mode: $mode${RESET}" >&2
            return 1
            ;;
    esac

    if [[ -z "$data" ]]; then
        echo -e "${YELLOW}No $mode found${RESET}"
        return 0
    fi

    # Use fzf for selection
    local selections
    mapfile -t selections < <(echo "$data" | fzf \
        --ansi \
        --multi \
        --height=80% \
        --layout=reverse \
        --border \
        --header="$header" \
        --preview="$preview_cmd" \
        --preview-window=right:50%:wrap \
        --bind 'tab:toggle+down' \
        --bind 'ctrl-a:select-all' \
        --bind 'ctrl-d:deselect-all' \
        --prompt="$mode> " \
        --color='header:italic:underline' \
    )

    if [[ ${#selections[@]} -eq 0 ]]; then
        echo -e "${YELLOW}No selections made${RESET}"
        return 0
    fi

    # Confirm before killing
    echo -e "${RED}About to kill ${#selections[@]} $mode:${RESET}"
    printf '%s\n' "${selections[@]}"
    read -p "$(echo -e ${YELLOW}Continue? [y/N]: ${RESET})" -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Cancelled${RESET}"
        return 0
    fi

    # Kill based on mode
    case "$mode" in
        panes)
            kill_panes "$kill_process" "${selections[@]}"
            ;;
        windows)
            kill_windows "${selections[@]}"
            ;;
        sessions)
            kill_sessions "${selections[@]}"
            ;;
    esac
}

# Parse arguments
main() {
    check_dependencies

    local mode="panes"
    local kill_process="false"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -p|--panes)
                mode="panes"
                shift
                ;;
            -w|--windows)
                mode="windows"
                shift
                ;;
            -s|--sessions)
                mode="sessions"
                shift
                ;;
            -k|--kill-process)
                kill_process="true"
                shift
                ;;
            -a|--all)
                echo "All mode not yet implemented"
                shift
                ;;
            *)
                echo -e "${RED}Unknown option: $1${RESET}" >&2
                echo "Use -h or --help for usage information" >&2
                exit 1
                ;;
        esac
    done

    interactive_select "$mode" "$kill_process"
}

main "$@"
