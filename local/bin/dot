#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

# Install homebrew packages
BREWFILE="${XDG_DATA_HOME:-$HOME/.local/share}/Brewfile"

# Trap Ctrl-C and exit cleanly
trap 'echo ""; echo "‚ùå Installation interrupted by user"; exit 130' INT

print_usage() {
    local HELP="cat"
    if command -v bat >/dev/null 2>&1; then
        HELP="bat --plain --language=help"
    fi
    
    $HELP << EOF
Usage: dot [COMMAND] [OPTIONS]

COMMANDS:
    install <topic>   Run install.sh for a specific topic (e.g., vim, osx, vscode)
    list              List available topics with install.sh scripts
    status            Show installation status and outdated packages
    invalidate        Clear dotfiles caches (bash_env, bash_aliases, etc.)
    purge             Find and remove stale symlinks in XDG directories
    clean             Clean Claude Code config files and backups from home directory
    (none)            Install homebrew packages (default behavior)

OPTIONS:
    -n, --new         Force regeneration of Brewfile and install
    -x, --export      Only create Brewfile without installing
    -s, --skip        Skip using brew bundle, force package installation
    -v, --verbose     Show verbose output during operations
    -f, --file PATH   Specify custom Brewfile location (default: \$XDG_DATA_HOME/Brewfile)
    -h, --help        Show this help message

Example:
    dot                           # Install using existing Brewfile
    dot install vim               # Run vim/install.sh
    dot install osx               # Run osx/install.sh
    dot list                      # Show available topics
    dot status                    # Show what's installed and outdated
    dot invalidate                # Clear dotfiles caches
    dot purge                     # Remove stale symlinks in ~/.config etc.
    dot purge --force             # Remove stale symlinks without confirmation
    dot clean                     # Clean Claude Code files
    dot -n                        # Regenerate Brewfile and install
    dot -x                        # Export current installations to Brewfile
    dot -v -n                     # Verbose output with new installation
    dot -f ~/my-brewfile          # Use custom Brewfile location

EOF
}

# Handle subcommands first
if [[ $# -gt 0 ]]; then
    case $1 in
        install)
            if [[ -z $DOTFILES ]]; then
                echo "‚ùå DOTFILES variable not set, exiting"
                exit 1
            fi
            if [[ -z $2 ]]; then
                echo "‚ùå Usage: dot install <topic>"
                echo "   Run 'dot list' to see available topics"
                exit 1
            fi
            TOPIC="$2"
            INSTALL_SCRIPT="$DOTFILES/$TOPIC/install.sh"
            if [[ -f "$INSTALL_SCRIPT" ]]; then
                echo "üîß Running install.sh for '$TOPIC'..."
                source "$INSTALL_SCRIPT"
                echo "‚úÖ Done installing '$TOPIC'"
                exit 0
            else
                echo "‚ùå No install.sh found for topic '$TOPIC'"
                echo "   Expected: $INSTALL_SCRIPT"
                echo "   Run 'dot list' to see available topics"
                exit 1
            fi
            ;;
        list)
            if [[ -z $DOTFILES ]]; then
                echo "‚ùå DOTFILES variable not set, exiting"
                exit 1
            fi
            echo "üìã Available topics with install.sh:"
            for script in "$DOTFILES"/*/install.sh; do
                if [[ -f "$script" ]]; then
                    topic=$(basename "$(dirname "$script")")
                    echo "   - $topic"
                fi
            done
            exit 0
            ;;
        status)
            echo "üìä Dotfiles Status"
            echo "=================="
            echo ""

            # Cache status (fast - just check files)
            cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles"
            echo "üíæ Shell Cache ($cache_dir)"
            if [[ -d "$cache_dir" ]]; then
                # Count source files for each cache type
                env_count=$(find "$DOTFILES" -maxdepth 2 -name 'bash_env' 2>/dev/null | wc -l | tr -d ' ')
                alias_count=$(find "$DOTFILES" -maxdepth 2 -name 'bash_aliases' 2>/dev/null | wc -l | tr -d ' ')
                comp_count=$(find "$DOTFILES" -maxdepth 2 -name 'bash_completion' 2>/dev/null | wc -l | tr -d ' ')

                for cache_file in "$cache_dir"/*.sh; do
                    [[ -f "$cache_file" ]] || continue
                    name=$(basename "$cache_file" .sh)
                    age_sec=$(( $(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null) ))
                    if [[ $age_sec -lt 60 ]]; then
                        age="${age_sec}s"
                    elif [[ $age_sec -lt 3600 ]]; then
                        age="$((age_sec / 60))m"
                    elif [[ $age_sec -lt 86400 ]]; then
                        age="$((age_sec / 3600))h"
                    else
                        age="$((age_sec / 86400))d"
                    fi
                    size=$(wc -c < "$cache_file" | tr -d ' ')
                    # Add source count based on cache type
                    case "$name" in
                        bash_env)        sources="$env_count sources, profile" ;;
                        bash_aliases)    sources="$alias_count sources, bashrc" ;;
                        bash_completion) sources="$comp_count sources, bashrc" ;;
                        *)               sources="" ;;
                    esac
                    printf "   %-18s %6s  %s ago  [%s]\n" "$name.sh" "${size}B" "$age" "$sources"
                done

                # Check shortcuts cache
                shortcuts_cache="$cache_dir/shortcuts.cache"
                if [[ -f "$shortcuts_cache" ]]; then
                    topic_count=$(wc -l < "$shortcuts_cache" | tr -d ' ')
                    size=$(wc -c < "$shortcuts_cache" | tr -d ' ')
                    age_sec=$(( $(date +%s) - $(stat -f %m "$shortcuts_cache" 2>/dev/null || stat -c %Y "$shortcuts_cache" 2>/dev/null) ))
                    if [[ $age_sec -lt 60 ]]; then
                        age="${age_sec}s"
                    elif [[ $age_sec -lt 3600 ]]; then
                        age="$((age_sec / 60))m"
                    elif [[ $age_sec -lt 86400 ]]; then
                        age="$((age_sec / 3600))h"
                    else
                        age="$((age_sec / 86400))d"
                    fi
                    printf "   %-18s %6s  %s ago  [%s]\n" "shortcuts.cache" "${size}B" "$age" "$topic_count topics"
                fi

                echo ""
                echo "   Run 'dot invalidate' to clear and regenerate on next shell"
            else
                echo "   (no cache - will generate on next shell start)"
            fi
            echo ""

            # Brewfile status (fast - just read file)
            BREWFILE="${XDG_DATA_HOME:-$HOME/.local/share}/Brewfile"
            echo "üì¶ Brewfile"
            if [[ -f "$BREWFILE" ]]; then
                formulae=$(grep -c '^brew ' "$BREWFILE" 2>/dev/null || echo 0)
                casks=$(grep -c '^cask ' "$BREWFILE" 2>/dev/null || echo 0)
                taps=$(grep -c '^tap ' "$BREWFILE" 2>/dev/null || echo 0)
                echo "   Path:     $BREWFILE"
                echo "   Taps:     $taps"
                echo "   Formulae: $formulae"
                echo "   Casks:    $casks"
            else
                echo "   Not found (run 'dot -x' to create)"
            fi
            echo ""

            # Homebrew status (fast - cached version)
            echo "üç∫ Homebrew"
            echo "   Prefix: $(brew --prefix)"
            # Use brew info which is faster than brew outdated
            installed=$(brew list --formula 2>/dev/null | wc -l | tr -d ' ')
            casks_installed=$(brew list --cask 2>/dev/null | wc -l | tr -d ' ')
            echo "   Installed: $installed formulae, $casks_installed casks"
            echo ""

            # XDG paths (fast)
            echo "üóÇÔ∏è  XDG Paths"
            echo "   CONFIG: ${XDG_CONFIG_HOME:-~/.config}"
            echo "   DATA:   ${XDG_DATA_HOME:-~/.local/share}"
            echo "   STATE:  ${XDG_STATE_HOME:-~/.local/state}"
            echo "   CACHE:  ${XDG_CACHE_HOME:-~/.cache}"
            echo ""

            # Topics summary (fast)
            if [[ -n $DOTFILES ]]; then
                echo "üìÅ Topics"
                for dir in "$DOTFILES"/*/; do
                    topic=$(basename "$dir")
                    [[ "$topic" == ".git" || "$topic" == "script" || "$topic" == "docs" ]] && continue

                    features=""
                    [[ -f "$dir/install.sh" ]] && features+="I"
                    [[ -f "$dir/brew_packages" ]] && features+="B"
                    [[ -f "$dir/bash_aliases" ]] && features+="A"
                    [[ -f "$dir/bash_env" ]] && features+="E"
                    [[ -f "$dir/bash_completion" ]] && features+="C"
                    [[ -d "$dir/config" ]] && features+="X"
                    [[ -f "$dir/bash_shortcuts" ]] && features+="K"

                    [[ -n "$features" ]] && printf "   %-12s [%s]\n" "$topic" "$features"
                done

                # Check config/ subdirectories for additional topics
                if [[ -d "$DOTFILES/config" ]]; then
                    for dir in "$DOTFILES/config"/*/; do
                        [[ -d "$dir" ]] || continue
                        topic=$(basename "$dir")

                        features=""
                        [[ -f "$dir/bash_shortcuts" ]] && features+="K"

                        [[ -n "$features" ]] && printf "   %-12s [%s]\n" "$topic" "$features"
                    done
                fi

                echo ""
                echo "   Legend: I=install B=brew A=aliases E=env C=completion X=config K=shortcuts"
            fi
            echo ""

            # Outdated packages (slowest - at the end)
            echo "üîÑ Outdated (run 'brew outdated' for full list)"
            outdated=$(timeout 5 brew outdated 2>/dev/null || echo "")
            if [[ -n "$outdated" ]]; then
                outdated_count=$(echo "$outdated" | wc -l | tr -d ' ')
                echo "   $outdated_count package(s) can be upgraded"
                echo "$outdated" | head -5 | while read -r line; do
                    echo "   ‚¨ÜÔ∏è  $line"
                done
                [[ $outdated_count -gt 5 ]] && echo "   ... and $((outdated_count - 5)) more"
            else
                echo "   ‚úÖ All up to date (or timed out)"
            fi

            exit 0
            ;;
        invalidate)
            cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles"
            if [[ -d "$cache_dir" ]]; then
                echo "üóëÔ∏è  Invalidating dotfiles caches..."

                # Remove .sh cache files
                for cache_file in "$cache_dir"/*.sh; do
                    if [[ -f "$cache_file" ]]; then
                        rm -f "$cache_file"
                        echo "   Removed: $(basename "$cache_file")"
                    fi
                done

                # Remove shortcuts cache
                if [[ -f "$cache_dir/shortcuts.cache" ]]; then
                    rm -f "$cache_dir/shortcuts.cache"
                    echo "   Removed: shortcuts.cache"
                fi

                # Remove aliases cache
                if [[ -f "$cache_dir/aliases.cache" ]]; then
                    rm -f "$cache_dir/aliases.cache"
                    echo "   Removed: aliases.cache"
                fi

                echo "‚úÖ Cache invalidated. Restart your shell to regenerate."
            else
                echo "‚ÑπÔ∏è  No cache directory found at: $cache_dir"
            fi
            exit 0
            ;;
        purge)
            # Check for --force flag
            FORCE=false
            if [[ "$2" == "-f" || "$2" == "--force" ]]; then
                FORCE=true
            fi
            echo "üîç Scanning for stale symlinks..."
            # Directories to scan for stale symlinks
            xdg_dirs=(
                "${XDG_CONFIG_HOME:-$HOME/.config}"
                "${XDG_DATA_HOME:-$HOME/.local/share}"
                "${XDG_STATE_HOME:-$HOME/.local/state}"
                "${XDG_CACHE_HOME:-$HOME/.cache}"
            )
            stale_links=()
            for dir in "${xdg_dirs[@]}"; do
                if [[ -d "$dir" ]]; then
                    while IFS= read -r link; do
                        [[ -n "$link" ]] && stale_links+=("$link")
                    done < <(find "$dir" -maxdepth 2 -type l ! -exec test -e {} \; -print 2>/dev/null)
                fi
            done
            if [[ ${#stale_links[@]} -eq 0 ]]; then
                echo "‚úÖ No stale symlinks found"
                exit 0
            fi
            echo "Found ${#stale_links[@]} stale symlink(s):"
            for link in "${stale_links[@]}"; do
                target=$(readlink "$link" 2>/dev/null || echo "unknown")
                echo "   üîó $link -> $target"
            done
            echo ""
            # Skip confirmation if --force
            if [[ "$FORCE" == true ]]; then
                REPLY="y"
            else
                read -p "Remove these stale symlinks? [Y/n] " -n 1 -r
                echo ""
                # Default to yes if empty
                [[ -z "$REPLY" ]] && REPLY="y"
            fi
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                for link in "${stale_links[@]}"; do
                    rm -f "$link"
                    echo "   Removed: $link"
                done
                echo "‚úÖ Stale symlinks purged"
            else
                echo "‚ÑπÔ∏è  No changes made"
            fi
            exit 0
            ;;
        clean)
            if [[ -z $DOTFILES ]]; then
                echo "‚ùå DOTFILES variable not set, exiting"
                exit 1
            fi
            CLEAN_SCRIPT="$DOTFILES/claude/bash_clean"
            if [[ -f "$CLEAN_SCRIPT" ]]; then
                source "$CLEAN_SCRIPT"
                exit 0
            else
                echo "‚ùå Clean script not found at: $CLEAN_SCRIPT"
                exit 1
            fi
            ;;
    esac
fi

# Parse command line arguments
USE_NEW=false
EXPORT_ONLY=false
SKIP_BUNDLE=false
VERBOSE=false
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--new)
            USE_NEW=true
            shift
            ;;
        -x|--export)
            EXPORT_ONLY=true
            shift
            ;;
        -s|--skip)
            SKIP_BUNDLE=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -f|--file)
            BREWFILE="$2"
            shift 2
            ;;
        -h|--help)
            print_usage
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done


if [[ -z $DOTFILES ]]  
then
    echo "‚ùå DOTFILES variable not set, exiting"
    exit 1
fi

# Check if export-only mode
if [[ "$EXPORT_ONLY" == true ]]; then
    echo "üìù Exporting current Homebrew installations to Brewfile..."
    if [[ "$VERBOSE" == true ]]; then
        brew bundle dump --file="$BREWFILE" --force --verbose
    else
        brew bundle dump --file="$BREWFILE" --force
    fi
    echo "‚úÖ Brewfile generated at $BREWFILE"
    exit 0
fi




# Check if Brewfile exists and --new flag is not set and --skip flag is not set
if [[ -f "$BREWFILE" && "$USE_NEW" == false && "$SKIP_BUNDLE" == false ]]; then
    echo "üì¶ Using existing Brewfile: $BREWFILE"
    echo "üîÑ Installing packages from Brewfile..."
    if [[ "$VERBOSE" == true ]]; then
        brew bundle --file="$BREWFILE" --verbose
    else
        brew bundle --file="$BREWFILE"
    fi
    exit 0
fi

# make sure we get the password early
if ! sudo -v; then
    echo "‚ùå sudo authentication failed or was cancelled"
    exit 1
fi

# start with brew itself
source "$DOTFILES/homebrew/brew_install.sh" 2>&1 || exit 1

# now process all topical brew packages
for src in $(find "$DOTFILES" -maxdepth 2 -name 'brew_packages')
do
    printf "  [ \033[00;34m..\033[0m ] Processing installer: $(basename $(dirname "$src"))\n"
    if [[ "$VERBOSE" == true ]]; then
        source "${src}" 2>&1 || exit 1
    else
        source "${src}" &>/dev/null || exit 1
    fi
done

# Finally, export the Brewfile
printf "  [ \033[00;34m..\033[0m ] Exporting current Homebrew installations to Brewfile...\n"
if [[ "$VERBOSE" == true ]]; then
    brew bundle dump --file="$BREWFILE" --force --verbose
else
    brew bundle dump --file="$BREWFILE" --force
fi
echo "‚úÖ Brewfile generated at $BREWFILE"
echo "‚úÖ All done!"
