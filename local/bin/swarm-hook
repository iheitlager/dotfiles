#!/usr/bin/env python3
"""
swarm-hook - Unified hook for swarm-daemon integration with Claude Code

Usage:
    swarm-hook register    # SessionStart: Register agent
    swarm-hook hook        # PostToolUse: Track requests
    swarm-hook model       # ModelChange: Track model switches
    swarm-hook -h          # Show this help

Context = git repository (one daemon per repo)
Agent ID = <repo> (simple for now, can extend to <repo>.agent-N)
State files: ~/.local/state/agent-context/<repo>/

Part of the swarm suite:
- swarm-daemon: Background daemon for monitoring and coordination
- swarm-hook: Claude Code hook for event emission
- swarm-context: (future) Context management utilities
"""

import json
import os
import subprocess
import sys
from pathlib import Path


def get_git_repo_context():
    """Get git repository name as context identifier."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True
        )
        repo_root = Path(result.stdout.strip())
        repo_name = repo_root.name.lstrip('.')

        # Check if this is a worktree
        git_dir = repo_root / ".git"
        if git_dir.is_file():
            parent_name = repo_root.parent.name
            if parent_name.endswith("-worktree"):
                repo_name = parent_name.replace("-worktree", "").lstrip('.')

        return repo_name
    except subprocess.CalledProcessError:
        return None


def get_agent_id(context):
    """Get agent ID from environment or generate from context with username."""
    agent_id = os.environ.get("AGENT_ID")
    if agent_id:
        return agent_id
    # Multi-user: include username for attribution
    whoami = os.environ.get("CLAUDE_USER") or os.environ.get("USER", "unknown")
    if context:
        return f"{whoami}-{context}"
    return whoami


def emit_event(agent_id, context, event_type, metadata):
    """Emit event to swarm-daemon (fire-and-forget)."""
    try:
        metadata_json = json.dumps(metadata)
        subprocess.run(
            ["swarm-daemon", "hook", event_type, metadata_json],
            env={**os.environ, "AGENT_ID": agent_id, "AGENT_CONTEXT": context or ""},
            capture_output=True,
            timeout=0.2,
            check=False
        )
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass  # Daemon not running or slow - that's OK


def cmd_register():
    """Handle SessionStart: Register agent with swarm-daemon."""
    context = get_git_repo_context()
    if not context:
        # Not in a git repo - allow but don't register
        print(json.dumps({}), flush=True)
        return

    agent_id = get_agent_id(context)

    # Emit AGENT_STARTUP event (fire-and-forget)
    metadata = {"context": context}
    emit_event(agent_id, context, "AGENT_STARTUP", metadata)

    # Return empty response (approve and continue)
    # Note: Setting env vars via hooks is not supported by Claude Code's schema
    print(json.dumps({}), flush=True)


def cmd_model():
    """Handle ModelChange: Track model switches."""
    # Read JSON input from stdin
    try:
        hook_input = json.loads(sys.stdin.read())
    except (json.JSONDecodeError, Exception):
        print(json.dumps({}), flush=True)
        return

    # Get context and agent ID
    context = get_git_repo_context()
    if not context:
        print(json.dumps({}), flush=True)
        return

    agent_id = get_agent_id(context)

    # Extract model information
    old_model = hook_input.get("old_model", "unknown")
    new_model = hook_input.get("new_model", "unknown")

    # Emit MODEL_CHANGE event
    metadata = {
        "old_model": old_model,
        "new_model": new_model,
        "pid": os.getpid(),
        "context": context
    }
    emit_event(agent_id, context, "MODEL_CHANGE", metadata)

    # Always allow the operation
    print(json.dumps({}), flush=True)


def cmd_hook():
    """Handle PostToolUse: Track request events."""
    # Read JSON input from stdin
    try:
        hook_input = json.loads(sys.stdin.read())
    except json.JSONDecodeError:
        print(json.dumps({}), flush=True)
        return
    except Exception:
        # Catch any other stdin reading errors
        print(json.dumps({}), flush=True)
        return

    # Get context and agent ID
    context = get_git_repo_context()
    if not context:
        print(json.dumps({}), flush=True)
        return

    agent_id = get_agent_id(context)

    # Extract tool information
    tool_name = hook_input.get("tool_name") or hook_input.get("tool", "unknown")

    # Extract parameters (nested under 'tool_input' key)
    params = hook_input.get("tool_input", {})

    # Emit REQUEST event with minimal metadata (fire-and-forget)
    metadata = {
        "tool": tool_name,
        "pid": os.getpid(),
        "context": context
    }
    emit_event(agent_id, context, "REQUEST", metadata)

    # Phase 3: Tool-specific event emission (ACTIVE - Enabled in Phase C of #14)
    # Emit specialized events based on tool type
    if tool_name == "Read":
        file_path = params.get("file_path", "unknown")
        metadata = {"file": file_path, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_READ", metadata)

    elif tool_name == "Edit":
        file_path = params.get("file_path", "unknown")
        # Try to estimate lines changed from old_string/new_string
        old_string = params.get("old_string", "")
        new_string = params.get("new_string", "")
        lines_changed = abs(len(new_string.splitlines()) - len(old_string.splitlines()))
        metadata = {"file": file_path, "lines": lines_changed, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_EDIT", metadata)

    elif tool_name == "Write":
        file_path = params.get("file_path", "unknown")
        content = params.get("content", "")
        lines = len(content.splitlines())
        metadata = {"file": file_path, "lines": lines, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_WRITE", metadata)

    elif tool_name == "Bash":
        command = params.get("command", "")
        # Detect specialized commands (git, test, lint)
        if "git commit" in command:
            emit_event(agent_id, context, "GIT_COMMIT", {"command": command[:100], "pid": os.getpid(), "context": context})
        elif "git push" in command:
            emit_event(agent_id, context, "GIT_PUSH", {"command": command[:100], "pid": os.getpid(), "context": context})
        elif "git rebase" in command:
            emit_event(agent_id, context, "GIT_REBASE", {"command": command[:100], "pid": os.getpid(), "context": context})
        # Detect test commands
        elif any(test_cmd in command for test_cmd in ["pytest", "npm test", "make test", "cargo test", "go test"]):
            emit_event(agent_id, context, "TEST_STARTED", {"command": command[:100], "pid": os.getpid(), "context": context})
        # Detect lint commands
        elif any(lint_cmd in command for lint_cmd in ["ruff", "eslint", "mypy", "pylint", "flake8", "black"]):
            emit_event(agent_id, context, "LINT_STARTED", {"command": command[:100], "pid": os.getpid(), "context": context})
        else:
            # Generic bash command
            emit_event(agent_id, context, "TOOL_BASH", {"command": command[:100], "pid": os.getpid(), "context": context})

    elif tool_name == "Grep":
        pattern = params.get("pattern", "unknown")
        metadata = {"pattern": pattern, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_GREP", metadata)

    elif tool_name == "Glob":
        pattern = params.get("pattern", "unknown")
        metadata = {"pattern": pattern, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_GLOB", metadata)

    elif tool_name == "Task":
        subagent = params.get("subagent_type", "unknown")
        metadata = {"subagent": subagent, "pid": os.getpid(), "context": context}
        emit_event(agent_id, context, "TOOL_TASK", metadata)

    # Always allow the operation (empty response = continue)
    print(json.dumps({}), flush=True)


def print_help():
    """Print help message."""
    print(__doc__)
    print("\nCommands:")
    print("  register    Register agent on session start (SessionStart hook)")
    print("              Emits: AGENT_STARTUP")
    print("              Returns: agent ID and context in environment")
    print()
    print("  hook        Track requests during session (PostToolUse hook)")
    print("              Emits: REQUEST events with tool, pid, context")
    print("              Always allows operation")
    print()
    print("  model       Track model changes (ModelChange hook)")
    print("              Emits: MODEL_CHANGE with old_model, new_model")
    print("              Always allows operation")
    print()
    print("Options:")
    print("  -h, --help  Show this help message")
    print()
    print("Files updated:")
    print("  ~/.local/state/agent-context/<repo>/events.log")
    print("  ~/.local/state/agent-context/<repo>/daemon/agent-state.yaml")
    print()
    print("Environment:")
    print("  AGENT_ID       Agent identifier (set by register, used by hook)")
    print("  AGENT_CONTEXT  Context/repo name (set by register)")


def main():
    """Main entry point."""
    try:
        if len(sys.argv) < 2:
            print("Usage: swarm-hook {register|hook|model|-h}", file=sys.stderr)
            sys.exit(1)

        command = sys.argv[1]

        if command in ("-h", "--help"):
            print_help()
            sys.exit(0)
        elif command == "register":
            cmd_register()
        elif command == "hook":
            cmd_hook()
        elif command == "model":
            cmd_model()
        else:
            print(f"Unknown command: {command}", file=sys.stderr)
            print("Usage: swarm-hook {register|hook|model|-h}", file=sys.stderr)
            sys.exit(1)
    except Exception:
        # Hooks should never fail - always allow the operation (empty response = continue)
        print(json.dumps({}), flush=True)
        sys.exit(0)


if __name__ == "__main__":
    main()
