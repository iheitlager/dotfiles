#!/usr/bin/python3
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

"""
skill-validate - Security validation for AI agent skills and instructions.
Version: 0.2.0

Based on vulnerability patterns from SkillScan research (arXiv:2601.10338)

Usage:
    skill-validate [OPTIONS] [PATH...]
    skill-validate                    # Scan default skill locations
    skill-validate ./my-skills/       # Scan specific directory
    skill-validate --strict file.md   # Strict mode (fail on medium+)
"""

import argparse
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterator

# ANSI Colors
RED = "\033[0;31m"
YELLOW = "\033[0;33m"
GREEN = "\033[0;32m"
BLUE = "\033[0;34m"
CYAN = "\033[0;36m"
MAGENTA = "\033[0;35m"
BOLD = "\033[1m"
DIM = "\033[2m"
NC = "\033[0m"


class ColorHelpFormatter(argparse.RawDescriptionHelpFormatter):
    """Colorful help formatter for argparse."""
    
    def _format_usage(self, usage, actions, groups, prefix):
        if prefix is None:
            prefix = f'{BOLD}Usage:{NC} '
        return super()._format_usage(usage, actions, groups, prefix)
    
    def _format_action_invocation(self, action):
        result = super()._format_action_invocation(action)
        return f'{CYAN}{result}{NC}'
    
    def _metavar_formatter(self, action, default_metavar):
        formatter = super()._metavar_formatter(action, default_metavar)
        def colored_formatter(tuple_size):
            result = formatter(tuple_size)
            if isinstance(result, tuple):
                return tuple(f'{YELLOW}{r}{NC}' for r in result)
            return f'{YELLOW}{result}{NC}'
        return colored_formatter
    
    def start_section(self, heading):
        super().start_section(f'{BOLD}{heading}{NC}')


# Default scan paths
DEFAULT_PATHS = [
    Path.home() / ".claude",
    Path.home() / ".claude" / "skills",
    Path.home() / ".claude" / "commands",
]

# File extensions to scan
SKILL_EXTENSIONS = {".md", ".yaml", ".yml", ".json", ".txt", ".skill"}
SKILL_FILENAMES = {"CLAUDE.md", "AGENTS.md", "SKILLS.md"}


@dataclass
class Finding:
    severity: str
    category: str
    file: str
    line: int
    description: str
    pattern_id: int
    match: str


@dataclass
class Pattern:
    severity: str
    category: str
    regex: re.Pattern
    pattern_id: int
    description: str


@dataclass
class ScanResults:
    total_files: int = 0
    findings: list = field(default_factory=list)

    @property
    def critical_count(self) -> int:
        return sum(1 for f in self.findings if f.severity == "CRITICAL")

    @property
    def high_count(self) -> int:
        return sum(1 for f in self.findings if f.severity == "HIGH")

    @property
    def medium_count(self) -> int:
        return sum(1 for f in self.findings if f.severity == "MEDIUM")

    @property
    def low_count(self) -> int:
        return sum(1 for f in self.findings if f.severity == "LOW")


# Compile all patterns once at module load
PATTERNS: list[Pattern] = []


def _init_patterns():
    """Initialize compiled regex patterns.
    
    Categories follow SkillScan taxonomy (arXiv:2601.10338):
    - P1: Instruction Override    - P2: Hidden Instructions
    - P3: Exfiltration Commands   - P4: Behavior Manipulation
    - E1: External Transmission   - E2: Env Variable Harvesting
    - E3: File System Enumeration - E4: Context Leakage
    - PE1: Excessive Permissions  - PE2: Sudo/Root Execution
    - PE3: Credential Access      - SC1: Unpinned Dependencies
    - SC2: External Script Fetch  - SC3: Obfuscated Code
    
    Additional categories for comprehensive coverage:
    - CODE: Code Injection        - CONTAINER: Container Escape
    - PERSIST: Persistence        - FS: Filesystem Risks
    """
    pattern_defs = [
        # === P1: INSTRUCTION OVERRIDE ===
        ("HIGH", "P1", r"ignore.*(previous|all|above|prior).*instructions", "Instruction override attempt"),
        ("HIGH", "P1", r"disregard.*(instructions|rules|guidelines)", "Instruction override attempt"),
        ("HIGH", "P1", r"new system prompt|new prompt:", "System prompt injection"),
        ("HIGH", "P1", r"forget (everything|what|your)", "Memory manipulation"),
        ("MEDIUM", "P1", r"\b(bypass|jailbreak)\b", "Security bypass mention"),
        ("MEDIUM", "P1", r"```system|<system>|<<SYS>>", "Delimiter injection"),

        # === P2: HIDDEN INSTRUCTIONS ===
        ("HIGH", "P2", r"<!--.*?(ignore|override|bypass|execute).*?-->", "Hidden directive in HTML comment"),
        ("HIGH", "P2", r"\[//\]:\s*#.*?(ignore|execute|bypass)", "Hidden directive in markdown comment"),
        ("HIGH", "P2", r"[\u200b\u200c\u200d\ufeff]", "Zero-width character (steganography)"),
        ("MEDIUM", "P2", r"/\*.*?(ignore|override|secret).*?\*/", "Hidden directive in code comment"),
        ("MEDIUM", "P2", r"#.*?(secret|hidden|ignore this)", "Suspicious inline comment"),

        # === P3: EXFILTRATION COMMANDS ===
        ("CRITICAL", "P3", r"curl.*\|.*bash|wget.*\|.*sh|curl.*\|.*sh", "Remote code execution (curl|bash)"),
        ("CRITICAL", "P3", r"/dev/tcp/", "Bash TCP socket (data exfiltration)"),
        ("CRITICAL", "P3", r"bash -i.*>&.*/dev/tcp", "Reverse shell"),
        ("HIGH", "P3", r"curl.*(--data|--upload|-d |-F )", "Data upload via curl"),
        ("HIGH", "P3", r"curl.*(-X POST|-X PUT)", "HTTP POST/PUT request"),
        ("HIGH", "P3", r"\bnc\s+-", "Netcat usage (potential reverse shell)"),
        ("HIGH", "P3", r"\bsocat\b", "Socat (bidirectional data transfer)"),
        ("HIGH", "P3", r"base64.*\|.*(curl|wget)", "Encoded data exfiltration"),
        ("HIGH", "P3", r"aws s3 (cp|sync|mv).*s3://", "AWS S3 upload"),
        ("HIGH", "P3", r"gsutil (cp|rsync)", "Google Cloud Storage upload"),
        ("HIGH", "P3", r"\bscp\b.*:", "SCP file transfer"),
        ("HIGH", "P3", r"\bftp\b|-ftp-", "FTP file transfer"),
        ("HIGH", "P3", r"ssh -R|ssh.*-R\s+\d+", "SSH reverse tunnel"),
        ("MEDIUM", "P3", r"\b(webhook|ngrok|pastebin)\b", "External service reference"),
        ("MEDIUM", "P3", r"\b(dig|nslookup)\b.*TXT", "DNS exfiltration"),

        # === P4: BEHAVIOR MANIPULATION ===
        ("HIGH", "P4", r"you are now|you're now|from now on you", "Role hijacking attempt"),
        ("HIGH", "P4", r"pretend (you are|to be|you're)", "Role pretending attack"),
        ("HIGH", "P4", r"\bDAN\b|do anything now", "DAN jailbreak attempt"),
        ("HIGH", "P4", r"developer mode|maintenance mode", "Mode switching attack"),
        ("HIGH", "P4", r"always (say yes|approve|accept|confirm)", "Forced approval pattern"),
        ("HIGH", "P4", r"(skip|bypass|disable).*(confirmation|prompt|approval|check)", "Confirmation bypass"),
        ("HIGH", "P4", r"execute without (asking|confirmation|approval)", "Unattended execution"),
        ("HIGH", "P4", r"don't (wait|ask|prompt|confirm)", "Interaction suppression"),
        ("HIGH", "P4", r"auto.*(approve|accept|confirm|execute)", "Automatic approval"),
        ("MEDIUM", "P4", r"no.*(human|user|manual).*(review|approval|check)", "Human review bypass"),

        # === E1: EXTERNAL TRANSMISSION ===
        ("HIGH", "E1", r"curl.*https?://[^/]+\.[^/]+", "HTTP request to external URL"),
        ("HIGH", "E1", r"wget\s+https?://", "Wget to external URL"),
        ("HIGH", "E1", r"requests?\.(get|post|put)\s*\(", "Python requests call"),
        ("MEDIUM", "E1", r"fetch\s*\(.*https?://", "JavaScript fetch call"),

        # === E2: ENV VARIABLE HARVESTING ===
        ("HIGH", "E2", r"\bprintenv\b|/proc/self/environ", "Environment variable dump"),
        ("HIGH", "E2", r"os\.environ|process\.env", "Environment access in code"),
        ("HIGH", "E2", r"\$\{?\w*SECRET\w*\}?|\$\{?\w*KEY\w*\}?|\$\{?\w*TOKEN\w*\}?", "Secret env var reference"),
        ("MEDIUM", "E2", r"env\s*\|", "Env piped to another command"),

        # === E3: FILE SYSTEM ENUMERATION ===
        ("HIGH", "E3", r"find\s+/\s+-name.*\.(pem|key|env|secret)", "Searching for secrets"),
        ("HIGH", "E3", r"ls\s+.*~/.ssh|ls\s+.*/.aws", "Listing credential directories"),
        ("MEDIUM", "E3", r"cat.*/etc/passwd", "User enumeration"),
        ("MEDIUM", "E3", r"ls -la.*/\.", "Hidden file enumeration"),
        ("MEDIUM", "E3", r"find.*-type\s+f.*-exec", "Find with exec (enumeration)"),

        # === E4: CONTEXT LEAKAGE ===
        ("HIGH", "E4", r"(send|transmit|upload|post).*(conversation|chat|history|context)", "Conversation exfiltration"),
        ("HIGH", "E4", r"(export|dump|save).*(messages?|prompts?|responses?)", "Message history export"),
        ("HIGH", "E4", r"(copy|include|attach).*(system prompt|instructions)", "System prompt leakage"),
        ("MEDIUM", "E4", r"log.*(user input|conversation|session)", "Session logging concern"),

        # === PE1: EXCESSIVE PERMISSIONS ===
        ("HIGH", "PE1", r"request.*all.*permissions?", "Excessive permission request"),
        ("HIGH", "PE1", r"(full|complete|total|unrestricted).*access", "Unrestricted access request"),
        ("MEDIUM", "PE1", r"permission.*everything|access.*everything", "Blanket permission request"),
        ("MEDIUM", "PE1", r"trust.*this.*(skill|tool|script|code)", "Trust manipulation"),
        ("HIGH", "PE1", r"--yes|--force|-y\b|-f\b.*dangerous", "Force flag in dangerous context"),

        # === PE2: SUDO/ROOT EXECUTION ===
        ("CRITICAL", "PE2", r"NOPASSWD", "Passwordless sudo configuration"),
        ("HIGH", "PE2", r"sudo -S", "Sudo with stdin password"),
        ("HIGH", "PE2", r"chmod 777|chmod \+s", "Dangerous permission change"),
        ("HIGH", "PE2", r"chown root", "Ownership change to root"),
        ("HIGH", "PE2", r"visudo|/etc/sudoers", "Sudoers modification"),
        ("HIGH", "PE2", r"/etc/passwd|/etc/shadow", "System password file access"),
        ("HIGH", "PE2", r"\.ssh/(authorized_keys|id_rsa|id_ed25519)", "SSH key manipulation"),
        ("HIGH", "PE2", r"python.*pty\.spawn", "PTY spawn (shell escape)"),

        # === PE3: CREDENTIAL ACCESS ===
        ("HIGH", "PE3", r"(password|api_key|api-key|secret|token)\s*[=:]\s*['\"][^'\"]+['\"]", "Hardcoded credential"),
        ("HIGH", "PE3", r"~/.aws/(credentials|config)", "AWS credentials access"),
        ("HIGH", "PE3", r"AWS_SECRET_ACCESS_KEY|AWS_ACCESS_KEY_ID", "AWS key reference"),
        ("HIGH", "PE3", r"GITHUB_TOKEN|GH_TOKEN", "GitHub token reference"),
        ("HIGH", "PE3", r"OPENAI_API_KEY|ANTHROPIC_API_KEY", "AI API key reference"),
        ("HIGH", "PE3", r"~/.netrc|\.netrc", "Netrc credentials file"),
        ("HIGH", "PE3", r"~/.npmrc|\.npmrc", "NPM credentials file"),
        ("MEDIUM", "PE3", r"cat\s+.*\.(env|pem|key)", "Reading secrets file"),
        ("MEDIUM", "PE3", r"git config --list|git config -l", "Git config disclosure"),
        ("MEDIUM", "PE3", r"cat.*\.env\b|cat.*\.env\.", "Env file disclosure"),

        # === SC1: UNPINNED DEPENDENCIES ===
        ("LOW", "SC1", r"pip install\s+[a-zA-Z][a-zA-Z0-9_-]+\s*$", "Unpinned pip package (no version)"),
        ("LOW", "SC1", r"npm install\s+[a-zA-Z@][^@\s]+\s*$", "Unpinned npm package (no version)"),
        ("LOW", "SC1", r"requirements\.txt.*[a-zA-Z]\s*$", "Unpinned requirement in requirements.txt"),
        ("MEDIUM", "SC1", r"(pip|npm|yarn)\s+install.*--upgrade", "Blind upgrade (supply chain risk)"),

        # === SC2: EXTERNAL SCRIPT FETCHING ===
        ("CRITICAL", "SC2", r"pip install.*(--trusted-host|-i http://)", "Untrusted package source"),
        ("CRITICAL", "SC2", r"npm config set registry", "NPM registry override"),
        ("HIGH", "SC2", r"pip install.*(github\.com|git\+)", "Direct Git package installation"),
        ("HIGH", "SC2", r"npm install.*github:", "Direct GitHub npm install"),
        ("HIGH", "SC2", r"go get\s+github\.com", "Direct Go package from GitHub"),
        ("HIGH", "SC2", r"cargo install.*--git", "Direct Cargo install from Git"),
        ("HIGH", "SC2", r"gem install.*--source", "Ruby gem from custom source"),
        ("HIGH", "SC2", r"pip install\s+\w{1,3}\b", "Suspiciously short package name (typosquatting)"),
        ("HIGH", "SC2", r"(requests?|numpy|pandas|django|flask)[0-9]|[0-9](requests?|numpy|pandas)", "Possible typosquat of popular package"),
        ("MEDIUM", "SC2", r"install.*from\s+https?://(?!pypi|npmjs|github|gitlab)", "Install from non-standard URL"),
        ("MEDIUM", "SC2", r"curl.*\|\s*(python|node|ruby|perl)", "Piped script execution"),

        # === SC3: OBFUSCATED CODE ===
        ("HIGH", "SC3", r"\\x[0-9a-fA-F]{2}.*\\x[0-9a-fA-F]{2}", "Hex-encoded strings"),
        ("HIGH", "SC3", r"chr\s*\(\s*\d+\s*\)\s*\+\s*chr", "Character concatenation obfuscation"),
        ("HIGH", "SC3", r"base64\s+(-d|--decode)", "Base64 decoding"),
        ("HIGH", "SC3", r"\bxxd\s+-r", "Hex decoding"),
        ("MEDIUM", "SC3", r"\\u[0-9a-fA-F]{4}.*\\u[0-9a-fA-F]{4}", "Unicode escape obfuscation"),

        # === CODE: CODE INJECTION (Additional) ===
        ("CRITICAL", "CODE", r"\beval\s*\(", "Eval execution"),
        ("CRITICAL", "CODE", r"\bexec\s*\(", "Exec execution"),
        ("CRITICAL", "CODE", r"os\.system\s*\(", "OS system call"),
        ("CRITICAL", "CODE", r"subprocess.*shell\s*=\s*True", "Subprocess shell injection"),
        ("HIGH", "CODE", r"pickle\.loads?", "Pickle deserialization (RCE risk)"),
        ("HIGH", "CODE", r"yaml\.load\s*\([^)]*\)(?!.*Loader)", "Unsafe YAML load"),
        ("HIGH", "CODE", r"yaml\.unsafe_load", "Unsafe YAML load"),
        ("HIGH", "CODE", r"__import__\s*\(", "Dynamic import"),
        ("HIGH", "CODE", r"compile\s*\(.*exec", "Dynamic code compilation"),

        # === CONTAINER: CONTAINER ESCAPE (Additional) ===
        ("CRITICAL", "CONTAINER", r"--privileged", "Privileged container"),
        ("CRITICAL", "CONTAINER", r"docker\.sock|/var/run/docker", "Docker socket access"),
        ("HIGH", "CONTAINER", r"/proc/self/root", "Container root escape"),
        ("HIGH", "CONTAINER", r"--cap-add\s*(SYS_ADMIN|ALL)", "Dangerous capability addition"),
        ("HIGH", "CONTAINER", r"--pid\s*=\s*host|--net\s*=\s*host", "Host namespace access"),

        # === FS: FILESYSTEM RISKS (Additional) ===
        ("CRITICAL", "FS", r"rm -rf /[^a-z]|rm -rf /\$", "Recursive root deletion"),
        ("HIGH", "FS", r"mkfs\.|dd if=.*of=/dev", "Disk formatting/direct write"),
        ("HIGH", "FS", r">\s*/dev/sd[a-z]|>\s*/dev/nvme", "Direct disk write"),

        # === PERSIST: PERSISTENCE (Additional) ===
        ("HIGH", "PERSIST", r"\b(crontab|/etc/cron)", "Cron job manipulation"),
        ("HIGH", "PERSIST", r"launchctl|LaunchAgents|LaunchDaemons", "macOS launch agent/daemon"),
        ("HIGH", "PERSIST", r"systemctl.*enable", "Systemd service enabling"),
        ("HIGH", "PERSIST", r"/etc/init\.d/|update-rc\.d", "Init script modification"),
        ("MEDIUM", "PERSIST", r"\.(bashrc|zshrc|profile|bash_profile)\b", "Shell RC modification"),
    ]

    for idx, (severity, category, pattern, description) in enumerate(pattern_defs, start=1):
        try:
            PATTERNS.append(Pattern(
                pattern_id=idx,
                severity=severity,
                category=category,
                regex=re.compile(pattern, re.IGNORECASE),
                description=description,
            ))
        except re.error as e:
            print(f"Warning: Invalid pattern '{pattern}': {e}", file=sys.stderr)


_init_patterns()


def is_skill_file(path: Path) -> bool:
    """Check if file should be scanned."""
    return path.suffix.lower() in SKILL_EXTENSIONS or path.name in SKILL_FILENAMES


def find_skill_files(root: Path) -> Iterator[Path]:
    """Recursively find all skill files in directory."""
    if root.is_file():
        if is_skill_file(root):
            yield root
        return

    if not root.is_dir():
        return

    for item in root.rglob("*"):
        if item.is_file() and is_skill_file(item):
            yield item


def scan_file(filepath: Path, results: ScanResults) -> None:
    """Scan a single file for security patterns."""
    results.total_files += 1

    try:
        content = filepath.read_text(encoding="utf-8", errors="ignore")
    except (OSError, IOError) as e:
        print(f"Warning: Could not read {filepath}: {e}", file=sys.stderr)
        return

    for line_num, line in enumerate(content.splitlines(), start=1):
        for pattern in PATTERNS:
            match = pattern.regex.search(line)
            if match:
                results.findings.append(Finding(
                    severity=pattern.severity,
                    category=pattern.category,
                    file=str(filepath),
                    line=line_num,
                    description=pattern.description,
                    pattern_id=pattern.pattern_id,
                    match=match.group(0)[:80],
                ))


def print_finding(finding: Finding, verbose: bool = False) -> None:
    """Print a single finding."""
    colors = {
        "CRITICAL": RED,
        "HIGH": RED,
        "MEDIUM": YELLOW,
        "LOW": BLUE,
    }
    color = colors.get(finding.severity, NC)

    print(f"{color}[{finding.severity}]{NC} {BOLD}{finding.category}/{finding.pattern_id}{NC}")
    print(f"  File: {finding.file}:{finding.line}")
    print(f"  Issue: {finding.description}")
    print(f"  {DIM}{finding.match}{NC}")
    print()


def print_summary(results: ScanResults) -> None:
    """Print scan summary."""
    print(f"{BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{NC}")
    print(f"{BOLD}Skill Validation Summary{NC}")
    print(f"{BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{NC}")
    print()
    print(f"Files scanned:  {results.total_files}")
    print(f"Total findings: {len(results.findings)}")
    print()

    if results.findings:
        print("By severity:")
        if results.critical_count:
            print(f"  {RED}CRITICAL: {results.critical_count}{NC}")
        if results.high_count:
            print(f"  {RED}HIGH:     {results.high_count}{NC}")
        if results.medium_count:
            print(f"  {YELLOW}MEDIUM:   {results.medium_count}{NC}")
        if results.low_count:
            print(f"  {BLUE}LOW:      {results.low_count}{NC}")
        print()

    if results.critical_count or results.high_count:
        print(f"{RED}⚠ Critical/High severity findings require immediate review{NC}")
    elif not results.findings:
        print(f"{GREEN}✓ No security findings detected{NC}")
    else:
        print(f"{YELLOW}Review medium/low findings for context-specific risks{NC}")


def print_patterns() -> None:
    """Print all vulnerability patterns being checked."""
    colors = {
        "CRITICAL": RED,
        "HIGH": RED,
        "MEDIUM": YELLOW,
        "LOW": BLUE,
    }
    
    # SkillScan taxonomy descriptions
    category_desc = {
        "P1": "Instruction Override",
        "P2": "Hidden Instructions",
        "P3": "Exfiltration Commands",
        "P4": "Behavior Manipulation",
        "E1": "External Transmission",
        "E2": "Env Variable Harvesting",
        "E3": "File System Enumeration",
        "E4": "Context Leakage",
        "PE1": "Excessive Permissions",
        "PE2": "Sudo/Root Execution",
        "PE3": "Credential Access",
        "SC1": "Unpinned Dependencies",
        "SC2": "External Script Fetch",
        "SC3": "Obfuscated Code",
        "CODE": "Code Injection",
        "CONTAINER": "Container Escape",
        "FS": "Filesystem Risks",
        "PERSIST": "Persistence",
    }
    
    print(f"{BOLD}Vulnerability Patterns ({len(PATTERNS)} total){NC}")
    print(f"{BOLD}Based on SkillScan taxonomy (arXiv:2601.10338){NC}")
    print(f"{BOLD}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━{NC}")
    print()
    
    current_category = None
    for p in PATTERNS:
        if p.category != current_category:
            current_category = p.category
            desc = category_desc.get(current_category, "")
            print(f"{BOLD}{current_category}: {desc}{NC}")
        
        color = colors.get(p.severity, NC)
        print(f"  {color}{p.pattern_id:2d}. [{p.severity:8s}]{NC} {p.description}")
        print(f"      {DIM}{p.regex.pattern}{NC}")
    print()


def output_json(results: ScanResults) -> None:
    """Output results as JSON."""
    output = [
        {
            "severity": f.severity,
            "category": f.category,
            "file": f.file,
            "line": f.line,
            "description": f.description,
            "match": f.match,
        }
        for f in results.findings
    ]
    print(json.dumps(output, indent=2))


def generate_hashes(paths: list[Path]) -> None:
    """Generate SHA256 hashes for skill files."""
    for path in paths:
        for filepath in find_skill_files(path):
            try:
                content = filepath.read_bytes()
                file_hash = hashlib.sha256(content).hexdigest()
                print(f"{file_hash}  {filepath}")
            except (OSError, IOError):
                pass


def check_integrity(hash_file: Path) -> None:
    """Check file integrity against baseline."""
    if not hash_file.exists():
        print(f"{YELLOW}No integrity baseline found at {hash_file}{NC}")
        print("Generate with: skill-validate --generate-hashes > ~/.local/state/skill-hashes.sha256")
        return

    print(f"{BLUE}Checking file integrity...{NC}")
    changed = 0

    for line in hash_file.read_text().splitlines():
        if not line.strip():
            continue
        parts = line.split("  ", 1)
        if len(parts) != 2:
            continue

        expected_hash, file_path = parts
        filepath = Path(file_path)

        if filepath.exists():
            current_hash = hashlib.sha256(filepath.read_bytes()).hexdigest()
            if current_hash != expected_hash:
                print(f"{RED}[MODIFIED]{NC} {file_path}")
                changed += 1
        else:
            print(f"{YELLOW}[MISSING]{NC} {file_path}")
            changed += 1

    if changed == 0:
        print(f"{GREEN}✓ All skill files match integrity baseline{NC}")
    else:
        print(f"{RED}✗ {changed} file(s) differ from baseline{NC}")
    print()


def main():
    parser = argparse.ArgumentParser(
        description=f"{BOLD}Validate AI agent skills for security vulnerabilities.{NC}",
        formatter_class=ColorHelpFormatter,
        epilog=f"""
{BOLD}Vulnerability Categories:{NC}
    {RED}1. Prompt Injection{NC}     - Attempts to override system instructions
    {YELLOW}2. Data Exfiltration{NC}    - Unauthorized data transmission
    {MAGENTA}3. Privilege Escalation{NC} - Elevated permission acquisition
    {CYAN}4. Supply Chain{NC}         - Malicious dependency introduction

{BOLD}Examples:{NC}
    {DIM}${NC} skill-validate                          {DIM}# Scan default locations{NC}
    {DIM}${NC} skill-validate ~/.claude/skills/        {DIM}# Scan specific directory{NC}
    {DIM}${NC} skill-validate --strict --verbose .     {DIM}# Strict scan with details{NC}
    {DIM}${NC} skill-validate --json > report.json     {DIM}# JSON output for CI/CD{NC}
        """,
    )
    parser.add_argument("paths", nargs="*", help="Paths to scan (default: common skill locations)")
    parser.add_argument("--strict", action="store_true", help="Exit with error on medium+ severity")
    parser.add_argument("-v", "--verbose", action="store_true", help="Show matched patterns")
    parser.add_argument("-i", "--info", action="store_true", help="Show vulnerability patterns")
    parser.add_argument("--json", action="store_true", help="Output as JSON")
    parser.add_argument("--integrity", action="store_true", help="Check file integrity")
    parser.add_argument("--generate-hashes", action="store_true", help="Generate integrity hashes")

    args = parser.parse_args()

    # Determine paths to scan
    scan_paths = [Path(p) for p in args.paths] if args.paths else DEFAULT_PATHS

    # Handle hash generation
    if args.generate_hashes:
        generate_hashes(scan_paths)
        return 0

    # Show patterns info
    if args.info:
        print_patterns()
        return 0

    # Header
    if not args.json:
        print(f"{BOLD}Skill Security Validator{NC}")
        print(f"{DIM}Based on SkillScan vulnerability taxonomy (arXiv:2601.10338){NC}")
        print()

    # Integrity check
    if args.integrity:
        check_integrity(Path.home() / ".local" / "state" / "skill-hashes.sha256")

    # Scan
    results = ScanResults()

    for path in scan_paths:
        if path.exists():
            if not args.json:
                print(f"{BLUE}Scanning: {path}{NC}")
            for filepath in find_skill_files(path):
                scan_file(filepath, results)

    # Output
    if args.json:
        output_json(results)
    else:
        for finding in results.findings:
            print_finding(finding, verbose=args.verbose)
        print_summary(results)

    # Exit code
    if args.strict:
        if results.critical_count or results.high_count or results.medium_count:
            return 1
    else:
        if results.critical_count or results.high_count:
            return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
