#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0
#
# spec - Interactive OpenSpec browser with fzf and markdown rendering
#
# Usage:
#   spec          Interactive fzf browser
#   spec list     List all specs with metadata and requirements
#   spec --help   Show help message

set -e

# Source shared utilities
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../lib/shell-common.sh"

# Additional colors not in shell-common
readonly GRAY='\033[90m'
readonly RESET="$NC"  # Alias for consistency with existing code

# Find the spec directory (tries multiple variants)
find_spec_dir() {
    local candidates=(".openspec" "openspec" ".specs" "specs" ".spec" "spec")

    # First, check if we're in a git repository
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        local git_root
        git_root="$(git rev-parse --show-toplevel 2>/dev/null)"

        if [ -n "$git_root" ]; then
            for dir in "${candidates[@]}"; do
                if [ -d "$git_root/$dir" ]; then
                    echo "$git_root/$dir"
                    return 0
                fi
            done
        fi
    fi

    # If not in git or specs not found in git root, search up the directory tree
    local current_dir="$PWD"
    while [ "$current_dir" != "/" ]; do
        for dir in "${candidates[@]}"; do
            if [ -d "$current_dir/$dir" ]; then
                echo "$current_dir/$dir"
                return 0
            fi
        done
        current_dir="$(dirname "$current_dir")"
    done

    # Check DOTFILES as fallback
    if [ -n "${DOTFILES:-}" ]; then
        for dir in "${candidates[@]}"; do
            if [ -d "$DOTFILES/$dir" ]; then
                echo "$DOTFILES/$dir"
                return 0
            fi
        done
    fi

    return 1
}

# Find all spec files within the spec directory
# Supports two patterns:
#   1. Directory-based: specs/001-topic/spec.md
#   2. Named files: category/topic.spec.md
find_spec_files() {
    local spec_dir="$1"
    local spec_files=()

    # Pattern 1: Find spec.md files (one per directory)
    while IFS= read -r -d '' file; do
        spec_files+=("$file")
    done < <(find "$spec_dir" -name "spec.md" -type f -print0 2>/dev/null)

    # Pattern 2: Find *.spec.md files (multiple specs per category)
    while IFS= read -r -d '' file; do
        spec_files+=("$file")
    done < <(find "$spec_dir" -name "*.spec.md" -type f -print0 2>/dev/null)

    # Remove duplicates and sort
    printf '%s\n' "${spec_files[@]}" | sort -u
}

# Check if directory names follow numbered pattern (NNN-name)
check_numbering() {
    local dir_name="$1"
    if [[ "$dir_name" =~ ^[0-9]{3,}- ]]; then
        return 0  # Has numbering
    else
        return 1  # No numbering
    fi
}

# Analyze numbering consistency across all specs
analyze_numbering() {
    local spec_dir="$1"
    local spec_files
    spec_files="$(find_spec_files "$spec_dir")"

    local total=0
    local numbered=0
    local unnumbered=0

    while read -r spec_file; do
        [ -z "$spec_file" ] && continue
        ((total++))

        local dir_name
        dir_name="$(basename "$(dirname "$spec_file")")"

        if check_numbering "$dir_name"; then
            ((numbered++))
        else
            ((unnumbered++))
        fi
    done <<< "$spec_files"

    # Return status: 0=all numbered, 1=mixed, 2=none numbered
    if [ "$total" -eq 0 ]; then
        return 3  # No specs
    elif [ "$unnumbered" -eq 0 ]; then
        return 0  # All numbered
    elif [ "$numbered" -eq 0 ]; then
        return 2  # None numbered
    else
        return 1  # Mixed
    fi
}

# Extract metadata from spec file header
parse_spec_metadata() {
    local spec_file="$1"
    local field="$2"

    grep "^\*\*${field}:\*\*" "$spec_file" 2>/dev/null | \
        sed "s/^\*\*${field}:\*\* //" | \
        head -1
}

# Get the spec title (first # heading, or derive from filename)
get_spec_title() {
    local spec_file="$1"
    local title

    # Try to get title from file content
    title=$(grep "^# " "$spec_file" 2>/dev/null | head -1 | sed 's/^# //')

    # Fallback: derive from filename for *.spec.md pattern
    if [ -z "$title" ]; then
        local basename_file
        basename_file=$(basename "$spec_file")

        if [[ "$basename_file" == *.spec.md ]]; then
            # Convert auth.spec.md -> Auth Specification
            title=$(echo "${basename_file%.spec.md}" | sed 's/-/ /g' | sed 's/\b\w/\u&/g')
            title="$title Specification"
        else
            # For spec.md files, use directory name
            local dirname_file
            dirname_file=$(basename "$(dirname "$spec_file")")
            # Remove leading numbers (001-dotfiles -> Dotfiles)
            dirname_file=$(echo "$dirname_file" | sed 's/^[0-9]*-//' | sed 's/-/ /g' | sed 's/\b\w/\u&/g')
            title="$dirname_file Specification"
        fi
    fi

    echo "$title"
}

# Get relative path from spec directory
get_relative_path() {
    local spec_dir="$1"
    local spec_file="$2"
    echo "${spec_file#$spec_dir/}"
}

# Extract all requirements from a spec file
parse_spec_requirements() {
    local spec_file="$1"

    # Find all "### Requirement:" lines with line numbers
    grep -n "^### Requirement:" "$spec_file" 2>/dev/null | \
        sed 's/^\([0-9]*\):### Requirement: /\1:/'
}

# Get line number for a requirement
get_requirement_line() {
    local spec_file="$1"
    local requirement="$2"

    grep -n "^### Requirement: ${requirement}$" "$spec_file" 2>/dev/null | \
        cut -d: -f1 | head -1
}

# Determine markdown formatter
# If RAW_MODE=true, use bat for syntax highlighting only
get_markdown_formatter() {
    if [ "${RAW_MODE:-false}" = "true" ]; then
        # Raw mode: use bat for syntax highlighting
        if has_cmd bat; then
            echo "bat --style=plain --color=always --language=markdown"
        else
            echo "cat"
        fi
    else
        # Default: use glow for beautiful markdown rendering
        if has_cmd glow; then
            echo "glow -s dark --tui"
        elif has_cmd bat; then
            echo "bat --style=plain --color=always --language=markdown"
        else
            echo "cat"
        fi
    fi
}

# Render markdown with highlighting at specific line
render_markdown() {
    local file="$1"
    local line="${2:-1}"
    local formatter
    formatter="$(get_markdown_formatter)"

    if [[ "$formatter" == glow* ]]; then
        # glow renders beautifully but doesn't support line highlighting
        $formatter "$file"
    elif [[ "$formatter" == bat* ]]; then
        # bat can highlight specific lines
        $formatter --highlight-line="$line" "$file"
    else
        # cat fallback
        $formatter "$file"
    fi
}

# Show compact status overview
show_status() {
    local spec_dir="$1"

    # Find all spec.md files using the flexible finder
    local spec_files
    spec_files=$(find_spec_files "$spec_dir")

    local file_count
    file_count=$(echo "$spec_files" | grep -c "spec.md" || echo "0")

    local total_reqs=0

    echo -e "${BOLD}OpenSpec Status${RESET} ${GRAY}($spec_dir)${RESET}\n"
    echo -e "Files: ${GREEN}$file_count${RESET}\n"

    # Check numbering and provide feedback
    local numbering_status=0
    analyze_numbering "$spec_dir" || numbering_status=$?

    case $numbering_status in
        0)
            echo -e "${GREEN}‚úì${RESET} All specs use numbered directories (NNN-name)\n"
            ;;
        1)
            echo -e "${YELLOW}‚ö†${RESET} ${YELLOW}Mixed numbering:${RESET} Some specs use numbered directories (NNN-name), others don't"
            echo -e "  ${GRAY}Consider adding numbers to all for explicit ordering${RESET}\n"
            ;;
        2)
            echo -e "${YELLOW}‚Ñπ${RESET} ${GRAY}No numbered directories found${RESET}"
            echo -e "  ${GRAY}Tip: Use numbered prefixes (001-name, 002-name) for explicit ordering${RESET}\n"
            ;;
    esac

    # Table header
    printf "${BOLD}%-50s  %-8s  %-12s  %s${RESET}\n" "Specification" "Version" "Status" "Reqs"
    printf "%s\n" "$(printf '‚îÄ%.0s' {1..80})"

    # Process each spec file (using process substitution to avoid subshell)
    while read -r spec_file; do
        [ -z "$spec_file" ] && continue

        local title
        title="$(get_spec_title "$spec_file")"

        local dir_name
        dir_name="$(basename "$(dirname "$spec_file")")"

        # Show directory name if unnumbered, or just title if numbered
        local display_name
        if check_numbering "$dir_name"; then
            display_name="$title"
        else
            display_name="$title ${GRAY}[$dir_name]${RESET}"
        fi

        # Truncate if too long
        if [ ${#display_name} -gt 50 ]; then
            display_name="${display_name:0:47}..."
        fi

        local version
        version="$(parse_spec_metadata "$spec_file" "Version")"
        [ -z "$version" ] && version="-"

        local status
        status="$(parse_spec_metadata "$spec_file" "Status")"
        [ -z "$status" ] && status="-"

        local req_count
        req_count=$(parse_spec_requirements "$spec_file" | wc -l | tr -d ' ')
        [ -z "$req_count" ] && req_count=0

        total_reqs=$((total_reqs + req_count))

        printf "%-50s  ${CYAN}%-8s${RESET}  ${GREEN}%-12s${RESET}  ${YELLOW}%s${RESET}\n" \
            "$display_name" "$version" "$status" "$req_count"
    done <<< "$spec_files"

    echo ""
    echo -e "Total Requirements: ${BOLD}${YELLOW}$total_reqs${RESET}"
}

# List all specs in plain text format
list_specs() {
    local spec_dir="$1"

    # Check numbering and provide feedback
    local numbering_status=0
    analyze_numbering "$spec_dir" || numbering_status=$?

    case $numbering_status in
        1)
            echo -e "${YELLOW}‚ö† Mixed numbering detected:${RESET} Some specs use numbered directories, others don't"
            echo -e "${GRAY}Consider adding numbered prefixes (001-, 002-, 003-) to all specs for explicit ordering${RESET}\n"
            ;;
        2)
            echo -e "${GRAY}Tip: Use numbered directory prefixes (001-name, 002-name) for explicit ordering${RESET}\n"
            ;;
    esac

    # Find all spec.md files using the flexible finder
    find_spec_files "$spec_dir" | while read -r spec_file; do
        [ -z "$spec_file" ] && continue

        local rel_path
        rel_path="$(get_relative_path "$spec_dir" "$spec_file")"

        local title
        title="$(get_spec_title "$spec_file")"

        local domain
        domain="$(parse_spec_metadata "$spec_file" "Domain")"

        local version
        version="$(parse_spec_metadata "$spec_file" "Version")"

        local status
        status="$(parse_spec_metadata "$spec_file" "Status")"

        # Check if directory is numbered
        local dir_name
        dir_name="$(basename "$(dirname "$spec_file")")"
        local numbering_indicator=""
        if ! check_numbering "$dir_name"; then
            numbering_indicator=" ${YELLOW}[unnumbered]${RESET}"
        fi

        # Print spec header
        echo -e "${BOLD}${GREEN}${title}${RESET}${numbering_indicator}"
        echo -e "  ${GRAY}Path:${RESET}    $rel_path"
        [ -n "$domain" ] && echo -e "  ${GRAY}Domain:${RESET}  $domain"
        [ -n "$version" ] && echo -e "  ${GRAY}Version:${RESET} $version"
        [ -n "$status" ] && echo -e "  ${GRAY}Status:${RESET}  $status"

        # Parse and list requirements
        local requirements
        requirements="$(parse_spec_requirements "$spec_file")"

        if [ -n "$requirements" ]; then
            echo -e "\n  ${CYAN}Requirements:${RESET}"
            echo "$requirements" | while IFS=: read -r line_num req_name; do
                echo -e "    ${YELLOW}‚Ä¢${RESET} $req_name ${GRAY}(line $line_num)${RESET}"
            done
        fi

        echo ""
    done
}

# Build fzf selection list with file and requirements
build_fzf_list() {
    local spec_dir="$1"

    find_spec_files "$spec_dir" | while read -r spec_file; do
        [ -z "$spec_file" ] && continue

        local rel_path
        rel_path="$(get_relative_path "$spec_dir" "$spec_file")"

        local title
        title="$(get_spec_title "$spec_file")"

        local domain
        domain="$(parse_spec_metadata "$spec_file" "Domain")"

        # Print file entry
        echo "FILE|$spec_file|1|$rel_path|$title|$domain"

        # Print requirement entries
        parse_spec_requirements "$spec_file" | while IFS=: read -r line_num req_name; do
            echo "REQ|$spec_file|$line_num|$rel_path|$req_name|$title"
        done
    done
}

# Format entry for fzf display
# Includes hidden line number field for preview scrolling
format_fzf_entry() {
    local type="$1"
    local rel_path="$2"
    local name="$3"
    local meta="$4"
    local line="$5"

    if [ "$type" = "FILE" ]; then
        printf "%s|%-50s  %s\n" "$line" "üìÑ $name" "$meta"
    else
        printf "%s|   %-47s  %s\n" "$line" "‚îî‚îÄ $name" "$meta"
    fi
}

# Interactive fzf browser
fzf_browser() {
    local spec_dir="$1"

    # Check if fzf is available
    if ! has_cmd fzf; then
        error "fzf is not installed. Install it with: brew install fzf"
        return 1
    fi

    # Build selection list
    local fzf_input
    fzf_input="$(build_fzf_list "$spec_dir")"

    if [ -z "$fzf_input" ]; then
        error "No spec files found in $spec_dir"
        return 1
    fi

    # Format for display and pass through fzf
    local selected
    selected="$(echo "$fzf_input" | while IFS='|' read -r type file line rel_path name meta; do
        format_fzf_entry "$type" "$rel_path" "$name" "$meta" "$line"
        echo "$type|$file|$line" >> /tmp/spec-fzf-data-$$
    done | fzf \
        --ansi \
        --height=100% \
        --layout=reverse \
        --border \
        --delimiter='|' \
        --with-nth=2.. \
        --prompt="OpenSpec > " \
        --header="Enter: view | Ctrl-/: zoom | Ctrl-D: scroll down | Ctrl-U: scroll up" \
        --preview="
            line=\$(sed -n \"\$(({n}+1))p\" /tmp/spec-fzf-data-$$ | cut -d'|' -f3)
            file=\$(sed -n \"\$(({n}+1))p\" /tmp/spec-fzf-data-$$ | cut -d'|' -f2)
            $(get_markdown_formatter) --highlight-line=\"\$line\" \"\$file\" 2>/dev/null || cat \"\$file\"
        " \
        --preview-window='right:60%:wrap:+{1}-5' \
        --bind='ctrl-/:change-preview-window(80%|60%:wrap:+{1}-5)' \
        --bind='ctrl-d:preview-half-page-down' \
        --bind='ctrl-u:preview-half-page-up'
    )"

    # Get the selected file and line
    local selected_index
    selected_index="$(echo "$selected" | grep -n "^" /dev/stdin | cut -d: -f1)"

    if [ -n "$selected_index" ]; then
        local selected_data
        selected_data="$(sed -n "${selected_index}p" /tmp/spec-fzf-data-$$)"

        local file line
        file="$(echo "$selected_data" | cut -d'|' -f2)"
        line="$(echo "$selected_data" | cut -d'|' -f3)"

        # Cleanup temp file
        rm -f /tmp/spec-fzf-data-$$

        # Render the selected spec
        clear
        render_markdown "$file" "$line"
    else
        # Cleanup temp file
        rm -f /tmp/spec-fzf-data-$$
    fi
}

# Validate a single spec file
validate_spec_file() {
    local spec_file="$1"
    local spec_name="$(basename "$(dirname "$spec_file")")"
    local issues=0

    echo -e "${BOLD}Validating: $spec_name${RESET}\n"

    # Check title
    local title
    title="$(get_spec_title "$spec_file")"
    if [ -n "$title" ]; then
        echo -e "‚úÖ Title: ${GREEN}$title${RESET}"
    else
        echo -e "‚ùå ${RED}Missing title (# Heading)${RESET}"
        ((issues++))
    fi

    # Check frontmatter
    local domain version status date
    domain="$(parse_spec_metadata "$spec_file" "Domain")"
    version="$(parse_spec_metadata "$spec_file" "Version")"
    status="$(parse_spec_metadata "$spec_file" "Status")"
    date="$(parse_spec_metadata "$spec_file" "Date")"

    if [ -n "$domain" ] && [ -n "$version" ] && [ -n "$status" ] && [ -n "$date" ]; then
        echo -e "‚úÖ Frontmatter: ${GREEN}Complete${RESET}"
        echo -e "   Domain: $domain"
        echo -e "   Version: $version"
        echo -e "   Status: $status"
        echo -e "   Date: $date"
    else
        echo -e "‚ùå ${RED}Incomplete frontmatter${RESET}"
        [ -z "$domain" ] && echo -e "   Missing: Domain"
        [ -z "$version" ] && echo -e "   Missing: Version"
        [ -z "$status" ] && echo -e "   Missing: Status"
        [ -z "$date" ] && echo -e "   Missing: Date"
        ((issues++))
    fi

    # Check Overview section
    if grep -q "^## Overview" "$spec_file"; then
        echo -e "‚úÖ Overview: ${GREEN}Present${RESET}"

        # Check for Philosophy subsection (recommended)
        if grep -q "^### Philosophy" "$spec_file"; then
            echo -e "   ‚úÖ Philosophy subsection"
        else
            echo -e "   ‚ö†Ô∏è  ${YELLOW}Philosophy subsection missing (recommended)${RESET}"
        fi

        # Check for Key Capabilities subsection (recommended)
        if grep -q "^### Key Capabilities" "$spec_file"; then
            echo -e "   ‚úÖ Key Capabilities subsection"
        else
            echo -e "   ‚ö†Ô∏è  ${YELLOW}Key Capabilities subsection missing (recommended)${RESET}"
        fi
    else
        echo -e "‚ùå ${RED}Missing Overview section${RESET}"
        ((issues++))
    fi

    # Check RFC 2119 Keywords section
    if grep -q "^## RFC 2119 Keywords" "$spec_file"; then
        echo -e "‚úÖ RFC 2119 Keywords: ${GREEN}Present${RESET}"
    else
        echo -e "‚ùå ${RED}Missing RFC 2119 Keywords section${RESET}"
        ((issues++))
    fi

    # Check ADDED Requirements section
    if grep -q "^## ADDED Requirements" "$spec_file"; then
        echo -e "‚úÖ ADDED Requirements: ${GREEN}Present${RESET}"

        # Count requirements
        local req_count
        req_count=$(grep -c "^### Requirement:" "$spec_file")

        if [ "$req_count" -gt 0 ]; then
            echo -e "   ${GREEN}$req_count requirements found${RESET}"

            # Check for scenarios in requirements
            local scenario_count
            scenario_count=$(grep -c "^#### Scenario:" "$spec_file")
            echo -e "   ${GREEN}$scenario_count scenarios found${RESET}"

            # Check for Given-When-Then format
            local given_count when_count then_count
            given_count=$(grep -c "^- GIVEN" "$spec_file")
            when_count=$(grep -c "^- WHEN" "$spec_file")
            then_count=$(grep -c "^- THEN" "$spec_file")

            if [ "$given_count" -gt 0 ] && [ "$when_count" -gt 0 ] && [ "$then_count" -gt 0 ]; then
                echo -e "   ‚úÖ Given-When-Then format used"
            else
                echo -e "   ‚ö†Ô∏è  ${YELLOW}Some scenarios may lack proper Given-When-Then format${RESET}"
            fi

            # Check for RFC 2119 keywords in requirements
            if grep -q "MUST\|SHALL\|SHOULD\|MAY" "$spec_file"; then
                echo -e "   ‚úÖ RFC 2119 keywords used (MUST/SHALL/SHOULD/MAY)"
            else
                echo -e "   ‚ö†Ô∏è  ${YELLOW}RFC 2119 keywords not found in requirements${RESET}"
            fi
        else
            echo -e "   ‚ùå ${RED}No requirements found${RESET}"
            ((issues++))
        fi
    else
        echo -e "‚ùå ${RED}Missing ADDED Requirements section${RESET}"
        ((issues++))
    fi

    # Check References section (recommended)
    if grep -q "^## References" "$spec_file"; then
        echo -e "‚úÖ References: ${GREEN}Present${RESET}"
    else
        echo -e "‚ö†Ô∏è  ${YELLOW}References section missing (recommended)${RESET}"
    fi

    # Check for license/copyright
    if grep -qi "license\|copyright" "$spec_file"; then
        echo -e "‚úÖ License/Copyright: ${GREEN}Present${RESET}"
    else
        echo -e "‚ö†Ô∏è  ${YELLOW}License/Copyright missing (recommended)${RESET}"
    fi

    # Summary
    echo ""
    if [ "$issues" -eq 0 ]; then
        echo -e "${BOLD}${GREEN}‚úÖ VALID${RESET} - No critical issues found"
        return 0
    else
        echo -e "${BOLD}${RED}‚ùå INVALID${RESET} - $issues critical issue(s) found"
        return 1
    fi
}

# Validate all specs in directory
validate_all_specs() {
    local spec_dir="$1"
    local total=0
    local passed=0
    local failed=0
    local spec_files

    echo -e "${BOLD}Validating all OpenSpec files${RESET} ${GRAY}($spec_dir)${RESET}\n"

    # Check numbering and provide feedback
    local numbering_status=0
    analyze_numbering "$spec_dir" || numbering_status=$?

    case $numbering_status in
        1)
            echo -e "${YELLOW}‚ö† Numbering:${RESET} Mixed - some specs use numbered directories, others don't"
            echo -e "${GRAY}Recommendation: Add numbered prefixes (001-, 002-, 003-) to all specs for explicit ordering${RESET}\n"
            ;;
        2)
            echo -e "${GRAY}‚Ñπ Numbering:${RESET} No numbered directories found"
            echo -e "${GRAY}Tip: Use numbered prefixes (001-name, 002-name) for explicit ordering${RESET}\n"
            ;;
    esac

    # Find all spec.md files and store in array
    mapfile -t spec_files < <(find_spec_files "$spec_dir")
    total=${#spec_files[@]}

    # Validate each spec
    for spec_file in "${spec_files[@]}"; do
        [ -z "$spec_file" ] && continue

        if validate_spec_file "$spec_file"; then
            ((passed++))
        else
            ((failed++))
        fi

        echo ""
        echo "$(printf '‚îÄ%.0s' {1..70})"
        echo ""
    done

    # Overall summary
    echo -e "${BOLD}Validation Summary${RESET}\n"
    echo -e "Total specs: ${BOLD}$total${RESET}"
    echo -e "Passed: ${GREEN}$passed${RESET}"
    echo -e "Failed: ${RED}$failed${RESET}"

    if [ "$failed" -eq 0 ]; then
        echo -e "\n${BOLD}${GREEN}All specs are valid!${RESET} ‚úÖ"
        return 0
    else
        echo -e "\n${BOLD}${RED}Some specs have issues${RESET} ‚ùå"
        return 1
    fi
}

# Show template (plain output, no formatting)
show_template() {
    local template_file="$SCRIPT_DIR/../share/spec/template.md"

    if [ ! -f "$template_file" ]; then
        error "Template not found: $template_file"
        return 1
    fi

    cat "$template_file"
}

# Detect spec file pattern used in the directory
# Returns: "directory" for spec.md pattern, "named" for *.spec.md pattern
detect_spec_pattern() {
    local spec_dir="$1"
    local has_spec_md=false
    local has_named_spec=false

    # Check for spec.md files
    if find "$spec_dir" -name "spec.md" -type f -print -quit 2>/dev/null | grep -q .; then
        has_spec_md=true
    fi

    # Check for *.spec.md files
    if find "$spec_dir" -name "*.spec.md" -type f -print -quit 2>/dev/null | grep -q .; then
        has_named_spec=true
    fi

    if [ "$has_spec_md" = true ] && [ "$has_named_spec" = false ]; then
        echo "directory"
    elif [ "$has_named_spec" = true ] && [ "$has_spec_md" = false ]; then
        echo "named"
    elif [ "$has_spec_md" = true ] && [ "$has_named_spec" = true ]; then
        echo "mixed"
    else
        echo "directory"  # Default
    fi
}

# Create new spec from template
create_new_spec() {
    local spec_name="$1"
    local category="${2:-}"  # Optional category for named pattern
    local spec_dir

    if ! spec_dir="$(find_spec_dir)"; then
        error "No spec directory found (.openspec, openspec, .spec, spec, .specs, specs)"
        error "Run from a project with OpenSpec or set DOTFILES"
        return 1
    fi

    if [ -z "$spec_name" ]; then
        error "Usage: spec new <spec-name> [category]"
        error ""
        error "Examples:"
        error "  spec new authentication           # Creates directory-based spec"
        error "  spec new auth backend            # Creates backend/auth.spec.md"
        return 1
    fi

    # Detect existing pattern
    local pattern
    pattern=$(detect_spec_pattern "$spec_dir")

    # Determine target directory and file pattern
    local target_dir
    local new_file

    if [ -n "$category" ] || [ "$pattern" = "named" ]; then
        # Named file pattern: category/name.spec.md
        if [ -z "$category" ]; then
            category="general"
        fi
        target_dir="$spec_dir/$category"
        mkdir -p "$target_dir"
        new_file="$target_dir/${spec_name}.spec.md"

        if [ -f "$new_file" ]; then
            error "Spec file already exists: $new_file"
            return 1
        fi

        echo -e "${GRAY}Using named file pattern:${RESET} $category/${spec_name}.spec.md"
    else
        # Directory pattern: specs/NNN-name/spec.md
        if [ -d "$spec_dir/specs" ]; then
            target_dir="$spec_dir/specs"
        elif [ -d "$spec_dir/spec" ]; then
            target_dir="$spec_dir/spec"
        else
            target_dir="$spec_dir/specs"
            mkdir -p "$target_dir"
        fi

        # Check if existing specs use numbering
        local has_numbered=false
        local has_unnumbered=false
        local max_num=0

        if [ -d "$target_dir" ]; then
            while IFS= read -r -d '' dir; do
                local basename_dir
                basename_dir="$(basename "$dir")"

                if check_numbering "$basename_dir"; then
                    has_numbered=true
                    local num
                    num=$(echo "$basename_dir" | grep -oE '^[0-9]+' || echo "0")
                    if [ "$num" -gt "$max_num" ]; then
                        max_num=$num
                    fi
                else
                    has_unnumbered=true
                fi
            done < <(find "$target_dir" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null || true)
        fi

        # Decide whether to use numbering
        local dir_name
        local use_numbering=false

        if [ "$has_numbered" = true ] && [ "$has_unnumbered" = false ]; then
            use_numbering=true
        elif [ "$has_numbered" = true ] && [ "$has_unnumbered" = true ]; then
            echo -e "${YELLOW}‚ö† Mixed numbering detected:${RESET} Existing specs have inconsistent naming"
            echo -e "${GRAY}Recommendation: Use numbered prefix for consistency${RESET}"
            use_numbering=true
        fi

        if [ "$use_numbering" = true ]; then
            local next_num
            next_num=$(printf "%03d" $((max_num + 1)))
            dir_name="$next_num-$spec_name"
        else
            dir_name="$spec_name"
        fi

        local new_dir="$target_dir/$dir_name"
        new_file="$new_dir/spec.md"

        if [ -d "$new_dir" ]; then
            error "Spec directory already exists: $new_dir"
            return 1
        fi

        mkdir -p "$new_dir"
        echo -e "${GRAY}Using directory pattern:${RESET} $dir_name/spec.md"
    fi

    # Copy template
    local template_file="$SCRIPT_DIR/../share/spec/template.md"
    if [ ! -f "$template_file" ]; then
        error "Template not found: $template_file"
        return 1
    fi

    cp "$template_file" "$new_file"

    # Replace placeholders with today's date
    local today
    today=$(date +%Y-%m-%d)
    sed -i '' "s/\[YYYY-MM-DD\]/$today/" "$new_file"

    echo -e "${GREEN}Created new spec:${RESET} $new_file"
    echo -e "${GRAY}Next steps:${RESET}"
    echo "  1. Edit the spec file: \$EDITOR $new_file"
    echo "  2. Replace [placeholders] with your content"
    echo "  3. Add requirements and scenarios"
    echo "  4. Run: spec validate ${spec_name}"
}

# Print help text
print_help() {
    cat << 'EOF'
spec - Interactive OpenSpec browser

USAGE:
    spec              Interactive fzf browser (default)
    spec list         List all specs with metadata
    spec status       Show compact overview (count, version, status)
    spec validate     Validate all specs for compliance
    spec validate <spec>  Validate a specific spec by name
    spec template     Show the OpenSpec template
    spec new <name>   Create new spec from template
    spec --raw        Use raw mode (bat syntax highlighting only)
    spec --help       Show this help message

DESCRIPTION:
    The spec command helps you explore OpenSpec specification files
    in your project. It automatically finds spec directories using
    flexible matching and provides both list and interactive modes.

    Supported directory names:
    - .openspec, openspec (standard)
    - .specs, specs, .spec, spec (alternatives)

    Supported file patterns:
    1. Directory-based: specs/001-dotfiles-core/spec.md
       - One spec.md per topic directory
       - Numbering (001-, 002-) is optional but recommended
    2. Named files: backend/auth.spec.md, frontend/ui.spec.md
       - Multiple *.spec.md files per category
       - Category-based organization

    The command auto-detects which pattern is in use and adapts.

    Search Order:
    1. Git repository root (if inside a git repo)
    2. Current directory and parents (walking up)
    3. $DOTFILES directory (fallback)

INTERACTIVE MODE:
    The default fzf mode shows all spec files and their requirements.
    Use arrow keys to navigate, Enter to view, Ctrl-C to exit.

    The preview pane shows the full spec with beautiful markdown
    rendering (via glow) or raw syntax highlighting (via bat --raw).

RENDERING MODES:
    Default: Uses glow for beautiful markdown rendering
    --raw:   Uses bat for raw syntax highlighting only

    Fallback: If neither glow nor bat is available, uses cat

LIST MODE:
    Lists all spec files with:
    - File path
    - Domain, Version, Status
    - All requirements with line numbers

STATUS MODE:
    Shows a compact overview table with:
    - Total number of spec files
    - For each spec: Name, Version, Status, Requirement count
    - Total requirement count across all specs

VALIDATE MODE:
    Checks specs for structural compliance and best practices:
    - Required sections: Title, Frontmatter, Overview, RFC 2119, Requirements
    - Recommended sections: Philosophy, Key Capabilities, References, License
    - Requirement format: Proper scenarios with Given-When-Then
    - RFC 2119 keyword usage: MUST, SHALL, SHOULD, MAY

    Exit codes:
    - 0: All specs valid
    - 1: Some specs have issues

REQUIREMENTS:
    - bash 4.0+
    - fzf (for interactive mode)
    - glow (recommended, for beautiful markdown rendering)
    - bat (optional, for raw syntax highlighting with --raw)

ENVIRONMENT:
    DOTFILES    Fallback directory to search for specs

EXAMPLES:
    # Interactive browser (beautiful rendering with glow)
    spec

    # Interactive browser (raw syntax highlighting with bat)
    spec --raw

    # Compact overview
    spec status

    # List all specs with details
    spec list

    # Validate all specs
    spec validate

    # Validate a specific spec
    spec validate dotfiles-caching

    # Show the template
    spec template

    # Create new spec from template (directory pattern)
    spec new authentication-system

    # Create new spec with category (named file pattern)
    spec new auth backend

    # From any subdirectory in a git repo (finds git root)
    cd ~/myproject/src/components
    spec

    # Works even deep in the directory tree
    cd ~/.dotfiles/bash
    spec  # Finds .openspec in git root

EOF
}

# Main function
main() {
    # Parse flags
    RAW_MODE=false
    local command=""
    local spec_name=""
    local spec_category=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --raw)
                RAW_MODE=true
                shift
                ;;
            --help|-h|help)
                command="help"
                shift
                ;;
            list)
                command="list"
                shift
                ;;
            status)
                command="status"
                shift
                ;;
            validate)
                command="validate"
                shift
                # Check if a specific spec name was provided
                if [[ $# -gt 0 ]] && [[ "$1" != --* ]]; then
                    spec_name="$1"
                    shift
                fi
                ;;
            template)
                command="template"
                shift
                ;;
            new)
                command="new"
                shift
                if [[ $# -gt 0 ]]; then
                    spec_name="$1"
                    shift
                    # Check for optional category argument
                    if [[ $# -gt 0 ]] && [[ "$1" != --* ]]; then
                        spec_category="$1"
                        shift
                    fi
                fi
                ;;
            *)
                if [ -z "$command" ]; then
                    command="${1:-browse}"
                fi
                shift
                ;;
        esac
    done

    # Default to browse if no command specified
    command="${command:-browse}"
    export RAW_MODE

    case "$command" in
        list)
            local spec_dir
            if ! spec_dir="$(find_spec_dir)"; then
                error "No spec directory found"
                error "Searched for: .openspec, openspec, .specs, specs, .spec, spec"
                error "From: $PWD"
                [ -n "${DOTFILES:-}" ] && error "Also checked: $DOTFILES"
                return 1
            fi

            echo -e "${BOLD}OpenSpec Files${RESET} ${GRAY}($spec_dir)${RESET}\n"
            list_specs "$spec_dir"
            ;;

        status)
            local spec_dir
            if ! spec_dir="$(find_spec_dir)"; then
                error "No spec directory found"
                error "Searched for: .openspec, openspec, .specs, specs, .spec, spec"
                error "From: $PWD"
                [ -n "${DOTFILES:-}" ] && error "Also checked: $DOTFILES"
                return 1
            fi

            show_status "$spec_dir"
            ;;

        validate)
            local spec_dir
            if ! spec_dir="$(find_spec_dir)"; then
                error "No spec directory found"
                error "Searched for: .openspec, openspec, .specs, specs, .spec, spec"
                error "From: $PWD"
                [ -n "${DOTFILES:-}" ] && error "Also checked: $DOTFILES"
                return 1
            fi

            if [ -n "$spec_name" ]; then
                # Validate specific spec
                local spec_file
                spec_file=$(find_spec_files "$spec_dir" | grep -i "$spec_name" | head -1)

                if [ -z "$spec_file" ]; then
                    error "Spec not found: $spec_name"
                    error "Available specs:"
                    find_spec_files "$spec_dir" | while read -r f; do
                        [ -z "$f" ] && continue
                        echo "  - $(basename "$(dirname "$f")")"
                    done
                    return 1
                fi

                validate_spec_file "$spec_file"
            else
                # Validate all specs
                validate_all_specs "$spec_dir"
            fi
            ;;

        template)
            show_template
            ;;

        new)
            create_new_spec "$spec_name" "$spec_category"
            ;;

        help)
            print_help | show_help
            ;;

        browse|*)
            if [ "$command" != "browse" ]; then
                error "Unknown command: $command"
                error "Try: spec --help"
                return 1
            fi

            local spec_dir
            if ! spec_dir="$(find_spec_dir)"; then
                error "No spec directory found"
                error "Searched for: .openspec, openspec, .specs, specs, .spec, spec"
                error "From: $PWD"
                [ -n "${DOTFILES:-}" ] && error "Also checked: $DOTFILES"
                return 1
            fi

            fzf_browser "$spec_dir"
            ;;
    esac
}

main "$@"
