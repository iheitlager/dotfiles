#!/usr/bin/env bash
# launch-agents
# Version: 0.5.2
#
# Changelog:
# 0.5.2 Improved resilience: smart defaults, restart command, better session handling
# 0.5.1 Force clean now kills tmux and agent processes (claude/gemini/copilot)
# 0.5.0 Added -w/--workspace mode for simple claude + shell layout
# 0.4.2 Clarified tmux inter-agent communication (two separate send-keys required)
# 0.4.1 Improved skill handling and instructions
# 0.4.0 Multi-client support with copilot and gemini
# 0.3.0 Improved agent manifest and instructions
# 0.2.0 Uniform multi agent structure
# 0.1.0 Three agent coordinator/worker structure
#
# Usage: ./launch-agents [OPTIONS] COMMAND
# Run from within your git repo

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

show_version() {
    local version=$(sed -n '3p' "$0" | sed 's/.*Version: \([0-9.]*\).*/\1/')
    echo -e "${BOLD}launch-agents${NC} version ${GREEN}$version${NC}"
}

# Detect repo root and name
# If in a worktree, get the main repo (strip -worktree suffix)
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: Not in a git repository${NC}"
    exit 1
}

# Extract the base repo name (handle -worktree suffix and agent-N subdirs)
local_repo_name=$(basename "$REPO_ROOT")
local_repo_parent=$(dirname "$REPO_ROOT")
local_repo_grandparent=$(dirname "$local_repo_parent")

# Check if we're in an agent-N subdirectory of a -worktree directory
if [[ "$local_repo_parent" =~ ^(.+)-worktree$ ]]; then
    # We're in a worktree agent subdirectory (e.g., agent-1 inside code-analyzer-worktree)
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
    WORKTREE_ROOT="$local_repo_parent"
    REPO_PARENT="$local_repo_grandparent"
    REPO_ROOT="$REPO_PARENT/$REPO_NAME"
elif [[ "$local_repo_name" =~ ^(.+)-worktree$ ]]; then
    # We're in the worktree root directory
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
    WORKTREE_ROOT="$REPO_ROOT"
    REPO_PARENT=$(dirname "$REPO_ROOT")
    REPO_ROOT="$REPO_PARENT/$REPO_NAME"
else
    # We're in the main repo
    REPO_NAME="$local_repo_name"
    REPO_PARENT=$(dirname "$REPO_ROOT")
    WORKTREE_ROOT="$REPO_PARENT/${REPO_NAME}-worktree"
fi

# Paths derived from repo
SESSION="claude-$REPO_NAME"
SHARED_CONTEXT="$HOME/.local/state/agent-context/$REPO_NAME"

# Defaults
AGENT_COUNT=2
FORCE=false
VERBOSE=false
EQUAL_DISTRIBUTION=false
SKIP_PERMISSIONS="--permission-mode acceptEdits"
ALLOWED_TOOLS=''
# ALLOWED_TOOLS='--allowedTools "git *" --allowedTools "gh *" --allowedTools Read --allowedTools Write --allowedTools Edit --allowedTools Bash'

debug() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BOLD}${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

show_help() {
    local HELP="cat"
    if command -v bat >/dev/null 2>&1; then
        HELP="bat --plain --language=help"
    fi
    
    $HELP << EOF
Usage: launch-agents [OPTIONS] [COMMAND]

Launch and manage a Claude Code agent swarm.

Commands:
    (none)          Smart default: start or attach if already running
    start           Launch agents in tmux (prompt if already running)
    stop            Kill tmux session
    restart         Stop and restart the session
    attach          Attach to existing session
    workspace       Simple workspace: claude (opus) left, shell right
    clean           Remove worktrees (if branches merged and clean)
    info            Show status of agents, models, and tasks

Options:
    -n COUNT        Number of agents: 2, 3, 4, or 6 (default: 2)
    -r              Shortcut for 'restart'
    -a              Shortcut for 'attach'
    -w              Shortcut for 'workspace'
    --equal         For n=6, use equal distribution (Option 5) instead of default
    -v, --verbose   Print commands being executed
    --force         Force restart or clean (skips prompts)
    --yolo          Skip permission prompts (Claude agents only)
    -h, --help      Show this help message

Layouts:
    2 agents        agent-1 │ agent-2
    3 agents        agent-1 │ agent-2 / agent-3
    4 agents        agent-1 / agent-3 │ agent-2 / agent-4
    6 agents        agent-1 / agent-2 │ agent-3 / agent-4 │ agent-5 / agent-6

Clients & Models:
    claude          opus (agents 1-2)
    copilot         5.1-codex (agents 3-4)
    gemini          gemini-pro (agents 5-6)

Examples:
    launch-agents                   Smart default: start or attach
    launch-agents -n 4 start        Start 4 agents
    launch-agents -r                Restart session
    launch-agents workspace         Simple workspace (claude + shell)
    launch-agents -w                Shortcut for workspace
    launch-agents info              Show swarm status
    launch-agents stop              Stop all agents
    launch-agents clean             Remove merged worktrees
    launch-agents --force clean     Remove all worktrees

Paths:
    Worktrees       $WORKTREE_ROOT/agent-N/
    Shared state    $SHARED_CONTEXT/

Documentation:
    See ~/.dotfiles/docs/agent-system.md for detailed architecture and usage.
EOF
}

get_client() {
    local agent=$1
    local count=$2

    case $count in
        2|3|4)
            echo "claude"
            ;;
        6)
            if [[ "$EQUAL_DISTRIBUTION" == true ]]; then
                # Option 5: Equal pairs
                case $agent in
                    1|2) echo "claude" ;;
                    3|4) echo "copilot" ;;
                    5|6) echo "gemini" ;;
                esac
            else
                # Option 1: Default (4 claude, 1 copilot, 1 gemini)
                case $agent in
                    1|2|3|4) echo "claude" ;;
                    5) echo "copilot" ;;
                    6) echo "gemini" ;;
                esac
            fi
            ;;
    esac
}

get_model() {
    local agent=$1
    local count=$2

    case $count in
        2)
            echo "opus"
            ;;
        3)
            case $agent in
                1) echo "opus" ;;
                *) echo "sonnet" ;;
            esac
            ;;
        4)
            case $agent in
                1|2) echo "opus" ;;
                3)   echo "sonnet" ;;
                4)   echo "haiku" ;;
            esac
            ;;
        6)
            if [[ "$EQUAL_DISTRIBUTION" == true ]]; then
                # Option 5: Equal pairs
                case $agent in
                    1) echo "opus" ;;
                    2) echo "sonnet" ;;
                    3|4) echo "5.1-codex" ;;
                    5|6) echo "gemini-pro" ;;
                esac
            else
                # Option 1: Default (4 claude, 1 copilot, 1 gemini)
                case $agent in
                    1|2) echo "opus" ;;
                    3|4) echo "sonnet" ;;
                    5) echo "5.1-codex" ;;
                    6) echo "gemini-pro" ;;
                esac
            fi
            ;;
    esac
}

create_agent() {
    local agent=$1
    local client=$2
    local model=$3
    local worktree_path="$WORKTREE_ROOT/agent-$agent"

    if [[ -d "$worktree_path" ]]; then
        echo -e "  ${GREEN}✓${NC} agent-$agent ($client/$model) worktree exists"
    else
        mkdir -p "$WORKTREE_ROOT"

        local branch="agent-$agent"
        if ! git show-ref --verify --quiet "refs/heads/$branch"; then
            echo -e "  ${BLUE}→${NC} Creating branch: $branch"
            debug "git branch $branch"
            git branch "$branch"
        fi

        echo -e "  ${BLUE}→${NC} Creating worktree: agent-$agent"
        debug "git worktree add $worktree_path $branch"
        git worktree add "$worktree_path" "$branch"

        pushd "$worktree_path" > /dev/null
        
        # Link shared config if it exists in main repo
        if [[ "$client" == "claude" ]] && [[ -f "$REPO_ROOT/CLAUDE.md" ]] && [[ ! -f "$worktree_path/CLAUDE.md" ]]; then
            echo -e "  ${BLUE}→${NC} Linking CLAUDE.md"
            ln -s "$REPO_ROOT/CLAUDE.md" CLAUDE.md || true
        fi
        
        if command -v uv &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Setting up uv venv"
            uv venv
        fi
        
        popd > /dev/null

        echo -e "  ${GREEN}✓${NC} agent-$agent ready"
    fi

    # Generate agent instructions (always regenerated)
    create_agent_instructions $agent $client $model
}

old_get_model() {
    local agent=$1
    local count=$2

    case $count in
        2)
            echo "opus"
            ;;
        3)
            case $agent in
                1) echo "opus" ;;
                *) echo "sonnet" ;;
            esac
            ;;
        4)
            case $agent in
                1|2) echo "opus" ;;
                3)   echo "sonnet" ;;
                4)   echo "haiku" ;;
            esac
            ;;
    esac
}

setup_worktree() {
    local agent=$1
    local worktree_path="$WORKTREE_ROOT/agent-$agent"
    local branch="agent-$agent"

    if [[ -d "$worktree_path" ]]; then
        echo -e "  ${GREEN}✓${NC} agent-$agent worktree exists"
    else
        mkdir -p "$WORKTREE_ROOT"

        if ! git show-ref --verify --quiet "refs/heads/$branch"; then
            echo -e "  ${BLUE}→${NC} Creating branch: $branch"
            debug "git branch $branch"
            git branch "$branch"
        fi

        echo -e "  ${BLUE}→${NC} Creating worktree: agent-$agent"
        debug "git worktree add $worktree_path $branch"
        git worktree add "$worktree_path" "$branch"

        pushd "$worktree_path" > /dev/null
        
        # Link shared .claude config if it exists in main repo
        if [[ -f "$REPO_ROOT/CLAUDE.md" ]] && [[ ! -f "$worktree_path/CLAUDE.md" ]]; then
            echo -e "  ${BLUE}→${NC} Linking CLAUDE.md"
            ln -s "$REPO_ROOT/CLAUDE.md" CLAUDE.md || true
        fi
        
        if command -v uv &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Setting up uv venv"
            uv venv
        fi
        
        if command -v link_claude &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Linking claude skills"
            link_claude
        fi
        
        popd > /dev/null

        echo -e "  ${GREEN}✓${NC} agent-$agent ready"
    fi
}

ensure_gitignore_agents() {
    # Ensure AGENTS.md is in .gitignore (called once during setup)
    pushd "$REPO_ROOT" > /dev/null
    if [[ ! -f .gitignore ]]; then
        echo "AGENTS.md" > .gitignore
        git add .gitignore
        git commit -m "chore: add .gitignore with AGENTS.md"
    elif ! grep -q "^AGENTS.md$" .gitignore; then
        echo "AGENTS.md" >> .gitignore
        git add .gitignore
        git commit -m "chore: ignore AGENTS.md" || true
    fi
    popd > /dev/null
}

setup_shared_state() {
    mkdir -p "$SHARED_CONTEXT/tasks/pending"
    mkdir -p "$SHARED_CONTEXT/tasks/active"
    mkdir -p "$SHARED_CONTEXT/tasks/done"
    mkdir -p "$SHARED_CONTEXT/agents"

    if [[ ! -f "$SHARED_CONTEXT/events.log" ]]; then
        echo "# Agent Events Log - $REPO_NAME" > "$SHARED_CONTEXT/events.log"
        echo "# Format: timestamp | agent | action | task | summary" >> "$SHARED_CONTEXT/events.log"
        echo "" >> "$SHARED_CONTEXT/events.log"
    fi

    # Ensure AGENTS.md is gitignored
    ensure_gitignore_agents

    echo -e "${GREEN}✓${NC} Shared state ready"
}

create_agent_instructions() {
    local agent=$1
    local client=$2
    local model=$3
    local worktree_path="$WORKTREE_ROOT/agent-$agent"

    # Always write to AGENTS.md - injected via --append-system-prompt for Claude
    # CLAUDE.md in repo root remains for project-specific instructions
    cat > "$worktree_path/AGENTS.md" << EOF
# Agent Instructions

You are agent-$agent running $model (via $client) in a peer swarm for project: $REPO_NAME

## Identity

- Agent ID: agent-$agent
- Client: $client
- Model: $model
- Worktree: $worktree_path
- Shared state: $SHARED_CONTEXT

## Receiving Orders

Users may talk to you directly. When receiving a request:

1. Assess complexity:
   - Simple: docs, formatting, simple tests
   - Moderate: standard features, refactors
   - Complex: architecture, tricky bugs, design

2. Decide:
   - Small task + you match capability → do it directly
   - Large task → break into subtasks, create task files
   - Wrong capability tier → create task for better-suited agent

## Task Queue

Find work:
\`\`\`bash
ls $SHARED_CONTEXT/tasks/pending/
\`\`\`

Claim a task:
\`\`\`bash
mv $SHARED_CONTEXT/tasks/pending/task-XXX.yaml \\
   $SHARED_CONTEXT/tasks/active/
# Edit file: set claimed_by: agent-$agent, claimed_at: <timestamp>
\`\`\`

Complete a task:
\`\`\`bash
mv $SHARED_CONTEXT/tasks/active/task-XXX.yaml \\
   $SHARED_CONTEXT/tasks/done/
# Edit file: set completed_at, result summary
\`\`\`

Log completion:
\`\`\`bash
echo "\$(date -Iseconds) | agent-$agent | DONE | task-XXX | <summary>" \\
  >> $SHARED_CONTEXT/events.log
\`\`\`

## Task File Format

\`\`\`yaml
id: task-XXX
created: <ISO timestamp>
created_by: agent-$agent
priority: low | medium | high | urgent
complexity: simple | moderate | complex
recommended_model: haiku | sonnet | opus
title: <short title>
description: |
  <detailed description>
depends_on: []
claimed_by: null
claimed_at: null
completed_at: null
result: null
\`\`\`

## Peer Communication

Check swarm activity:
\`\`\`bash
tail -30 $SHARED_CONTEXT/events.log
\`\`\`

Signal another agent via tmux:
\`\`\`bash
# IMPORTANT: Must be TWO separate commands - first types text, second submits
tmux send-keys -t $SESSION:agents.N "Message here" Enter
tmux send-keys -t $SESSION:agents.N Enter
\`\`\`

Alternative (if the agent appears stuck in idle/Enchanting state):
\`\`\`bash
# Send Escape first to break idle state, then message with separate Enter
tmux send-keys -t $SESSION:agents.N Escape
tmux send-keys -t $SESSION:agents.N "Message here" Enter
tmux send-keys -t $SESSION:agents.N Enter
\`\`\`

Close the swarm:
If the customer types shut down, gracefully wind down:
1. Finish current task
2. Log shutdown event
3. Exit process
\`\`\`bash
launch-agents stop
\`\`\`

Pane mapping: agent-1=1, agent-2=2, agent-3=3, agent-4=4, agent-5=5, agent-6=6 (it is 1-based)

## Git Workflow

You work on branch: agent-$agent

For each task:
1. Ensure branch is up to date: git pull --rebase origin main
2. Make changes, commit with clear messages
3. Create PR when complete: gh pr create
4. Log completion to events.log

## Principles

- No hierarchy — all agents are peers
- Match task complexity to your capability
- One active task at a time
- Signal completion clearly
- Help clear simple tasks if queue is empty

## Documentation

For detailed architecture, security considerations, and advanced usage:
\`\`\`bash
cat ~/.dotfiles/docs/agent-system.md
\`\`\`
EOF
}

create_tmux_layout() {
    local count=$1

    echo -e "${BLUE}Creating tmux layout for $count agents...${NC}"
    debug "tmux new-session -d -s $SESSION -n agents -c $WORKTREE_ROOT/agent-1"

    local model1=$(get_model 1 $count)
    tmux new-session -d -s "$SESSION" -n "agents" -c "$WORKTREE_ROOT/agent-1"

    case $count in
        2)
            # Create 1x2 layout: 1 | 2
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            ;;
        3)
            # Create 1x3 layout: 1 | 2 | 3
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -v -t "$SESSION:agents.2" -c "$WORKTREE_ROOT/agent-3"
            ;;
        4)
            # Create 2x2 layout: 1 | 3
            #                    2 | 4
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -v -t "$SESSION:agents.1" -c "$WORKTREE_ROOT/agent-3"
            tmux split-window -v -t "$SESSION:agents.3" -c "$WORKTREE_ROOT/agent-4"
            ;;
        6)
            # Create 2x3 grid: 1 | 3 | 5
            #                  2 | 4 | 6
            # First create 3 columns with explicit sizing (1-based pane index)
            tmux split-window -h -t "$SESSION:agents" -l 66% -c "$WORKTREE_ROOT/agent-3"
            tmux split-window -h -t "$SESSION:agents" -l 50% -c "$WORKTREE_ROOT/agent-5"
            # Split each column vertically for the bottom row
            tmux split-window -v -t "$SESSION:agents.1" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -v -t "$SESSION:agents.3" -c "$WORKTREE_ROOT/agent-4"
            tmux split-window -v -t "$SESSION:agents.5" -c "$WORKTREE_ROOT/agent-6"
            ;;
    esac

    for i in $(seq 1 $count); do
        local pane=$i
        local client=$(get_client $i $count)
        local model=$(get_model $i $count)
        
        debug "tmux send-keys -t $SESSION:agents.$pane 'export AGENT_ID=agent-$i' C-m"
        tmux send-keys -t "$SESSION:agents.$pane" "export AGENT_ID=agent-$i" C-m
        debug "tmux send-keys -t $SESSION:agents.$pane 'export AGENT_CLIENT=$client' C-m"
        tmux send-keys -t "$SESSION:agents.$pane" "export AGENT_CLIENT=$client" C-m
        debug "tmux send-keys -t $SESSION:agents.$pane 'export AGENT_MODEL=$model' C-m"
        tmux send-keys -t "$SESSION:agents.$pane" "export AGENT_MODEL=$model" C-m
        
        if [[ -f "$WORKTREE_ROOT/agent-$i/.venv/bin/activate" ]]; then
            debug "tmux send-keys -t $SESSION:agents.$pane 'source .venv/bin/activate' C-m"
            tmux send-keys -t "$SESSION:agents.$pane" "source .venv/bin/activate" C-m
        fi
        
        # Start the appropriate agent based on client
        case $client in
            claude)
                tmux send-keys -t "$SESSION:agents.$pane" "export CLAUDE_SKIP_PERMISSION_PROMPTS=true" C-m
                tmux send-keys -t "$SESSION:agents.$pane" "export CLAUDE_AUTO_APPROVE_FOLDERS=true" C-m
                tmux send-keys -t "$SESSION:agents.$pane" "clear" C-m
                # Inject AGENTS.md via --append-system-prompt (CLAUDE.md is auto-read for project info)
                debug "tmux send-keys -t $SESSION:agents.$pane 'claude --model $model --append-system-prompt \"\$(cat AGENTS.md)\" $SKIP_PERMISSIONS $ALLOWED_TOOLS' C-m"
                tmux send-keys -t "$SESSION:agents.$pane" "claude --model $model --append-system-prompt \"\$(cat AGENTS.md)\" $SKIP_PERMISSIONS $ALLOWED_TOOLS" C-m
                # debug "tmux send-keys -t $SESSION:agents.$pane 'claude --model $model --append-system-prompt \"\$(cat AGENTS.md)\" $SKIP_PERMISSIONS $ALLOWED_TOOLS' C-m"
                # tmux send-keys -t "$SESSION:agents.$pane" "claude --model $model --append-system-prompt \"\$(cat AGENTS.md)\" $SKIP_PERMISSIONS $ALLOWED_TOOLS" C-m
                ;;
            copilot)
                tmux send-keys -t "$SESSION:agents.$pane" "export COPILOT_MODEL=$model" C-m
                sleep 0.1
                debug "tmux send-keys -t $SESSION:agents.$pane 'copilot' C-m"
                tmux send-keys -t "$SESSION:agents.$pane" "copilot" C-m
                ;;
            gemini)
                tmux send-keys -t "$SESSION:agents.$pane" "export GEMINI_MODEL=$model" C-m
                sleep 0.1
                debug "tmux send-keys -t $SESSION:agents.$pane 'gemini' C-m"
                tmux send-keys -t "$SESSION:agents.$pane" "gemini" C-m
                ;;
        esac
    done

    for i in $(seq 1 $count); do
        tmux new-window -t "$SESSION" -n "shell-$i" -c "$WORKTREE_ROOT/agent-$i"
        sleep 0.2
        
        if [[ -f "$WORKTREE_ROOT/agent-$i/.venv/bin/activate" ]]; then
            tmux send-keys -t "$SESSION:shell-$i" "source .venv/bin/activate" C-m
        fi
    done

    tmux select-window -t "$SESSION:agents"
    tmux select-pane -t "$SESSION:agents.1"

    echo -e "${GREEN}✓ Tmux session created${NC}"
}

cmd_workspace() {
    # Sanitize session name: replace dots and special chars with underscores
    local dir_name=$(basename "$PWD")
    local ws_session="ws-${dir_name//[^a-zA-Z0-9_-]/_}"
    
    if tmux has-session -t "$ws_session" 2>/dev/null; then
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Workspace exists, restarting...${NC}"
            tmux kill-session -t "$ws_session"
        else
            echo -e "${YELLOW}Workspace '$ws_session' already running${NC}"
            echo ""
            echo "Options:"
            echo "  launch-agents -w               Attach to existing workspace"
            echo "  launch-agents --force -w       Kill and restart workspace"
            echo ""
            read -p "Attach to existing workspace? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                exit 0
            fi
            tmux attach -t "$ws_session"
            exit 0
        fi
    fi

    echo -e "${BLUE}Creating workspace: $ws_session${NC}"

    # Create session with first pane (claude)
    tmux new-session -d -s "$ws_session" -n "workspace" -c "$PWD"
    
    # Split vertically: left claude, right shell
    tmux split-window -h -t "$ws_session:workspace" -c "$PWD"
    
    # Set even split (50/50)
    tmux select-layout -t "$ws_session:workspace" even-horizontal
    
    # Activate venv if present in both panes
    if [[ -f ".venv/bin/activate" ]]; then
        tmux send-keys -t "$ws_session:workspace.1" "source .venv/bin/activate" C-m
        tmux send-keys -t "$ws_session:workspace.2" "source .venv/bin/activate" C-m
        sleep 0.3
    fi
    
    # Start claude in opus on the left pane
    tmux send-keys -t "$ws_session:workspace.1" "claude --model opus $SKIP_PERMISSIONS" C-m
    
    # Select left pane (claude)
    tmux select-pane -t "$ws_session:workspace.1"

    echo ""
    echo -e "${GREEN}${BOLD}Workspace Ready${NC}"
    echo ""
    echo "Directory:    $(basename "$PWD")"
    echo "Left pane:    claude (opus)"
    echo "Right pane:   shell"
    echo ""
    echo "Navigation:"
    echo "  Alt ←→          Switch pane"
    echo "  Ctrl-b z        Zoom pane"
    echo "  Ctrl-b d        Detach"
    echo ""

    tmux attach -t "$ws_session"
}

cmd_start() {
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Session exists, restarting...${NC}"
            tmux kill-session -t "$SESSION"
        else
            echo -e "${YELLOW}Session '$SESSION' already running${NC}"
            echo ""
            echo "Options:"
            echo "  launch-agents start          Attach to existing session"
            echo "  launch-agents --force start  Kill and restart session"
            echo "  launch-agents restart        Alias for --force start"
            echo "  launch-agents stop           Stop session"
            echo "  launch-agents info           Show status"
            echo ""
            read -p "Attach to existing session? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                exit 0
            fi
            tmux attach -t "$SESSION"
            exit 0
        fi
    fi

    echo -e "${BLUE}Setting up $AGENT_COUNT agents for: $REPO_NAME${NC}"
    echo ""

    setup_shared_state

    echo "Preparing worktrees..."
    for i in $(seq 1 $AGENT_COUNT); do
        local client=$(get_client $i $AGENT_COUNT)
        local model=$(get_model $i $AGENT_COUNT)
        create_agent $i $client $model
    done
    echo ""

    create_tmux_layout $AGENT_COUNT

    echo ""
    echo -e "${GREEN}${BOLD}Claude Swarm Ready${NC}"
    echo ""
    echo "Project:      $REPO_NAME"
    echo "Agents:       $AGENT_COUNT"
    echo ""
    echo "Navigation:"
    echo "  Ctrl-b 1        Agents window"
    echo "  Ctrl-b 2-$((AGENT_COUNT+1))      Shell windows"
    echo "  Alt ↑↓←→        Switch pane"
    echo "  Ctrl-b z        Zoom pane"
    echo "  Ctrl-b d        Detach"
    echo ""

    tmux attach -t "$SESSION"
}

cmd_stop() {
    debug "Stopping session $SESSION"

    if tmux has-session -t "$SESSION" 2>/dev/null; then
        # Count panes in agents window to determine agent count
        local pane_count=$(tmux list-panes -t "$SESSION:agents" 2>/dev/null | wc -l | tr -d ' ')
        
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Force killing agents...${NC}"
            
            # Send Ctrl-C to interrupt running processes
            for i in $(seq 1 $pane_count); do
                debug "Sending Ctrl-C to agent-$i"
                tmux send-keys -t "$SESSION:agents.$i" C-c
            done
            sleep 0.5
            
            # Send exit to terminate shells
            for i in $(seq 1 $pane_count); do
                debug "Sending exit to agent-$i"
                tmux send-keys -t "$SESSION:agents.$i" "exit" Enter
            done
            sleep 0.5
            
            echo -e "${YELLOW}Killing tmux session: $SESSION${NC}"
            tmux kill-session -t "$SESSION"
            echo -e "${GREEN}✓ Session killed${NC}"
        else
            echo -e "${YELLOW}Sending shutdown to agents...${NC}"
            
            # Send graceful shutdown message to each agent (two commands required)
            for i in $(seq 1 $pane_count); do
                debug "Sending shutdown to agent-$i"
                tmux send-keys -t "$SESSION:agents.$i" "Please shut down gracefully. Finish any current task, log a shutdown event, then exit." Enter
                tmux send-keys -t "$SESSION:agents.$i" Enter
            done
            
            echo -e "${YELLOW}Killing tmux session: $SESSION${NC}"
            tmux kill-session -t "$SESSION"
            echo -e "${GREEN}✓ Session stopped${NC}"
        fi
    else
        echo "No session running"
    fi
}

cmd_clean() {
    # Force mode: kill all related processes
    if [[ "$FORCE" == true ]]; then
        echo -e "${YELLOW}Force mode: killing all related processes...${NC}"
        
        # Kill tmux sessions
        if pgrep -x tmux > /dev/null; then
            echo -e "  ${YELLOW}Killing tmux...${NC}"
            pkill -x tmux 2>/dev/null || true
            sleep 0.5
        fi
        
        # Kill agent processes
        for proc in claude gemini copilot; do
            if pgrep -f "$proc" > /dev/null; then
                echo -e "  ${YELLOW}Killing $proc...${NC}"
                pkill -f "$proc" 2>/dev/null || true
            fi
        done
        sleep 0.5
    fi

    # Stop session first if running
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        echo -e "${YELLOW}Stopping session first...${NC}"
        tmux kill-session -t "$SESSION"
    fi

    echo "Checking worktrees for cleanup..."

    # Find all agent worktrees dynamically
    if [[ -d "$WORKTREE_ROOT" ]]; then
        for worktree_path in "$WORKTREE_ROOT"/agent-*; do
            [[ -d "$worktree_path" ]] || continue
            local agent=$(basename "$worktree_path")
            local branch="$agent"

            # Check for uncommitted changes
            pushd "$worktree_path" > /dev/null
            local has_changes=$(git status --porcelain)
            popd > /dev/null

            if [[ -n "$has_changes" ]] && [[ "$FORCE" != true ]]; then
                echo -e "  ${RED}✗${NC} $agent: uncommitted changes (use --force to override)"
                continue
            fi

            if [[ "$FORCE" == true ]]; then
                echo -e "  ${YELLOW}!${NC} $agent: force removing"
                git worktree remove "$worktree_path" --force 2>/dev/null || rm -rf "$worktree_path"
                git branch -D "$branch" 2>/dev/null || true
                continue
            fi

            # Check if branch is merged into main
            pushd "$REPO_ROOT" > /dev/null
            if git branch --merged main 2>/dev/null | grep -q "$branch"; then
                echo -e "  ${GREEN}✓${NC} $agent: branch merged, removing"
                git worktree remove "$worktree_path" --force
                git branch -d "$branch" 2>/dev/null || true
            else
                echo -e "  ${YELLOW}!${NC} $agent: branch not merged into main, skipping"
            fi
            popd > /dev/null
        done
    fi

    if [[ -d "$WORKTREE_ROOT" ]] && [[ -z "$(ls -A "$WORKTREE_ROOT")" ]]; then
        rmdir "$WORKTREE_ROOT"
        echo -e "${GREEN}✓ Worktree directory removed${NC}"
    fi

    git worktree prune

    # Clean shared state if all worktrees are removed
    if [[ ! -d "$WORKTREE_ROOT" ]] || [[ -z "$(ls -A "$WORKTREE_ROOT")" ]]; then
        if [[ -d "$SHARED_CONTEXT" ]]; then
            if [[ "$FORCE" == true ]]; then
                echo -e "  ${YELLOW}!${NC} Force removing shared state"
                rm -rf "$SHARED_CONTEXT"
                echo -e "${GREEN}✓ Shared state removed${NC}"
            else
                # Only remove if tasks are all done (no pending/active)
                local pending=$(ls -1 "$SHARED_CONTEXT/tasks/pending" 2>/dev/null | wc -l | tr -d ' ')
                local active=$(ls -1 "$SHARED_CONTEXT/tasks/active" 2>/dev/null | wc -l | tr -d ' ')
                if [[ "$pending" -eq 0 ]] && [[ "$active" -eq 0 ]]; then
                    rm -rf "$SHARED_CONTEXT"
                    echo -e "${GREEN}✓ Shared state removed${NC}"
                else
                    echo -e "  ${YELLOW}!${NC} Shared state has pending/active tasks, keeping (use --force to override)"
                fi
            fi
        fi
    fi

    echo -e "${GREEN}✓ Cleanup complete${NC}"
}

cmd_info() {
    echo -e "${BOLD}Claude Swarm Status${NC}"
    echo ""
    echo -e "${BOLD}Project:${NC} $REPO_NAME"
    echo ""

    # Session status
    echo -e "${BOLD}Session:${NC}"
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        echo -e "  Status: ${GREEN}running${NC}"
        echo -e "  Attach: tmux attach -t $SESSION"
    else
        echo -e "  Status: ${YELLOW}stopped${NC}"
    fi
    echo ""

    # Worktrees
    echo -e "${BOLD}Agents:${NC}"
    for i in 1 2 3 4; do
        local worktree_path="$WORKTREE_ROOT/agent-$i"
        if [[ -d "$worktree_path" ]]; then
            local model=$(get_model $i 4)  # Show potential model
            pushd "$worktree_path" > /dev/null
            local branch=$(git branch --show-current)
            local status=""
            if [[ -n $(git status --porcelain) ]]; then
                status=" ${YELLOW}(uncommitted changes)${NC}"
            fi
            popd > /dev/null
            echo -e "  agent-$i: ${GREEN}exists${NC} [$branch]$status"
        fi
    done
    if [[ ! -d "$WORKTREE_ROOT" ]]; then
        echo "  (no worktrees)"
    fi
    echo ""

    # Tasks
    echo -e "${BOLD}Tasks:${NC}"
    local pending=$(ls -1 "$SHARED_CONTEXT/tasks/pending" 2>/dev/null | wc -l | tr -d ' ')
    local active=$(ls -1 "$SHARED_CONTEXT/tasks/active" 2>/dev/null | wc -l | tr -d ' ')
    local done=$(ls -1 "$SHARED_CONTEXT/tasks/done" 2>/dev/null | wc -l | tr -d ' ')
    echo "  Pending: $pending"
    echo "  Active:  $active"
    echo "  Done:    $done"
    
    if [[ "$active" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}Active Tasks:${NC}"
        for f in "$SHARED_CONTEXT/tasks/active"/*.yaml; do
            [[ -f "$f" ]] || continue
            local id=$(basename "$f" .yaml)
            local title=$(grep "^title:" "$f" | cut -d: -f2- | xargs)
            local claimed=$(grep "^claimed_by:" "$f" | cut -d: -f2- | xargs)
            echo "  $id: $title (${claimed:-unclaimed})"
        done
    fi
    echo ""

    # Recent events
    if [[ -f "$SHARED_CONTEXT/events.log" ]]; then
        local event_count=$(grep -v "^#" "$SHARED_CONTEXT/events.log" | grep -v "^$" | wc -l | tr -d ' ')
        if [[ "$event_count" -gt 0 ]]; then
            echo -e "${BOLD}Recent Events:${NC}"
            grep -v "^#" "$SHARED_CONTEXT/events.log" | grep -v "^$" | tail -5 | while read line; do
                echo "  $line"
            done
        fi
    fi
    echo ""

    # Paths
    echo -e "${BOLD}Paths:${NC}"
    echo "  Worktrees:    $WORKTREE_ROOT/"
    echo "  Shared state: $SHARED_CONTEXT/"
}

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -n)
            if [[ "$2" =~ ^[2-6]$ ]]; then
                AGENT_COUNT=$2
                shift 2
            else
                echo -e "${RED}Error: -n requires 2, 3, 4, or 6${NC}"
                exit 1
            fi
            ;;
        --version)
            show_version
            exit 0
            ;;
        --equal)
            EQUAL_DISTRIBUTION=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --yolo)
            SKIP_PERMISSIONS="--dangerously-skip-permissions"
            shift
            ;;
        -w|--workspace)
            COMMAND="workspace"
            shift
            ;;
        -r)
            COMMAND="restart"
            shift
            ;;
        -a)
            COMMAND="attach"
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        start|stop|clean|info|restart|attach|workspace)
            COMMAND=$1
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo ""
            echo "Did you mean one of these?"
            echo "  launch-agents          Start or attach (smart default)"
            echo "  launch-agents start    Start agents"
            echo "  launch-agents stop     Stop agents"
            echo "  launch-agents -w       Simple workspace"
            echo "  launch-agents info     Show status"
            echo ""
            exit 1
            ;;
    esac
done

# Execute command
case ${COMMAND:-} in
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    clean)
        cmd_clean
        ;;
    info)
        cmd_info
        ;;
    workspace)
        cmd_workspace
        ;;
    restart)
        # Restart is just stop + start with force
        FORCE=true
        cmd_stop 2>/dev/null || true
        sleep 0.5
        cmd_start
        ;;
    attach)
        if tmux has-session -t "$SESSION" 2>/dev/null; then
            tmux attach -t "$SESSION"
        else
            echo -e "${RED}No session '$SESSION' running${NC}"
            echo "Run 'launch-agents start' to create one"
            exit 1
        fi
        ;;
    "")
        # Smart default: start or attach if already running
        if tmux has-session -t "$SESSION" 2>/dev/null; then
            echo -e "${GREEN}Session exists, attaching...${NC}"
            tmux attach -t "$SESSION"
        else
            cmd_start
        fi
        ;;
    *)
        echo -e "${RED}Unknown command: $COMMAND${NC}"
        show_help
        exit 1
        ;;
esac
