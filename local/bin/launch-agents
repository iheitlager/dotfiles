#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0


# launch-agents
# Version: 0.8.1
#
# Changelog:
# 0.8.1 Set Ghostty window title for workspace and swarm modes
# 0.8.0 New default: per-agent windows (claude|shell); classic layout via --classic/-o
# 0.7.0 Default to sonnet, --opus flag enables opus-based distribution
# 0.6.0 Added --daemon/-d flag for task-watcher integration
# 0.5.2 Improved resilience: smart defaults, restart command, better session handling
# 0.5.1 Force clean now kills tmux and agent processes (claude/gemini/copilot)
# 0.5.0 Added -w/--workspace mode for simple claude + shell layout
# 0.4.2 Clarified tmux inter-agent communication (two separate send-keys required)
# 0.4.1 Improved skill handling and instructions
# 0.4.0 Multi-client support with copilot and gemini
# 0.3.0 Improved agent manifest and instructions
# 0.2.0 Uniform multi agent structure
# 0.1.0 Three agent coordinator/worker structure
#
# Usage: ./launch-agents [OPTIONS] COMMAND
# Run from within your git repo

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

show_version() {
    local version=$(grep -m1 '^# Version:' "$0" | sed 's/.*Version: //')
    echo -e "${BOLD}launch-agents${NC} version ${GREEN}$version${NC}"
}

# Detect repo root and name
# If in a worktree, get the main repo (strip -worktree suffix)
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: Not in a git repository${NC}"
    exit 1
}

# Extract the base repo name (handle -worktree suffix and agent-N subdirs)
local_repo_name=$(basename "$REPO_ROOT")
local_repo_parent=$(dirname "$REPO_ROOT")
local_repo_grandparent=$(dirname "$local_repo_parent")

# Check if we're in an agent-N subdirectory of a -worktree directory
if [[ "$local_repo_parent" =~ ^(.+)-worktree$ ]]; then
    # We're in a worktree agent subdirectory (e.g., agent-1 inside code-analyzer-worktree)
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
    WORKTREE_ROOT="$local_repo_parent"
    REPO_PARENT="$local_repo_grandparent"
    REPO_ROOT="$REPO_PARENT/$REPO_NAME"
elif [[ "$local_repo_name" =~ ^(.+)-worktree$ ]]; then
    # We're in the worktree root directory
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
    WORKTREE_ROOT="$REPO_ROOT"
    REPO_PARENT=$(dirname "$REPO_ROOT")
    REPO_ROOT="$REPO_PARENT/$REPO_NAME"
else
    # We're in the main repo
    REPO_NAME="$local_repo_name"
    REPO_PARENT=$(dirname "$REPO_ROOT")
    WORKTREE_ROOT="$REPO_PARENT/${REPO_NAME}-worktree"
fi

# Paths derived from repo
# Sanitize session name: tmux doesn't allow dots
SESSION="claude-${REPO_NAME//[.]/_}"
SHARED_CONTEXT="$HOME/.local/state/agent-context/$REPO_NAME"

# Defaults
AGENT_COUNT=2
FORCE=false
VERBOSE=false
EQUAL_DISTRIBUTION=false
DAEMON_MODE=false
OPUS_MODE=false
CLASSIC_MODE=false
SKIP_PERMISSIONS="--permission-mode acceptEdits"
ALLOWED_TOOLS=''
# ALLOWED_TOOLS='--allowedTools "git *" --allowedTools "gh *" --allowedTools Read --allowedTools Write --allowedTools Edit --allowedTools Bash'

debug() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BOLD}${BLUE}[DEBUG]${NC} $*" >&2
    fi
}

print_usage() {
    local help_cmd="cat"
    command -v bat &>/dev/null && help_cmd="bat --plain --language=help"
    
    $help_cmd << 'EOF'
Usage: launch-agents [OPTIONS] [COMMAND]

Launch and manage a Claude Code agent swarm.

Commands:
    (none)          Smart default: start or attach if already running
    start           Launch agents in tmux (prompt if already running)
    stop            Kill tmux session
    restart         Stop and restart the session
    attach          Attach to existing session
    workspace       Simple workspace: claude left, shell right
    clean           Remove worktrees (if branches merged and clean)
    info            Show status of agents, models, and tasks

Options:
    -n COUNT           Number of agents: 2, 3, 4, or 6 (default: 2)
    -d, --daemon       Run task-watcher daemon (monitors queue, notifies agents)
    -o, --classic      Use classic multi-pane layout (all agents in one window)
    --opus             Use opus-based model distribution (default: all sonnet)
    --equal            For n=6, use equal distribution (Option 5) instead of default
    -v, --verbose      Print commands being executed
    --force            Force restart or clean (skips prompts)
    --yolo             Skip permission prompts (Claude agents only)
    -h, --help         Show this help message

Layouts (default):
    2 agents        agent-1 [claude│shell]  agent-2 [claude│shell]  daemon
    3 agents        agent-1 [claude│shell]  agent-2 [claude│shell]  agent-3 [claude│shell]  daemon
    4 agents        agent-1..4 [claude│shell each]  daemon

Layouts (--classic / -o):
    2 agents        agents: agent-1 │ agent-2   +  shell-1  shell-2
    3 agents        agents: agent-1 │ agent-2 / agent-3   +  shell-1..3
    4 agents        agents: agent-1 / agent-3 │ agent-2 / agent-4   +  shell-1..4
    6 agents        agents: agent-1/2 │ agent-3/4 │ agent-5/6   +  shell-1..6

Clients & Models:
    claude          sonnet (default), opus with --opus flag
    copilot         5.1-codex (agents 5-6 with n=6)
    gemini          gemini-pro (agent 6 with n=6)

Examples:
    launch-agents                   Smart default: start or attach
    launch-agents -n 4 start        Start 4 agents
    launch-agents -d start          Start with task-watcher daemon
    launch-agents workspace         Simple workspace (claude + shell)
    launch-agents info              Show swarm status
    launch-agents stop              Stop all agents
    launch-agents clean             Remove merged worktrees
    launch-agents --force clean     Remove all worktrees

Paths:
    Worktrees       $WORKTREE_ROOT/agent-N/
    Shared state    $SHARED_CONTEXT/

Documentation:
    See ~/.dotfiles/docs/agent-system.md for detailed architecture and usage.
EOF
}

get_client() {
    local agent=$1
    local count=$2

    case $count in
        2|3|4)
            echo "claude"
            ;;
        6)
            if [[ "$EQUAL_DISTRIBUTION" == true ]]; then
                # Option 5: Equal pairs
                case $agent in
                    1|2) echo "claude" ;;
                    3|4) echo "copilot" ;;
                    5|6) echo "gemini" ;;
                esac
            else
                # Option 1: Default (4 claude, 1 copilot, 1 gemini)
                case $agent in
                    1|2|3|4) echo "claude" ;;
                    5) echo "copilot" ;;
                    6) echo "gemini" ;;
                esac
            fi
            ;;
    esac
}

get_model() {
    local agent=$1
    local count=$2

    # Non-claude models (copilot/gemini) for 6-agent configs
    if [[ "$count" -eq 6 ]]; then
        if [[ "$EQUAL_DISTRIBUTION" == true ]]; then
            case $agent in
                3|4) echo "5.1-codex"; return ;;
                5|6) echo "gemini-pro"; return ;;
            esac
        else
            case $agent in
                5) echo "5.1-codex"; return ;;
                6) echo "gemini-pro"; return ;;
            esac
        fi
    fi

    # Claude models: default to sonnet, --opus enables opus-based distribution
    if [[ "$OPUS_MODE" == true ]]; then
        case $count in
            2)
                echo "opus"
                ;;
            3)
                case $agent in
                    1|2) echo "sonnet" ;;
                    *) echo "opus" ;;
                esac
                ;;
            4)
                case $agent in
                    1|2) echo "sonnet" ;;
                    3)   echo "opus" ;;
                    4)   echo "haiku" ;;
                esac
                ;;
            6)
                if [[ "$EQUAL_DISTRIBUTION" == true ]]; then
                    case $agent in
                        1) echo "opus" ;;
                        2) echo "sonnet" ;;
                    esac
                else
                    case $agent in
                        1|2) echo "opus" ;;
                        3|4) echo "sonnet" ;;
                    esac
                fi
                ;;
        esac
    else
        # Default: all claude agents use sonnet
        echo "sonnet"
    fi
}

create_agent() {
    local agent=$1
    local client=$2
    local model=$3
    local worktree_path="$WORKTREE_ROOT/agent-$agent"

    if [[ -d "$worktree_path" ]]; then
        echo -e "  ${GREEN}✓${NC} agent-$agent ($client/$model) worktree exists"
    else
        mkdir -p "$WORKTREE_ROOT"

        local branch="agent-$agent"
        if ! git show-ref --verify --quiet "refs/heads/$branch"; then
            echo -e "  ${BLUE}→${NC} Creating branch: $branch"
            debug "git branch $branch"
            git branch "$branch"
        fi

        echo -e "  ${BLUE}→${NC} Creating worktree: agent-$agent"
        debug "git worktree add $worktree_path $branch"
        git worktree add "$worktree_path" "$branch"

        pushd "$worktree_path" > /dev/null
        
        # Link shared config if it exists in main repo
        if [[ "$client" == "claude" ]] && [[ -f "$REPO_ROOT/CLAUDE.md" ]] && [[ ! -f "$worktree_path/CLAUDE.md" ]]; then
            echo -e "  ${BLUE}→${NC} Linking CLAUDE.md"
            ln -s "$REPO_ROOT/CLAUDE.md" CLAUDE.md || true
        fi
        
        if command -v uv &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Setting up uv venv"
            uv venv
        fi
        
        popd > /dev/null

        echo -e "  ${GREEN}✓${NC} agent-$agent ready"
    fi

    # Generate agent instructions (always regenerated)
    create_agent_instructions $agent $client $model
}

old_get_model() {
    local agent=$1
    local count=$2

    case $count in
        2)
            echo "opus"
            ;;
        3)
            case $agent in
                1) echo "opus" ;;
                *) echo "sonnet" ;;
            esac
            ;;
        4)
            case $agent in
                1|2) echo "opus" ;;
                3)   echo "sonnet" ;;
                4)   echo "haiku" ;;
            esac
            ;;
    esac
}

setup_worktree() {
    local agent=$1
    local worktree_path="$WORKTREE_ROOT/agent-$agent"
    local branch="agent-$agent"

    if [[ -d "$worktree_path" ]]; then
        echo -e "  ${GREEN}✓${NC} agent-$agent worktree exists"
    else
        mkdir -p "$WORKTREE_ROOT"

        if ! git show-ref --verify --quiet "refs/heads/$branch"; then
            echo -e "  ${BLUE}→${NC} Creating branch: $branch"
            debug "git branch $branch"
            git branch "$branch"
        fi

        echo -e "  ${BLUE}→${NC} Creating worktree: agent-$agent"
        debug "git worktree add $worktree_path $branch"
        git worktree add "$worktree_path" "$branch"

        pushd "$worktree_path" > /dev/null
        
        # Link shared .claude config if it exists in main repo
        if [[ -f "$REPO_ROOT/CLAUDE.md" ]] && [[ ! -f "$worktree_path/CLAUDE.md" ]]; then
            echo -e "  ${BLUE}→${NC} Linking CLAUDE.md"
            ln -s "$REPO_ROOT/CLAUDE.md" CLAUDE.md || true
        fi
        
        if command -v uv &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Setting up uv venv"
            uv venv
        fi
        
        if command -v link_claude &> /dev/null; then
            echo -e "  ${BLUE}→${NC} Linking claude skills"
            link_claude
        fi
        
        popd > /dev/null

        echo -e "  ${GREEN}✓${NC} agent-$agent ready"
    fi
}

ensure_gitignore_agents() {
    # Ensure AGENTS.md is in .gitignore (called once during setup)
    pushd "$REPO_ROOT" > /dev/null
    if [[ ! -f .gitignore ]]; then
        echo "AGENTS.md" > .gitignore
        git add .gitignore
        git commit -m "chore: add .gitignore with AGENTS.md"
    elif ! grep -q "^AGENTS.md$" .gitignore; then
        echo "AGENTS.md" >> .gitignore
        git add .gitignore
        git commit -m "chore: ignore AGENTS.md" || true
    fi
    popd > /dev/null
}

setup_shared_state() {
    mkdir -p "$SHARED_CONTEXT/jobs/pending"
    mkdir -p "$SHARED_CONTEXT/jobs/active"
    mkdir -p "$SHARED_CONTEXT/jobs/done"
    mkdir -p "$SHARED_CONTEXT/agents"

    if [[ ! -f "$SHARED_CONTEXT/events.log" ]]; then
        echo "# Agent Events Log - $REPO_NAME" > "$SHARED_CONTEXT/events.log"
        echo "# Format: timestamp | agent_id | event_type | metadata_json" >> "$SHARED_CONTEXT/events.log"
        echo "# Example: 2026-02-02T17:30:00Z | agent-1 | REQUEST | {\"tool\": \"Read\", \"pid\": 12345}" >> "$SHARED_CONTEXT/events.log"
        echo "" >> "$SHARED_CONTEXT/events.log"
    fi

    # Ensure AGENTS.md is gitignored
    ensure_gitignore_agents

    echo -e "${GREEN}✓${NC} Shared state ready"
}

create_agent_instructions() {
    local agent=$1
    local client=$2
    local model=$3
    local worktree_path="$WORKTREE_ROOT/agent-$agent"

    # Always write to AGENTS.md - injected via --append-system-prompt for Claude
    # CLAUDE.md in repo root remains for project-specific instructions
    cat > "$worktree_path/AGENTS.md" << EOF
# Agent Instructions

You are agent-$agent running $model (via $client) in a peer swarm for project: $REPO_NAME

## Identity

- Agent ID: agent-$agent
- Client: $client
- Model: $model
- Worktree: $worktree_path
- Shared state: $SHARED_CONTEXT

## Receiving Orders

Users may talk to you directly. When receiving a request:

1. Assess complexity:
   - Simple: docs, formatting, simple tests
   - Moderate: standard features, refactors
   - Complex: architecture, tricky bugs, design

2. Decide:
   - Small task + you match capability → do it directly
   - Large task → break into subtasks, create job files
   - Wrong capability tier → create a job for a better-suited agent

## Job Queue

Use \`swarm-job\` for all job operations:

\`\`\`bash
# List all jobs (pending/active/done)
swarm-job list

# List only pending jobs with scores
swarm-job list pending

# Claim best matching job for your model tier
swarm-job claim

# Claim specific job
swarm-job claim job-1737372800-12345

# Complete a job
swarm-job complete job-1737372800-12345
swarm-job complete job-1737372800-12345 -r "merged to main"

# Create a new job for others
swarm-job new "Job title" -p high -c complex
\`\`\`

## Polling

Check for new jobs periodically. When idle:
\`\`\`bash
# Check every 30-60 seconds when not busy
swarm-job list pending
\`\`\`

The swarm-daemon will also send notifications via tmux when:
- New jobs are available for your tier
- Jobs you depend on are completed (unblocked)

## Capability Matching

Your model tier: $model
- opus (tier 3): complex tasks, architecture, debugging
- sonnet (tier 2): moderate tasks, standard features
- haiku (tier 1): simple tasks, docs, formatting

Claim jobs at or below your tier. Higher-tier agents can help clear simpler jobs.

## Job File Format

\`\`\`yaml
id: job-1737372800-12345
created: <ISO timestamp>
created_by: agent-$agent
priority: low | medium | high | urgent
complexity: simple | moderate | complex
recommended_model: haiku | sonnet | opus
title: <short title>
description: |
  <detailed description>
depends_on: []
claimed_by: null
claimed_at: null
completed_at: null
result: null
\`\`\`

Job files live in \`$SHARED_CONTEXT/jobs/pending/\`, \`jobs/active/\`, and \`jobs/done/\`.

## Peer Communication

Check swarm activity:
\`\`\`bash
swarm-daemon log              # View recent events (preferred)
swarm-daemon log -f           # Follow events in real-time
tail -30 $SHARED_CONTEXT/events.log  # Direct file access (alternative)
\`\`\`

Signal another agent via tmux:
\`\`\`bash
# IMPORTANT: Must be TWO separate commands - first types text, second submits
# Each agent is in its own window: $SESSION:agent-N.1 (left/claude pane)
tmux send-keys -t $SESSION:agent-N.1 "Message here" Enter
tmux send-keys -t $SESSION:agent-N.1 Enter
\`\`\`

Alternative (if the agent appears stuck in idle/Enchanting state):
\`\`\`bash
# Send Escape first to break idle state, then message with separate Enter
tmux send-keys -t $SESSION:agent-N.1 Escape
tmux send-keys -t $SESSION:agent-N.1 "Message here" Enter
tmux send-keys -t $SESSION:agent-N.1 Enter
\`\`\`

Close the swarm:
If the customer types shut down, gracefully wind down:
1. Finish current job
2. Exit process (shutdown logged automatically)
\`\`\`bash
launch-agents stop
\`\`\`

Pane mapping: each agent has its own window $SESSION:agent-N, claude is pane 1 (left), shell is pane 2 (right)

## Git Workflow

You work on branch: agent-$agent

For each job:
1. Ensure branch is up to date: \`git fetch && git rebase origin/main\`
2. Create a feature branch: \`git checkout -b feat/my-feature\`
3. Make changes and commit with clear messages
4. Create PR: use \`/pr\` skill, then signal the swarm:
   \`\`\`bash
   swarm-daemon hook JOB_PR_READY <job-id> <pr-number>
   \`\`\`
5. After merge: use \`/merge\` skill, then signal the swarm:
   \`\`\`bash
   swarm-daemon hook JOB_PR_MERGED <job-id>
   \`\`\`
6. Mark job complete: \`swarm-job complete <job-id>\`

Note: Tool use events (Read, Edit, Write, Bash, etc.) are emitted automatically
by the Claude Code hooks in \`~/.dotfiles/claude/config/settings.json\` — no
manual calls needed for those.

IMPORTANT: Never create PRs or push \`agent-N\` branches. Always work on a
feature branch (\`feat/\`, \`fix/\`, \`refactor/\`, etc.) branched from \`agent-$agent\`.

## Principles

- No hierarchy — all agents are peers
- Match job complexity to your capability
- One active job at a time
- Signal completion clearly
- Help clear simple jobs if queue is empty

## Documentation

For detailed architecture, security considerations, and advanced usage:
\`\`\`bash
cat ~/.dotfiles/docs/agent-system.md
\`\`\`
EOF
}

_start_agent_pane() {
    # Helper: configure and start an agent in the given tmux target pane
    local target=$1  # e.g. "$SESSION:agent-1.1"
    local agent=$2
    local client=$3
    local model=$4

    tmux send-keys -t "$target" "export AGENT_ID=agent-$agent" C-m
    tmux send-keys -t "$target" "export AGENT_CLIENT=$client" C-m
    tmux send-keys -t "$target" "export AGENT_MODEL=$model" C-m

    if [[ -f "$WORKTREE_ROOT/agent-$agent/.venv/bin/activate" ]]; then
        tmux send-keys -t "$target" "source .venv/bin/activate" C-m
    fi

    case $client in
        claude)
            tmux send-keys -t "$target" "export CLAUDE_SKIP_PERMISSION_PROMPTS=true" C-m
            tmux send-keys -t "$target" "export CLAUDE_AUTO_APPROVE_FOLDERS=true" C-m
            tmux send-keys -t "$target" "clear" C-m
            debug "tmux send-keys -t $target 'claude --model $model ...' C-m"
            tmux send-keys -t "$target" "claude --model $model --add-dir . --append-system-prompt \"\$(cat AGENTS.md)\" $SKIP_PERMISSIONS $ALLOWED_TOOLS" C-m
            ;;
        copilot)
            tmux send-keys -t "$target" "export COPILOT_MODEL=$model" C-m
            sleep 0.1
            debug "tmux send-keys -t $target 'copilot' C-m"
            tmux send-keys -t "$target" "copilot" C-m
            ;;
        gemini)
            tmux send-keys -t "$target" "export GEMINI_MODEL=$model" C-m
            sleep 0.1
            debug "tmux send-keys -t $target 'gemini' C-m"
            tmux send-keys -t "$target" "gemini" C-m
            ;;
    esac
}

create_tmux_layout_new() {
    # New default layout: one window per agent, each split left (claude) | right (shell)
    # Plus a daemon window at the end.
    local count=$1

    echo -e "${BLUE}Creating per-agent tmux layout for $count agents...${NC}"

    # Create session with first agent's window
    tmux new-session -d -s "$SESSION" -n "agent-1" -c "$WORKTREE_ROOT/agent-1"

    for i in $(seq 1 $count); do
        local client=$(get_client $i $count)
        local model=$(get_model $i $count)
        local win="agent-$i"

        if [[ $i -gt 1 ]]; then
            tmux new-window -t "$SESSION" -n "$win" -c "$WORKTREE_ROOT/agent-$i"
            sleep 0.2
        fi

        # Split: left = claude (pane 1), right = shell (pane 2)
        tmux split-window -h -t "$SESSION:$win" -c "$WORKTREE_ROOT/agent-$i"
        tmux select-layout -t "$SESSION:$win" even-horizontal

        # Left pane: start agent
        _start_agent_pane "$SESSION:$win.1" $i $client $model

        # Right pane: activate venv if present
        if [[ -f "$WORKTREE_ROOT/agent-$i/.venv/bin/activate" ]]; then
            tmux send-keys -t "$SESSION:$win.2" "source .venv/bin/activate" C-m
        fi
    done

    # Always add daemon window (starts swarm-daemon only if -d flag)
    tmux new-window -t "$SESSION" -n "daemon" -c "$REPO_ROOT"
    sleep 0.2
    if [[ "$DAEMON_MODE" == true ]]; then
        tmux send-keys -t "$SESSION:daemon" "swarm-daemon daemon" C-m
        echo -e "${GREEN}✓ Swarm daemon started${NC}"
    fi

    tmux select-window -t "$SESSION:agent-1"
    tmux select-pane -t "$SESSION:agent-1.1"

    echo -e "${GREEN}✓ Tmux session created${NC}"
}

create_tmux_layout_classic() {
    # Classic layout: all agents in a single 'agents' window, separate shell-N windows
    local count=$1

    echo -e "${BLUE}Creating classic tmux layout for $count agents...${NC}"
    debug "tmux new-session -d -s $SESSION -n agents -c $WORKTREE_ROOT/agent-1"

    tmux new-session -d -s "$SESSION" -n "agents" -c "$WORKTREE_ROOT/agent-1"

    case $count in
        2)
            # Create 1x2 layout: 1 | 2
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            ;;
        3)
            # Create 1x3 layout: 1 | 2 | 3
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -h -t "$SESSION:agents.2" -c "$WORKTREE_ROOT/agent-3"
            ;;
        4)
            # Create 2x2 layout: 1 | 3
            #                    2 | 4
            tmux split-window -h -t "$SESSION:agents" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -v -t "$SESSION:agents.1" -c "$WORKTREE_ROOT/agent-3"
            tmux split-window -v -t "$SESSION:agents.3" -c "$WORKTREE_ROOT/agent-4"
            ;;
        6)
            # Create 2x3 grid: 1 | 3 | 5
            #                  2 | 4 | 6
            tmux split-window -h -t "$SESSION:agents" -l 66% -c "$WORKTREE_ROOT/agent-3"
            tmux split-window -h -t "$SESSION:agents" -l 50% -c "$WORKTREE_ROOT/agent-5"
            tmux split-window -v -t "$SESSION:agents.1" -c "$WORKTREE_ROOT/agent-2"
            tmux split-window -v -t "$SESSION:agents.3" -c "$WORKTREE_ROOT/agent-4"
            tmux split-window -v -t "$SESSION:agents.5" -c "$WORKTREE_ROOT/agent-6"
            ;;
    esac

    for i in $(seq 1 $count); do
        local pane=$i
        local client=$(get_client $i $count)
        local model=$(get_model $i $count)

        _start_agent_pane "$SESSION:agents.$pane" $i $client $model
    done

    for i in $(seq 1 $count); do
        tmux new-window -t "$SESSION" -n "shell-$i" -c "$WORKTREE_ROOT/agent-$i"
        sleep 0.2

        if [[ -f "$WORKTREE_ROOT/agent-$i/.venv/bin/activate" ]]; then
            tmux send-keys -t "$SESSION:shell-$i" "source .venv/bin/activate" C-m
        fi
    done

    # Add daemon window if daemon mode enabled
    if [[ "$DAEMON_MODE" == true ]]; then
        tmux new-window -t "$SESSION" -n "daemon" -c "$REPO_ROOT"
        sleep 0.2
        tmux send-keys -t "$SESSION:daemon" "swarm-daemon daemon" C-m
        echo -e "${GREEN}✓ Swarm daemon started${NC}"
    fi

    tmux select-window -t "$SESSION:agents"
    tmux select-pane -t "$SESSION:agents.1"

    echo -e "${GREEN}✓ Tmux session created${NC}"
}

create_tmux_layout() {
    if [[ "$CLASSIC_MODE" == true ]]; then
        create_tmux_layout_classic "$@"
    else
        create_tmux_layout_new "$@"
    fi
}

cmd_workspace() {
    # Sanitize session name: replace dots and special chars with underscores
    local dir_name=$(basename "$PWD")
    local ws_session="ws-${dir_name//[^a-zA-Z0-9_-]/_}"
    local agent_spec="$HOME/.dotfiles/local/share/launch-agents/WORKSPACE_AGENT.md"

    if tmux has-session -t "$ws_session" 2>/dev/null; then
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Workspace exists, restarting...${NC}"
            tmux kill-session -t "$ws_session"
        else
            echo -e "${YELLOW}Workspace '$ws_session' already running${NC}"
            echo ""
            echo "Options:"
            echo "  launch-agents workspace            Attach to existing workspace"
            echo "  launch-agents --force workspace    Kill and restart workspace"
            echo ""
            read -p "Attach to existing workspace? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                exit 0
            fi
            tmux attach -t "$ws_session"
            exit 0
        fi
    fi

    echo -e "${BLUE}Creating workspace: $ws_session${NC}"

    # Create session with first pane (claude)
    tmux new-session -d -s "$ws_session" -n "workspace" -c "$PWD"

    # Split vertically: left claude, right shell
    tmux split-window -h -t "$ws_session:workspace" -c "$PWD"

    # Set even split (50/50)
    tmux select-layout -t "$ws_session:workspace" even-horizontal

    # Activate venv if present in both panes
    if [[ -f ".venv/bin/activate" ]]; then
        tmux send-keys -t "$ws_session:workspace.1" "source .venv/bin/activate" C-m
        tmux send-keys -t "$ws_session:workspace.2" "source .venv/bin/activate" C-m
        sleep 0.3
    fi

    # Set environment for claude
    tmux send-keys -t "$ws_session:workspace.1" "export CLAUDE_SKIP_PERMISSION_PROMPTS=true" C-m
    tmux send-keys -t "$ws_session:workspace.1" "export CLAUDE_AUTO_APPROVE_FOLDERS=true" C-m
    tmux send-keys -t "$ws_session:workspace.1" "export WORKSPACE_SESSION='$ws_session'" C-m
    tmux send-keys -t "$ws_session:workspace.1" "clear" C-m

    # Build agent prompt with session info
    local agent_prompt=""
    if [[ -f "$agent_spec" ]]; then
        # Replace $WORKSPACE_SESSION placeholder with actual session name
        agent_prompt=$(sed "s|\$WORKSPACE_SESSION|$ws_session|g" "$agent_spec")
    fi

    # Start claude on the left pane with workspace agent instructions
    local ws_model="sonnet"
    [[ "$OPUS_MODE" == true ]] && ws_model="opus"

    if [[ -n "$agent_prompt" ]]; then
        tmux send-keys -t "$ws_session:workspace.1" "claude --model $ws_model --add-dir . --append-system-prompt \"\$(sed 's|\\\$WORKSPACE_SESSION|$ws_session|g' '$agent_spec')\" $SKIP_PERMISSIONS" C-m
    else
        tmux send-keys -t "$ws_session:workspace.1" "claude --model $ws_model --add-dir . $SKIP_PERMISSIONS" C-m
    fi

    # Create second window: monitors (ctop | htop)
    tmux new-window -t "$ws_session" -n "monitors" -c "$PWD"
    tmux split-window -h -t "$ws_session:monitors" -c "$PWD"
    tmux select-layout -t "$ws_session:monitors" even-horizontal

    # Start ctop (left) and htop (right) in monitors window
    tmux send-keys -t "$ws_session:monitors.1" "TERM=xterm-256color DOCKER_HOST="unix://$(podman machine inspect --format "{{.ConnectionInfo.PodmanSocket.Path}}" 2>/dev/null)" command ctop" C-m
    tmux send-keys -t "$ws_session:monitors.2" "htop" C-m

    # Select workspace window, left pane (claude)
    tmux select-window -t "$ws_session:workspace"
    tmux select-pane -t "$ws_session:workspace.1"

    echo ""
    echo -e "${GREEN}${BOLD}Workspace Ready${NC}"
    echo ""
    echo "Directory:    $(basename "$PWD")"
    echo ""
    echo "Window 1 (workspace):"
    echo "  Left pane:  claude ($ws_model)"
    echo "  Right pane: shell"
    echo ""
    echo "Window 2 (monitors):"
    echo "  Left pane:  ctop"
    echo "  Right pane: htop"
    echo ""
    echo "Navigation:"
    echo "  Ctrl-b 1/2      Switch window"
    echo "  Alt ←→          Switch pane"
    echo "  Ctrl-b z        Zoom pane"
    echo "  Ctrl-b d        Detach"
    echo ""

    # Set Ghostty window title
    printf '\e]0;workspace · %s\a' "$(basename "$PWD")"

    tmux attach -t "$ws_session"
}

cmd_start() {
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Session exists, restarting...${NC}"
            tmux kill-session -t "$SESSION"
        else
            echo -e "${YELLOW}Session '$SESSION' already running${NC}"
            echo ""
            echo "Options:"
            echo "  launch-agents start          Attach to existing session"
            echo "  launch-agents --force start  Kill and restart session"
            echo "  launch-agents restart        Alias for --force start"
            echo "  launch-agents stop           Stop session"
            echo "  launch-agents info           Show status"
            echo ""
            read -p "Attach to existing session? [Y/n] " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                exit 0
            fi
            tmux attach -t "$SESSION"
            exit 0
        fi
    fi

    echo -e "${BLUE}Setting up $AGENT_COUNT agents for: $REPO_NAME${NC}"
    echo ""

    setup_shared_state

    echo "Preparing worktrees..."
    for i in $(seq 1 $AGENT_COUNT); do
        local client=$(get_client $i $AGENT_COUNT)
        local model=$(get_model $i $AGENT_COUNT)
        create_agent $i $client $model
    done
    echo ""

    create_tmux_layout $AGENT_COUNT

    echo ""
    echo -e "${GREEN}${BOLD}Claude Swarm Ready${NC}"
    echo ""
    echo "Project:      $REPO_NAME"
    echo "Agents:       $AGENT_COUNT"
    echo ""
    if [[ "$CLASSIC_MODE" == true ]]; then
        echo "Navigation (classic):"
        echo "  Ctrl-b 1        Agents window"
        echo "  Ctrl-b 2-$((AGENT_COUNT+1))      Shell windows"
    else
        echo "Navigation:"
        echo "  Ctrl-b 1-$AGENT_COUNT      Agent windows (claude│shell)"
        echo "  Ctrl-b $((AGENT_COUNT+1))         Daemon window"
        echo "  Alt ←→          Switch pane within window"
    fi
    echo "  Alt ↑↓←→        Switch pane"
    echo "  Ctrl-b z        Zoom pane"
    echo "  Ctrl-b d        Detach"
    echo ""

    # Set Ghostty window title
    printf '\e]0;swarm · %s (%s agents)\a' "$REPO_NAME" "$AGENT_COUNT"

    tmux attach -t "$SESSION"
}

cmd_stop() {
    # Check for workspace session first (ws-*), then swarm session (claude-*)
    local dir_name=$(basename "$PWD")
    local ws_session="ws-${dir_name//[^a-zA-Z0-9_-]/_}"
    local target_session=""
    local session_type=""

    if tmux has-session -t "$ws_session" 2>/dev/null; then
        target_session="$ws_session"
        session_type="workspace"
    elif tmux has-session -t "$SESSION" 2>/dev/null; then
        target_session="$SESSION"
        session_type="swarm"
    fi

    if [[ -z "$target_session" ]]; then
        echo "No session running (checked: $ws_session, $SESSION)"
        return
    fi

    debug "Stopping $session_type session: $target_session"

    if [[ "$session_type" == "workspace" ]]; then
        # Workspace mode: simpler shutdown
        if [[ "$FORCE" == true ]]; then
            echo -e "${YELLOW}Force killing workspace...${NC}"
            # Send Ctrl-C to both panes
            tmux send-keys -t "$target_session:workspace.1" C-c
            tmux send-keys -t "$target_session:workspace.2" C-c
            sleep 0.3
        else
            echo -e "${YELLOW}Stopping workspace...${NC}"
            # Send graceful exit to claude
            tmux send-keys -t "$target_session:workspace.1" "/exit" Enter 2>/dev/null || true
            sleep 0.3
        fi
        tmux kill-session -t "$target_session"
        echo -e "${GREEN}✓ Workspace stopped${NC}"
    else
        # Swarm mode: detect layout (classic vs per-agent windows)
        local layout_type=""
        if tmux list-windows -t "$target_session" 2>/dev/null | grep -q "^[0-9]*: agents"; then
            layout_type="classic"
        else
            layout_type="per-agent"
        fi

        debug "Detected layout type: $layout_type"

        if [[ "$layout_type" == "classic" ]]; then
            # Classic layout: all agents in one 'agents' window
            local pane_count=$(tmux list-panes -t "$target_session:agents" 2>/dev/null | wc -l | tr -d ' ')

            if [[ "$FORCE" == true ]]; then
                echo -e "${YELLOW}Force killing agents (classic layout)...${NC}"

                # Send Ctrl-C to interrupt running processes
                for i in $(seq 1 $pane_count); do
                    debug "Sending Ctrl-C to agent-$i"
                    tmux send-keys -t "$target_session:agents.$i" C-c
                done
                sleep 0.5

                # Send exit to terminate shells
                for i in $(seq 1 $pane_count); do
                    debug "Sending exit to agent-$i"
                    tmux send-keys -t "$target_session:agents.$i" "exit" Enter
                done
                sleep 0.5
            else
                echo -e "${YELLOW}Sending shutdown to agents (classic layout)...${NC}"

                # Send graceful shutdown message to each agent
                for i in $(seq 1 $pane_count); do
                    debug "Sending shutdown to agent-$i"
                    tmux send-keys -t "$target_session:agents.$i" "Please shut down gracefully. Finish any current task, log a shutdown event, then exit." Enter
                    tmux send-keys -t "$target_session:agents.$i" Enter
                done
                sleep 1
            fi
        else
            # Per-agent window layout: separate agent-N windows
            local agent_windows=$(tmux list-windows -t "$target_session" 2>/dev/null | grep -E "^[0-9]*: agent-[0-9]+" | cut -d: -f1)

            if [[ "$FORCE" == true ]]; then
                echo -e "${YELLOW}Force killing agents (per-agent layout)...${NC}"

                # Send Ctrl-C and exit to each agent window's panes
                for window_id in $agent_windows; do
                    local window_name=$(tmux list-windows -t "$target_session" | grep "^${window_id}:" | sed 's/^[0-9]*: \([^ ]*\).*/\1/')
                    debug "Stopping window: $window_name"

                    # Send Ctrl-C to both panes (claude on left, shell on right)
                    tmux send-keys -t "$target_session:${window_id}.1" C-c 2>/dev/null || true
                    tmux send-keys -t "$target_session:${window_id}.2" C-c 2>/dev/null || true
                    sleep 0.3

                    # Send exit to both panes
                    tmux send-keys -t "$target_session:${window_id}.1" "exit" Enter 2>/dev/null || true
                    tmux send-keys -t "$target_session:${window_id}.2" "exit" Enter 2>/dev/null || true
                done
                sleep 0.5
            else
                echo -e "${YELLOW}Sending shutdown to agents (per-agent layout)...${NC}"

                # Send graceful shutdown to each agent window
                for window_id in $agent_windows; do
                    local window_name=$(tmux list-windows -t "$target_session" | grep "^${window_id}:" | sed 's/^[0-9]*: \([^ ]*\).*/\1/')
                    debug "Graceful shutdown to window: $window_name"

                    # Send shutdown message to claude pane (pane 1)
                    tmux send-keys -t "$target_session:${window_id}.1" "Please shut down gracefully. Finish any current task, log a shutdown event, then exit." Enter 2>/dev/null || true
                    tmux send-keys -t "$target_session:${window_id}.1" Enter 2>/dev/null || true
                done
                sleep 1
            fi
        fi

        echo -e "${YELLOW}Killing tmux session: $target_session${NC}"
        tmux kill-session -t "$target_session"
        echo -e "${GREEN}✓ Session stopped${NC}"
    fi
}

cmd_clean() {
    # Force mode: kill all related processes
    if [[ "$FORCE" == true ]]; then
        echo -e "${YELLOW}Force mode: killing all related processes...${NC}"
        
        # Kill tmux sessions
        if pgrep -x tmux > /dev/null; then
            echo -e "  ${YELLOW}Killing tmux...${NC}"
            pkill -x tmux 2>/dev/null || true
            sleep 0.5
        fi
        
        # Kill agent processes
        for proc in claude gemini copilot; do
            if pgrep -f "$proc" > /dev/null; then
                echo -e "  ${YELLOW}Killing $proc...${NC}"
                pkill -f "$proc" 2>/dev/null || true
            fi
        done
        sleep 0.5
    fi

    # Stop session first if running
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        echo -e "${YELLOW}Stopping session first...${NC}"
        tmux kill-session -t "$SESSION"
    fi

    echo "Checking worktrees for cleanup..."

    # Find all agent worktrees dynamically
    if [[ -d "$WORKTREE_ROOT" ]]; then
        for worktree_path in "$WORKTREE_ROOT"/agent-*; do
            [[ -d "$worktree_path" ]] || continue
            local agent=$(basename "$worktree_path")
            local branch="$agent"

            # Check for uncommitted changes
            pushd "$worktree_path" > /dev/null
            local has_changes=$(git status --porcelain)
            popd > /dev/null

            if [[ -n "$has_changes" ]] && [[ "$FORCE" != true ]]; then
                echo -e "  ${RED}✗${NC} $agent: uncommitted changes (use --force to override)"
                continue
            fi

            if [[ "$FORCE" == true ]]; then
                echo -e "  ${YELLOW}!${NC} $agent: force removing"
                git worktree remove "$worktree_path" --force 2>/dev/null || rm -rf "$worktree_path"
                git branch -D "$branch" 2>/dev/null || true
                continue
            fi

            # Check if branch is merged into main
            pushd "$REPO_ROOT" > /dev/null
            if git branch --merged main 2>/dev/null | grep -q "$branch"; then
                echo -e "  ${GREEN}✓${NC} $agent: branch merged, removing"
                git worktree remove "$worktree_path" --force
                git branch -d "$branch" 2>/dev/null || true
            else
                echo -e "  ${YELLOW}!${NC} $agent: branch not merged into main, skipping"
            fi
            popd > /dev/null
        done
    fi

    if [[ -d "$WORKTREE_ROOT" ]] && [[ -z "$(ls -A "$WORKTREE_ROOT")" ]]; then
        rmdir "$WORKTREE_ROOT"
        echo -e "${GREEN}✓ Worktree directory removed${NC}"
    fi

    git worktree prune

    # Clean shared state if all worktrees are removed
    if [[ ! -d "$WORKTREE_ROOT" ]] || [[ -z "$(ls -A "$WORKTREE_ROOT")" ]]; then
        if [[ -d "$SHARED_CONTEXT" ]]; then
            if [[ "$FORCE" == true ]]; then
                echo -e "  ${YELLOW}!${NC} Force removing shared state"
                rm -rf "$SHARED_CONTEXT"
                echo -e "${GREEN}✓ Shared state removed${NC}"
            else
                # Only remove if tasks are all done (no pending/active)
                local pending=$(ls -1 "$SHARED_CONTEXT/jobs/pending" 2>/dev/null | wc -l | tr -d ' ')
                local active=$(ls -1 "$SHARED_CONTEXT/jobs/active" 2>/dev/null | wc -l | tr -d ' ')
                if [[ "$pending" -eq 0 ]] && [[ "$active" -eq 0 ]]; then
                    rm -rf "$SHARED_CONTEXT"
                    echo -e "${GREEN}✓ Shared state removed${NC}"
                else
                    echo -e "  ${YELLOW}!${NC} Shared state has pending/active tasks, keeping (use --force to override)"
                fi
            fi
        fi
    fi

    echo -e "${GREEN}✓ Cleanup complete${NC}"
}

cmd_info() {
    echo -e "${BOLD}Claude Swarm Status${NC}"
    echo ""
    echo -e "${BOLD}Project:${NC} $REPO_NAME"
    echo ""

    # Session status
    echo -e "${BOLD}Session:${NC}"
    if tmux has-session -t "$SESSION" 2>/dev/null; then
        echo -e "  Status: ${GREEN}running${NC}"
        echo -e "  Attach: tmux attach -t $SESSION"
    else
        echo -e "  Status: ${YELLOW}stopped${NC}"
    fi
    echo ""

    # Worktrees
    echo -e "${BOLD}Agents:${NC}"
    for i in 1 2 3 4; do
        local worktree_path="$WORKTREE_ROOT/agent-$i"
        if [[ -d "$worktree_path" ]]; then
            local model=$(get_model $i 4)  # Show potential model
            pushd "$worktree_path" > /dev/null
            local branch=$(git branch --show-current)
            local status=""
            if [[ -n $(git status --porcelain) ]]; then
                status=" ${YELLOW}(uncommitted changes)${NC}"
            fi
            popd > /dev/null
            echo -e "  agent-$i: ${GREEN}exists${NC} [$branch]$status"
        fi
    done
    if [[ ! -d "$WORKTREE_ROOT" ]]; then
        echo "  (no worktrees)"
    fi
    echo ""

    # Tasks
    echo -e "${BOLD}Tasks:${NC}"
    local pending=$(ls -1 "$SHARED_CONTEXT/jobs/pending" 2>/dev/null | wc -l | tr -d ' ')
    local active=$(ls -1 "$SHARED_CONTEXT/jobs/active" 2>/dev/null | wc -l | tr -d ' ')
    local done=$(ls -1 "$SHARED_CONTEXT/jobs/done" 2>/dev/null | wc -l | tr -d ' ')
    echo "  Pending: $pending"
    echo "  Active:  $active"
    echo "  Done:    $done"
    
    if [[ "$active" -gt 0 ]]; then
        echo ""
        echo -e "${BOLD}Active Tasks:${NC}"
        for f in "$SHARED_CONTEXT/jobs/active"/*.yaml; do
            [[ -f "$f" ]] || continue
            local id=$(basename "$f" .yaml)
            local title=$(grep "^title:" "$f" | cut -d: -f2- | xargs)
            local claimed=$(grep "^claimed_by:" "$f" | cut -d: -f2- | xargs)
            echo "  $id: $title (${claimed:-unclaimed})"
        done
    fi
    echo ""

    # Recent events
    if [[ -f "$SHARED_CONTEXT/events.log" ]]; then
        local event_count=$(grep -v "^#" "$SHARED_CONTEXT/events.log" | grep -v "^$" | wc -l | tr -d ' ')
        if [[ "$event_count" -gt 0 ]]; then
            echo -e "${BOLD}Recent Events:${NC}"
            grep -v "^#" "$SHARED_CONTEXT/events.log" | grep -v "^$" | tail -5 | while read line; do
                echo "  $line"
            done
        fi
    fi
    echo ""

    # Paths
    echo -e "${BOLD}Paths:${NC}"
    echo "  Worktrees:    $WORKTREE_ROOT/"
    echo "  Shared state: $SHARED_CONTEXT/"
}

# Parse options
while [[ $# -gt 0 ]]; do
    case $1 in
        -n)
            if [[ "$2" =~ ^[2-6]$ ]]; then
                AGENT_COUNT=$2
                shift 2
            else
                echo -e "${RED}Error: -n requires 2, 3, 4, or 6${NC}"
                exit 1
            fi
            ;;
        --version)
            show_version
            exit 0
            ;;
        --equal)
            EQUAL_DISTRIBUTION=true
            shift
            ;;
        -o|--classic)
            CLASSIC_MODE=true
            shift
            ;;
        --opus)
            OPUS_MODE=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --yolo)
            SKIP_PERMISSIONS="--dangerously-skip-permissions"
            shift
            ;;
        -d|--daemon)
            DAEMON_MODE=true
            shift
            ;;
        -h|--help)
            print_usage
            exit 0
            ;;
        start|stop|clean|info|restart|attach|workspace)
            COMMAND=$1
            shift
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo ""
            echo "Did you mean one of these?"
            echo "  launch-agents          Start or attach (smart default)"
            echo "  launch-agents start    Start agents"
            echo "  launch-agents stop     Stop agents"
            echo "  launch-agents workspace  Simple workspace"
            echo "  launch-agents info     Show status"
            echo ""
            exit 1
            ;;
    esac
done

# Execute command
case ${COMMAND:-} in
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    clean)
        cmd_clean
        ;;
    info)
        cmd_info
        ;;
    workspace)
        cmd_workspace
        ;;
    restart)
        # Restart is just stop + start with force
        FORCE=true
        cmd_stop 2>/dev/null || true
        sleep 0.5
        cmd_start
        ;;
    attach)
        if tmux has-session -t "$SESSION" 2>/dev/null; then
            tmux attach -t "$SESSION"
        else
            echo -e "${RED}No session '$SESSION' running${NC}"
            echo "Run 'launch-agents start' to create one"
            exit 1
        fi
        ;;
    "")
        # Smart default: start or attach if already running
        if tmux has-session -t "$SESSION" 2>/dev/null; then
            echo -e "${GREEN}Session exists, attaching...${NC}"
            tmux attach -t "$SESSION"
        else
            cmd_start
        fi
        ;;
    *)
        echo -e "${RED}Unknown command: $COMMAND${NC}"
        print_usage
        exit 1
        ;;
esac
