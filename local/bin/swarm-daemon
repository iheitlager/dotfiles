#!/usr/bin/env python3
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

"""
swarm-daemon - Unified scheduler, watcher, and REPL for agent swarms

Phase 1: Basic work visibility
- Track when agents start/stop working
- Monitor agent heartbeats
- Provide REPL for investigation

Phase 2: Issue & PR tracking
- Track job lifecycle (claimed → PR → merged)
- Monitor what each agent is working on
- Calculate time-to-PR and time-to-merge metrics
- Reactive actions (sync broadcast, work suggestions)

Phase 3: Semantic events & deep visibility
- Rich activity tracking (tasks, tools, git, tests)
- Time breakdown by activity type
- Pattern detection and bottleneck identification
- Visual timelines and performance analytics

Usage:
    swarm-daemon daemon         Run in background (monitoring mode)
    swarm-daemon repl           Interactive investigation shell
    swarm-daemon status         Quick status overview
    swarm-daemon agents         List agent status
    swarm-daemon log            Show recent events
    swarm-daemon hook <EVENT>   Record event (called by agents)

Note: This script has zero external dependencies - pure stdlib only.
"""

import logging
import logging.handlers
import os
import sys
import time
import signal
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, Optional, List
import subprocess
import json

# =============================================================================
# INLINE YAML HANDLING (Minimal implementation - no external deps)
# =============================================================================

class SimpleYAML:
    """Minimal YAML reader/writer for our simple state files"""

    @staticmethod
    def load(file_path: Path) -> Dict:
        """Load simple YAML file (agents state only)"""
        if not file_path.exists():
            return {"agents": {}}

        try:
            with open(file_path) as f:
                content = f.read()

            # Simple parsing for our specific structure
            result = {"agents": {}}
            current_agent = None

            for line in content.split('\n'):
                line = line.rstrip()

                if not line or line.startswith('#'):
                    continue

                # Top level key
                if line.startswith('agents:'):
                    continue

                # Agent ID
                if line.startswith('  ') and line[2:3] != ' ' and ':' in line:
                    current_agent = line.strip().rstrip(':')
                    result["agents"][current_agent] = {}

                # Agent properties
                elif line.startswith('    ') and current_agent and ':' in line:
                    key, value = line.strip().split(':', 1)
                    value = value.strip()

                    # Remove quotes
                    if value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]

                    result["agents"][current_agent][key] = value

            return result
        except Exception as e:
            return {"agents": {}}

    @staticmethod
    def dump(data: Dict, file_path: Path):
        """Write simple YAML file"""
        lines = ["agents:"]

        for agent_id, agent_data in data.get("agents", {}).items():
            lines.append(f"  {agent_id}:")
            for key, value in agent_data.items():
                # Quote strings with special chars
                if isinstance(value, str) and (':' in value or value.startswith(' ')):
                    value = f'"{value}"'
                lines.append(f"    {key}: {value}")

        try:
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
        except Exception as e:
            pass

class SimpleJobMetricsYAML:
    """Minimal YAML reader/writer for job-metrics.yaml"""

    @staticmethod
    def load(file_path: Path) -> Dict:
        """Load job metrics YAML file"""
        if not file_path.exists():
            return {"active": {}, "completed_today": []}

        try:
            with open(file_path) as f:
                content = f.read()

            result = {"active": {}, "completed_today": []}
            current_section = None
            current_job = None
            in_completed = False
            current_completed_item = {}

            for line in content.split('\n'):
                line_stripped = line.rstrip()

                if not line_stripped or line_stripped.startswith('#'):
                    continue

                # Top level sections
                if line_stripped == "active:":
                    current_section = "active"
                    in_completed = False
                    continue
                elif line_stripped == "completed_today:":
                    current_section = "completed_today"
                    in_completed = True
                    continue

                # Active jobs (2-space indent for job ID, 4-space for properties)
                if current_section == "active" and line.startswith('  ') and not line.startswith('    '):
                    current_job = line.strip().rstrip(':')
                    result["active"][current_job] = {}
                elif current_section == "active" and line.startswith('    ') and current_job:
                    key, value = line.strip().split(':', 1)
                    value = value.strip()
                    # Handle null
                    if value == "null" or value == "~":
                        value = None
                    # Remove quotes
                    elif value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.startswith("'") and value.endswith("'"):
                        value = value[1:-1]
                    # Try to convert to int
                    elif value.isdigit():
                        value = int(value)
                    result["active"][current_job][key] = value

                # Completed jobs (list items starting with '- ')
                elif in_completed and line.startswith('  - '):
                    # Save previous item if exists
                    if current_completed_item:
                        result["completed_today"].append(current_completed_item)
                    current_completed_item = {}
                    # Parse first key-value
                    rest = line[4:].strip()
                    if ':' in rest:
                        key, value = rest.split(':', 1)
                        value = value.strip()
                        if value.startswith('"') and value.endswith('"'):
                            value = value[1:-1]
                        elif value.isdigit():
                            value = int(value)
                        current_completed_item[key] = value
                elif in_completed and line.startswith('    ') and not line.startswith('  - '):
                    # Additional properties for list item
                    key, value = line.strip().split(':', 1)
                    value = value.strip()
                    if value == "null" or value == "~":
                        value = None
                    elif value.startswith('"') and value.endswith('"'):
                        value = value[1:-1]
                    elif value.isdigit():
                        value = int(value)
                    current_completed_item[key] = value

            # Save last completed item
            if current_completed_item:
                result["completed_today"].append(current_completed_item)

            return result
        except Exception as e:
            return {"active": {}, "completed_today": []}

    @staticmethod
    def dump(data: Dict, file_path: Path):
        """Write job metrics YAML file"""
        lines = []

        # Active jobs
        lines.append("active:")
        active = data.get("active", {})
        if active:
            for job_id, job_data in active.items():
                lines.append(f"  {job_id}:")
                for key, value in job_data.items():
                    if value is None:
                        value = "null"
                    elif isinstance(value, str) and (':' in value or value.startswith(' ')):
                        value = f'"{value}"'
                    lines.append(f"    {key}: {value}")
        else:
            lines.append("  {}")

        # Completed jobs
        lines.append("")
        lines.append("completed_today:")
        completed = data.get("completed_today", [])
        if completed:
            for item in completed:
                first_key = True
                for key, value in item.items():
                    if value is None:
                        value = "null"
                    elif isinstance(value, str) and (':' in value or value.startswith(' ')):
                        value = f'"{value}"'

                    if first_key:
                        lines.append(f"  - {key}: {value}")
                        first_key = False
                    else:
                        lines.append(f"    {key}: {value}")
        else:
            lines.append("  []")

        try:
            with open(file_path, 'w') as f:
                f.write('\n'.join(lines) + '\n')
        except Exception as e:
            pass

# =============================================================================
# CONFIGURATION LOADING
# =============================================================================

class DaemonConfig:
    """Configuration for swarm-daemon"""

    def __init__(self):
        # Default values
        self.enable_stale_check = False  # Disabled by default
        self.stale_check_interval = 5
        self.stale_log_interval = 300
        self.stale_threshold_minutes = 5
        self.log_level = "INFO"
        self.max_log_size_mb = 10
        self.backup_count = 5

    @classmethod
    def load(cls, config_path: Path) -> 'DaemonConfig':
        """Load configuration from YAML file"""
        config = cls()

        if not config_path.exists():
            return config  # Return defaults

        try:
            with open(config_path) as f:
                content = f.read()

            # Simple YAML parsing for our config structure
            current_section = None
            for line in content.split('\n'):
                line = line.strip()
                if not line or line.startswith('#'):
                    continue

                # Section headers
                if line == "monitoring:":
                    current_section = "monitoring"
                elif line == "logging:":
                    current_section = "logging"
                elif ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()

                    # Parse values
                    if value.isdigit():
                        value = int(value)
                    elif value in ('true', 'True'):
                        value = True
                    elif value in ('false', 'False'):
                        value = False

                    # Assign to config
                    if current_section == "monitoring":
                        if key == "enable_stale_check":
                            config.enable_stale_check = value
                        elif key == "stale_check_interval":
                            config.stale_check_interval = value
                        elif key == "stale_log_interval":
                            config.stale_log_interval = value
                        elif key == "stale_threshold_minutes":
                            config.stale_threshold_minutes = value
                    elif current_section == "logging":
                        if key == "level":
                            config.log_level = value
                        elif key == "max_log_size_mb":
                            config.max_log_size_mb = value
                        elif key == "backup_count":
                            config.backup_count = value

        except Exception as e:
            pass  # Use defaults on error

        return config

# =============================================================================
# TIME UTILITIES
# =============================================================================

def format_duration(start_iso: str, end_iso: str) -> str:
    """Calculate duration between two ISO timestamps and format as human-readable"""
    try:
        start = datetime.fromisoformat(start_iso)
        end = datetime.fromisoformat(end_iso)
        delta = end - start

        total_seconds = int(delta.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60

        if hours > 0:
            return f"{hours}h{minutes}m"
        else:
            return f"{minutes}m"
    except:
        return "unknown"

def calculate_duration_seconds(start_iso: str, end_iso: str) -> Optional[int]:
    """Calculate duration in seconds between two ISO timestamps"""
    try:
        start = datetime.fromisoformat(start_iso)
        end = datetime.fromisoformat(end_iso)
        return int((end - start).total_seconds())
    except:
        return None

# =============================================================================
# LOGGING SETUP (XDG compliant with rotation)
# =============================================================================

def setup_logging(daemon_mode: bool = False, context: Optional['SwarmContext'] = None):
    """Configure logging to context directory with rotation

    Logs go to: ~/.local/state/agent-context/<repo>/daemon/swarm-daemon.log
    """
    if context:
        # Use context-specific log location
        log_dir = context.state_dir / "daemon"
        log_dir.mkdir(parents=True, exist_ok=True)
        log_file = log_dir / "swarm-daemon.log"
    else:
        # Fallback for early initialization (before context available)
        xdg_state = os.environ.get("XDG_STATE_HOME", os.path.expanduser("~/.local/state"))
        log_dir = Path(xdg_state) / "swarm-daemon"
        log_dir.mkdir(parents=True, exist_ok=True)
        log_file = log_dir / "swarm-daemon.log"

    # Rotating file handler: 1MB max, keep 3 backups
    handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=1_000_000,  # 1MB
        backupCount=3,
    )
    handler.setFormatter(logging.Formatter(
        "%(asctime)s [%(levelname)s] %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S"
    ))

    # Console handler for non-daemon mode
    console = logging.StreamHandler()
    console.setFormatter(logging.Formatter("%(message)s"))

    logger = logging.getLogger("swarm-daemon")
    logger.setLevel(logging.INFO)
    logger.addHandler(handler)

    # Only log to console in non-daemon mode or if interactive
    if not daemon_mode or sys.stderr.isatty():
        logger.addHandler(console)

    return logger

log = None  # Will be set in main()

# =============================================================================
# REPOSITORY & STATE DETECTION
# =============================================================================

class SwarmContext:
    """Manages paths and state for the current swarm (git repo)

    Context = git repository (whether in worktree or not).
    One daemon per context, all state files isolated per context.
    """

    def __init__(self, context_override: Optional[str] = None):
        """Initialize context.

        Args:
            context_override: Manually specify context (repo name) instead of
                             detecting from current directory's git repo.
        """
        self.context_override = context_override

        if context_override:
            # Manual context mode - don't need to be in a git repo
            self.repo_root = None
            self.repo_name = context_override.lstrip('.')
        else:
            # Auto-detect from current git repo
            self.repo_root = self._get_repo_root()
            self.repo_name = self._get_repo_name()

        self.state_dir = self._get_state_dir()
        self.config_path = self._get_config_path()
        self.ensure_directories()

    def _get_repo_root(self) -> Optional[Path]:
        """Get git repository root (None if not in a git repo)"""
        try:
            result = subprocess.run(
                ["git", "rev-parse", "--show-toplevel"],
                capture_output=True,
                text=True,
                check=True
            )
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            if self.context_override:
                return None  # OK if using --context
            print("Error: Not in a git repository (use --context <repo>)", file=sys.stderr)
            sys.exit(1)

    def _get_repo_name(self) -> str:
        """Get repository name (handles worktree paths and leading dots)"""
        if not self.repo_root:
            return "unknown"

        local_repo_name = self.repo_root.name.lstrip('.')
        local_repo_parent = self.repo_root.parent.name

        # Handle worktree paths
        if local_repo_parent.endswith("-worktree"):
            return local_repo_parent.replace("-worktree", "").lstrip('.')
        elif local_repo_name.endswith("-worktree"):
            return local_repo_name.replace("-worktree", "").lstrip('.')
        else:
            return local_repo_name

    def _get_state_dir(self) -> Path:
        """Get XDG state directory for this project"""
        xdg_state = os.environ.get("XDG_STATE_HOME", os.path.expanduser("~/.local/state"))
        return Path(xdg_state) / "agent-context" / self.repo_name

    def _get_config_path(self) -> Path:
        """Get configuration file path (check dotfiles, then XDG config)"""
        # First check if we're in dotfiles repo
        if self.repo_root:
            dotfiles_config = self.repo_root / "config" / "swarm-daemon" / "config.yml"
            if dotfiles_config.exists():
                return dotfiles_config

        # Fall back to XDG config or dotfiles home
        dotfiles_home = Path.home() / ".dotfiles" / "config" / "swarm-daemon" / "config.yml"
        if dotfiles_home.exists():
            return dotfiles_home

        xdg_config = os.environ.get("XDG_CONFIG_HOME", os.path.expanduser("~/.config"))
        return Path(xdg_config) / "swarm-daemon" / "config.yml"

    def ensure_directories(self):
        """Ensure all required directories exist"""
        # Job queue directories (should already exist from swarm-job)
        (self.state_dir / "jobs" / "pending").mkdir(parents=True, exist_ok=True)
        (self.state_dir / "jobs" / "active").mkdir(parents=True, exist_ok=True)
        (self.state_dir / "jobs" / "done").mkdir(parents=True, exist_ok=True)

        # Daemon state directory (new)
        (self.state_dir / "daemon").mkdir(parents=True, exist_ok=True)

    @property
    def events_log(self) -> Path:
        return self.state_dir / "events.log"

    @property
    def agent_state_file(self) -> Path:
        return self.state_dir / "daemon" / "agent-state.yaml"

    @property
    def daemon_pid_file(self) -> Path:
        return self.state_dir / "daemon" / "daemon.pid"

    @property
    def job_metrics_file(self) -> Path:
        return self.state_dir / "daemon" / "job-metrics.yaml"

    @property
    def session_name(self) -> str:
        """Get tmux session name (sanitized)"""
        return f"claude-{self.repo_name.replace('.', '_')}"

# =============================================================================
# AGENT STATE MANAGEMENT
# =============================================================================

class AgentStateManager:
    """Manages agent state (working/idle, heartbeats)"""

    def __init__(self, context: SwarmContext):
        self.context = context
        self.state: Dict = {"agents": {}}
        self.load_state()

    def load_state(self):
        """Load agent state from YAML file"""
        try:
            self.state = SimpleYAML.load(self.context.agent_state_file)
        except Exception as e:
            log.error(f"Failed to load agent state: {e}")
            self.state = {"agents": {}}

    def save_state(self):
        """Save agent state to YAML file"""
        try:
            SimpleYAML.dump(self.state, self.context.agent_state_file)
        except Exception as e:
            log.error(f"Failed to save agent state: {e}")

    def update_agent(self, agent_id: str, **kwargs):
        """Update agent state fields"""
        if agent_id not in self.state["agents"]:
            self.state["agents"][agent_id] = {}

        self.state["agents"][agent_id].update(kwargs)
        self.save_state()

    def get_agent(self, agent_id: str) -> Optional[Dict]:
        """Get agent state"""
        return self.state["agents"].get(agent_id)

    def get_all_agents(self) -> Dict:
        """Get all agent states"""
        return self.state["agents"]

    def get_working_agents(self) -> List[str]:
        """Get list of agents currently working"""
        return [
            agent_id for agent_id, state in self.state["agents"].items()
            if state.get("status") == "working"
        ]

    def get_idle_agents(self) -> List[str]:
        """Get list of idle agents"""
        return [
            agent_id for agent_id, state in self.state["agents"].items()
            if state.get("status") == "idle"
        ]

    def remove_agent(self, agent_id: str):
        """Remove an agent from the state"""
        if agent_id in self.state["agents"]:
            del self.state["agents"][agent_id]
            self.save_state()

    def check_stale_agents(self, threshold_minutes: int = 5) -> List[str]:
        """Find agents with no heartbeat in threshold_minutes"""
        stale = []
        threshold = datetime.now() - timedelta(minutes=threshold_minutes)

        for agent_id, state in self.state["agents"].items():
            last_heartbeat = state.get("last_heartbeat")
            if last_heartbeat:
                try:
                    last_time = datetime.fromisoformat(last_heartbeat)
                    if last_time < threshold:
                        stale.append(agent_id)
                except ValueError:
                    pass

        return stale

# =============================================================================
# JOB METRICS MANAGEMENT (Phase 2)
# =============================================================================

class JobMetricsManager:
    """Manages job metrics (active jobs, completed jobs, performance tracking)"""

    def __init__(self, context: SwarmContext):
        self.context = context
        self.state: Dict = {"active": {}, "completed_today": []}
        self.load_state()

    def load_state(self):
        """Load job metrics from YAML file"""
        try:
            self.state = SimpleJobMetricsYAML.load(self.context.job_metrics_file)
        except Exception as e:
            log.error(f"Failed to load job metrics: {e}")
            self.state = {"active": {}, "completed_today": []}

    def save_state(self):
        """Save job metrics to YAML file"""
        try:
            SimpleJobMetricsYAML.dump(self.state, self.context.job_metrics_file)
        except Exception as e:
            log.error(f"Failed to save job metrics: {e}")

    def claim_job(self, job_id: str, issue: int, title: str, agent: str, claimed_at: str):
        """Register a new claimed job"""
        self.state["active"][job_id] = {
            "issue": issue,
            "title": title,
            "agent": agent,
            "claimed_at": claimed_at,
            "pr_number": None,
            "state": "working",
            # Phase 3: Initialize activity counters
            "tasks_created": 0,
            "tasks_completed": 0,
            "files_read": 0,
            "files_edited": 0,
            "files_written": 0,
            "lines_changed": 0,
            "commits": 0,
            "test_runs": 0,
            "test_failures": 0,
            "bash_commands": 0
        }
        self.save_state()

    def mark_pr_ready(self, job_id: str, pr_number: int, pr_ready_at: str):
        """Mark job as having a PR created"""
        if job_id in self.state["active"]:
            self.state["active"][job_id]["pr_number"] = pr_number
            self.state["active"][job_id]["pr_ready_at"] = pr_ready_at
            self.state["active"][job_id]["state"] = "pr_ready"
            self.save_state()

    def mark_pr_merged(self, job_id: str, pr_merged_at: str):
        """Mark job as merged and move to completed"""
        if job_id in self.state["active"]:
            job = self.state["active"][job_id]
            job["pr_merged_at"] = pr_merged_at
            job["state"] = "pr_merged"

            # Calculate metrics
            claimed_at = job.get("claimed_at")
            pr_ready_at = job.get("pr_ready_at")

            time_to_pr = None
            time_to_merge = None
            total_time = None

            if claimed_at and pr_ready_at:
                time_to_pr = format_duration(claimed_at, pr_ready_at)
            if pr_ready_at and pr_merged_at:
                time_to_merge = format_duration(pr_ready_at, pr_merged_at)
            if claimed_at and pr_merged_at:
                total_time = format_duration(claimed_at, pr_merged_at)

            # Move to completed
            completed_job = {
                "job_id": job_id,
                "issue": job.get("issue"),
                "title": job.get("title"),
                "agent": job.get("agent"),
                "pr_number": job.get("pr_number"),
                "time_to_pr": time_to_pr or "unknown",
                "time_to_merge": time_to_merge or "unknown",
                "total_time": total_time or "unknown"
            }
            self.state["completed_today"].append(completed_job)

            # Remove from active
            del self.state["active"][job_id]
            self.save_state()

    def get_active_jobs(self) -> Dict:
        """Get all active jobs"""
        return self.state["active"]

    def get_completed_jobs(self) -> List[Dict]:
        """Get completed jobs"""
        return self.state["completed_today"]

    def get_job_by_agent(self, agent: str) -> Optional[str]:
        """Find active job ID for an agent"""
        for job_id, job in self.state["active"].items():
            if job.get("agent") == agent:
                return job_id
        return None

    def clear_completed(self):
        """Clear completed jobs (for daily reset)"""
        self.state["completed_today"] = []
        self.save_state()

    # Phase 3: Activity tracking methods
    def _ensure_activity_counters(self, job_id: str):
        """Ensure job has activity counter fields"""
        if job_id in self.state["active"]:
            job = self.state["active"][job_id]
            if "tasks_created" not in job:
                job["tasks_created"] = 0
                job["tasks_completed"] = 0
                job["files_read"] = 0
                job["files_edited"] = 0
                job["files_written"] = 0
                job["lines_changed"] = 0
                job["commits"] = 0
                job["test_runs"] = 0
                job["test_failures"] = 0
                job["bash_commands"] = 0

    def increment_activity(self, job_id: str, activity: str, amount: int = 1):
        """Increment activity counter for a job"""
        self._ensure_activity_counters(job_id)
        if job_id in self.state["active"]:
            counter_map = {
                "TASK_CREATED": "tasks_created",
                "TASK_COMPLETED": "tasks_completed",
                "TOOL_READ": "files_read",
                "TOOL_EDIT": "files_edited",
                "TOOL_WRITE": "files_written",
                "GIT_COMMIT": "commits",
                "TEST_STARTED": "test_runs",
                "TEST_FAILED": "test_failures",
                "TOOL_BASH": "bash_commands"
            }
            if activity in counter_map:
                counter = counter_map[activity]
                self.state["active"][job_id][counter] += amount
                self.save_state()

    def add_lines_changed(self, job_id: str, lines: int):
        """Add to lines changed counter"""
        self._ensure_activity_counters(job_id)
        if job_id in self.state["active"]:
            self.state["active"][job_id]["lines_changed"] += lines
            self.save_state()

# =============================================================================
# EVENT LOGGING
# =============================================================================

class EventLogger:
    """Handles event logging to events.log"""

    def __init__(self, context: SwarmContext):
        self.context = context
        self.ensure_log_file()

    def ensure_log_file(self):
        """Ensure events.log exists"""
        if not self.context.events_log.exists():
            self.context.events_log.touch()

    def log_event(self, agent_id: str, event_type: str, data: str = ""):
        """Append event to events.log"""
        timestamp = datetime.now().isoformat()
        line = f"{timestamp} | {agent_id} | {event_type} | {data}\n"

        try:
            with open(self.context.events_log, 'a') as f:
                f.write(line)
        except Exception as e:
            log.error(f"Failed to write event: {e}")

    def read_recent_events(self, limit: int = 20) -> List[str]:
        """Read recent events from log"""
        if not self.context.events_log.exists():
            return []

        try:
            with open(self.context.events_log) as f:
                lines = f.readlines()
            return lines[-limit:]
        except Exception as e:
            log.error(f"Failed to read events: {e}")
            return []

    def filter_events(self, agent_id: Optional[str] = None, event_type: Optional[str] = None, limit: int = 50) -> List[str]:
        """Filter events by agent or event type"""
        if not self.context.events_log.exists():
            return []

        try:
            with open(self.context.events_log) as f:
                lines = f.readlines()

            filtered = []
            for line in reversed(lines):
                parts = line.split(" | ")
                if len(parts) >= 3:
                    line_agent = parts[1].strip()
                    line_event = parts[2].strip()

                    if agent_id and line_agent != agent_id:
                        continue
                    if event_type and line_event != event_type:
                        continue

                    filtered.append(line)
                    if len(filtered) >= limit:
                        break

            return list(reversed(filtered))
        except Exception as e:
            log.error(f"Failed to filter events: {e}")
            return []

# =============================================================================
# HOOK HANDLER (Fast Event Recording)
# =============================================================================

def handle_hook(context: SwarmContext, event_type: str, args: List[str]):
    """Handle hook events from agents - MUST BE FAST"""
    agent_id = os.environ.get("AGENT_ID", "unknown")
    agent_context = os.environ.get("AGENT_CONTEXT", "unknown")

    # Parse arguments
    data = " ".join(args)

    # Quick validation - simplified event types
    valid_events = {
        # Phase 1: Basic agent lifecycle (ACTIVE)
        "AGENT_STARTUP", "AGENT_SHUTDOWN",

        # Phase 1: Request tracking (ACTIVE)
        # Simplified model: track each tool use as REQUEST instead of tool-specific events
        "REQUEST", "REQUEST_START", "REQUEST_END",

        # Phase 2: Job lifecycle (ACTIVE - emitted by swarm-job and skills)
        "JOB_CLAIMED", "JOB_PR_READY", "JOB_PR_MERGED", "JOB_COMPLETED",

        # Phase 3: Semantic events (ACTIVE - emitted automatically by swarm-hook)

        # Task tracking
        "TASK_CREATED", "TASK_STARTED", "TASK_COMPLETED", "TASK_BLOCKED",

        # Tool usage (granular)
        "TOOL_READ", "TOOL_EDIT", "TOOL_WRITE", "TOOL_BASH",
        "TOOL_GREP", "TOOL_GLOB", "TOOL_TASK",

        # Git operations
        "GIT_COMMIT", "GIT_PUSH", "GIT_REBASE", "GIT_CONFLICT",

        # Test/Build
        "TEST_STARTED", "TEST_PASSED", "TEST_FAILED",
        "LINT_STARTED", "LINT_PASSED", "LINT_FAILED",

        # Agent state
        "AGENT_THINKING", "AGENT_WAITING", "AGENT_ERROR"
    }
    if event_type not in valid_events:
        print(f"Warning: Unknown event type: {event_type}", file=sys.stderr)

    # Log event (fast append)
    event_logger = EventLogger(context)
    event_logger.log_event(agent_id, event_type, data)

    # Update agent state (quick YAML update)
    state_manager = AgentStateManager(context)
    job_metrics = JobMetricsManager(context)
    now = datetime.now().isoformat()

    # Get current job for this agent (used by Phase 3 events)
    current_job = job_metrics.get_job_by_agent(agent_id)

    # Phase 1 events
    if event_type == "AGENT_STARTUP":
        state_manager.update_agent(
            agent_id,
            status="working",
            started_at=now,
            last_heartbeat=now,
            context=agent_context
        )
    elif event_type in ("REQUEST", "REQUEST_START", "REQUEST_END"):
        # Just update heartbeat for request tracking
        state_manager.update_agent(
            agent_id,
            last_heartbeat=now
        )

    # Phase 2 events
    elif event_type == "JOB_CLAIMED":
        # Parse: job-id --issue N --title "Title"
        job_id = args[0] if args else "unknown"
        issue = None
        title = ""

        i = 1
        while i < len(args):
            if args[i] == "--issue" and i + 1 < len(args):
                try:
                    issue = int(args[i + 1])
                    i += 2
                except ValueError:
                    i += 1
            elif args[i] == "--title" and i + 1 < len(args):
                title = args[i + 1]
                i += 2
            else:
                i += 1

        if issue and title:
            job_metrics.claim_job(job_id, issue, title, agent_id, now)
            state_manager.update_agent(
                agent_id,
                current_job=job_id,
                current_issue=issue,
                claimed_at=now
            )

    elif event_type == "JOB_PR_READY":
        # Parse: job-id pr-number
        if len(args) >= 2:
            job_id = args[0]
            try:
                pr_number = int(args[1])
                job_metrics.mark_pr_ready(job_id, pr_number, now)
            except ValueError:
                pass

    elif event_type == "JOB_PR_MERGED":
        # Parse: job-id pr-number
        if len(args) >= 1:
            job_id = args[0]
            job_metrics.mark_pr_merged(job_id, now)
            # Clear current job from agent
            state_manager.update_agent(
                agent_id,
                status="idle",
                current_job=None,
                current_issue=None,
                last_stopped=now
            )

    elif event_type == "JOB_COMPLETED":
        # Parse: job-id
        if len(args) >= 1:
            job_id = args[0]
            # Clear current job from agent
            state_manager.update_agent(
                agent_id,
                status="idle",
                current_job=None,
                current_issue=None,
                last_stopped=now
            )

    # Phase 3 events: Semantic tracking
    # Task events
    elif event_type in ("TASK_CREATED", "TASK_COMPLETED"):
        if current_job:
            job_metrics.increment_activity(current_job, event_type)

    # Tool events
    elif event_type in ("TOOL_READ", "TOOL_EDIT", "TOOL_WRITE"):
        if current_job:
            job_metrics.increment_activity(current_job, event_type)
            # Parse --lines for TOOL_EDIT
            if event_type == "TOOL_EDIT" and "--lines" in args:
                try:
                    idx = args.index("--lines")
                    if idx + 1 < len(args):
                        lines = int(args[idx + 1])
                        job_metrics.add_lines_changed(current_job, lines)
                except (ValueError, IndexError):
                    pass

    elif event_type == "TOOL_BASH":
        if current_job:
            job_metrics.increment_activity(current_job, event_type)

    # Git events
    elif event_type == "GIT_COMMIT":
        if current_job:
            job_metrics.increment_activity(current_job, event_type)

    # Test events
    elif event_type in ("TEST_STARTED", "TEST_FAILED"):
        if current_job:
            job_metrics.increment_activity(current_job, event_type)

    # Note: Other Phase 3 events (TOOL_GREP, TOOL_GLOB, TOOL_TASK, GIT_PUSH,
    # GIT_REBASE, GIT_CONFLICT, TEST_PASSED, LINT_*, AGENT_THINKING, AGENT_WAITING,
    # AGENT_ERROR, TASK_STARTED, TASK_BLOCKED) are logged but don't update counters yet.
    # These can be used for timeline/pattern analysis in Phase 3B/3C.

    # Exit immediately (fire-and-forget)
    sys.exit(0)

# =============================================================================
# DAEMON MODE (Background Monitoring)
# =============================================================================

class SwarmDaemon:
    """Background daemon that monitors agent activity"""

    def __init__(self, context: SwarmContext):
        self.context = context
        self.state_manager = AgentStateManager(context)
        self.event_logger = EventLogger(context)
        self.running = True

        # Load configuration
        self.config = DaemonConfig.load(context.config_path)
        self.poll_interval = self.config.stale_check_interval

        # Track last log time for each agent (for rate-limiting)
        self.last_stale_log: Dict[str, float] = {}

        # Register signal handlers
        signal.signal(signal.SIGINT, self.handle_shutdown)
        signal.signal(signal.SIGTERM, self.handle_shutdown)

    def handle_shutdown(self, signum, frame):
        """Graceful shutdown handler"""
        log.info("Shutdown signal received - stopping daemon...")
        self.event_logger.log_event("swarm-daemon", "SHUTDOWN", "Daemon stopping")
        self.running = False

    def write_pid_file(self):
        """Write PID file for daemon tracking"""
        with open(self.context.daemon_pid_file, 'w') as f:
            f.write(str(os.getpid()))

    def remove_pid_file(self):
        """Remove PID file on shutdown"""
        if self.context.daemon_pid_file.exists():
            self.context.daemon_pid_file.unlink()

    def check_for_stale_agents(self):
        """Check for agents with no recent heartbeat (with rate-limited logging)"""
        # Skip if stale checking is disabled
        if not self.config.enable_stale_check:
            return

        stale = self.state_manager.check_stale_agents(
            threshold_minutes=self.config.stale_threshold_minutes
        )

        current_time = time.time()

        for agent_id in stale:
            # Always log event (for tracking)
            self.event_logger.log_event("swarm-daemon", "AGENT_STALE", agent_id)

            # Rate-limit warning logs
            last_log_time = self.last_stale_log.get(agent_id, 0)
            if current_time - last_log_time >= self.config.stale_log_interval:
                log.warning(
                    f"Agent {agent_id} appears stale "
                    f"(no heartbeat for {self.config.stale_threshold_minutes}m)"
                )
                self.last_stale_log[agent_id] = current_time

    def detect_patterns(self):
        """Detect patterns and anomalies (Phase 3)"""
        job_metrics = JobMetricsManager(self.context)
        active_jobs = job_metrics.get_active_jobs()

        # Pattern 1: Repeated test failures
        for job_id, job in active_jobs.items():
            test_failures = job.get("test_failures", 0)
            if test_failures >= 3:
                agent = job.get("agent", "unknown")
                issue = job.get("issue", "?")
                log.warning(f"Pattern detected: {agent} has {test_failures} test failures on #{issue}")
                self.event_logger.log_event("swarm-daemon", "PATTERN_TEST_FAILURES",
                                          f"{job_id} agent={agent} failures={test_failures}")

        # Pattern 2: Stuck jobs (claimed for > 60m with minimal activity)
        for job_id, job in active_jobs.items():
            claimed_at = job.get("claimed_at")
            if claimed_at:
                try:
                    claimed_time = datetime.fromisoformat(claimed_at)
                    elapsed = datetime.now() - claimed_time
                    minutes_elapsed = int(elapsed.total_seconds() / 60)

                    if minutes_elapsed > 60:
                        total_activity = (
                            job.get("files_read", 0) +
                            job.get("files_edited", 0) +
                            job.get("commits", 0)
                        )
                        if total_activity < 2:
                            agent = job.get("agent", "unknown")
                            log.warning(f"Pattern detected: Job {job_id} stuck ({minutes_elapsed}m, minimal activity)")
                            self.event_logger.log_event("swarm-daemon", "PATTERN_STUCK_JOB",
                                                      f"{job_id} agent={agent} elapsed={minutes_elapsed}m")
                except ValueError:
                    pass

    def _is_foreground(self) -> bool:
        """Returns True if running in a terminal (foreground mode)"""
        return sys.stderr.isatty()

    def _init_event_tail(self):
        """Open events.log and seek to EOF for tail-follow behavior"""
        if not self.context.events_log.exists():
            self.context.events_log.touch()
        self._event_file = open(self.context.events_log)
        self._event_file.seek(0, 2)  # Seek to EOF

    def _drain_new_events(self) -> int:
        """Read all available new lines from events log and print them"""
        count = 0
        while True:
            line = self._event_file.readline()
            if not line:
                break
            self._print_event_line(line)
            count += 1
        return count

    def _print_event_line(self, line: str):
        """Format and print one event line with ANSI colors"""
        # ANSI color codes
        GREEN = '\033[0;32m'
        YELLOW = '\033[0;33m'
        RED = '\033[0;31m'
        DIM = '\033[2m'
        NC = '\033[0m'

        parts = line.strip().split(" | ")
        if len(parts) < 3:
            return

        timestamp = parts[0].split("T")[1][:8] if "T" in parts[0] else parts[0]
        agent = parts[1]
        event = parts[2]
        data = " | ".join(parts[3:]) if len(parts) > 3 else ""

        # Color by event type
        if event in ("AGENT_STARTUP", "TEST_PASSED", "LINT_PASSED", "REQUEST_START"):
            color = GREEN
        elif event in ("AGENT_SHUTDOWN", "JOB_PR_READY"):
            color = YELLOW
        elif event in ("TEST_FAILED", "LINT_FAILED", "AGENT_ERROR"):
            color = RED
        elif event in ("REQUEST", "REQUEST_END"):
            color = DIM
        else:
            color = NC

        print(f"{DIM}{timestamp}{NC}  {color}{event:20}{NC}  {agent}  {data}")

    def run(self):
        """Main daemon loop"""
        log.info("swarm-daemon starting")
        log.info(f"Monitoring: {self.context.state_dir}")
        log.info(f"Session: {self.context.session_name}")
        log.info(f"Poll interval: {self.poll_interval}s")

        self.write_pid_file()
        self.event_logger.log_event("swarm-daemon", "STARTED", f"Poll interval: {self.poll_interval}s")

        # Foreground mode: live event tail
        foreground = self._is_foreground()
        if foreground:
            self._init_event_tail()
            # Print agent count status line
            agents = self.state_manager.get_all_agents()
            working = self.state_manager.get_working_agents()
            agent_details = ", ".join(
                f"{aid}: {self.state_manager.get_agent(aid).get('status', 'unknown')}"
                for aid in agents
            )
            if agent_details:
                log.info(f"Agents: {len(agents)} registered ({agent_details})")
            else:
                log.info("Agents: 0 registered")

        try:
            loop_count = 0
            last_event_time = time.time()
            while self.running:
                # Check for stale agents (every loop)
                self.check_for_stale_agents()

                # Foreground: drain new events
                if foreground:
                    n = self._drain_new_events()
                    if n > 0:
                        last_event_time = time.time()

                    # Heartbeat if no events for 30s
                    if time.time() - last_event_time >= 30 and foreground:
                        now_str = datetime.now().strftime("%H:%M:%S")
                        working_count = len(self.state_manager.get_working_agents())
                        print(f"\033[2m[{now_str}] -- no new events ({working_count} agent working) --\033[0m")
                        last_event_time = time.time()

                # Detect patterns (every 12 loops = ~1 minute)
                if loop_count % 12 == 0:
                    self.detect_patterns()

                loop_count += 1

                # Sleep
                time.sleep(self.poll_interval)

        finally:
            if foreground and hasattr(self, '_event_file'):
                self._event_file.close()
            self.remove_pid_file()
            log.info("swarm-daemon stopped")

# =============================================================================
# REPL MODE (Interactive Investigation)
# =============================================================================

class SwarmREPL:
    """Interactive REPL for investigating swarm state"""

    # ANSI colors
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[0;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    NC = '\033[0m'

    def __init__(self, context: SwarmContext):
        self.context = context
        self.state_manager = AgentStateManager(context)
        self.job_metrics = JobMetricsManager(context)
        self.event_logger = EventLogger(context)
        self.running = True

    def print_banner(self):
        """Print REPL banner"""
        working = len(self.state_manager.get_working_agents())
        idle = len(self.state_manager.get_idle_agents())
        total = len(self.state_manager.get_all_agents())

        print(f"{self.BOLD}{self.CYAN}swarm-daemon v1.0.0 - Interactive REPL{self.NC}")
        print(f"Connected to: {self.BOLD}{self.context.repo_name}{self.NC}")
        print(f"Agents: {total} total ({working} working, {idle} idle)")
        print()
        print(f"Type {self.BOLD}help{self.NC} for commands, {self.BOLD}quit{self.NC} to exit")
        print()

    def cmd_status(self, args):
        """Show system status"""
        agents = self.state_manager.get_all_agents()
        working = self.state_manager.get_working_agents()
        idle = self.state_manager.get_idle_agents()

        print(f"{self.BOLD}Swarm: {self.context.repo_name}{self.NC}")
        print(f"  Agents: {len(agents)} total ({len(working)} working, {len(idle)} idle)")
        print()

    def cmd_agents(self, args):
        """List all agents with status"""
        agents = self.state_manager.get_all_agents()

        if not agents:
            print(f"{self.DIM}No agents registered yet{self.NC}")
            return

        for agent_id, state in agents.items():
            status = state.get("status", "unknown")

            if status == "working":
                status_color = self.GREEN
                started = state.get("started_at", "")
                if started:
                    elapsed = self._format_elapsed(started)
                    status_display = f"{status_color}WORKING{self.NC}  {elapsed}"
                else:
                    status_display = f"{status_color}WORKING{self.NC}"
            else:
                status_color = self.DIM
                stopped = state.get("last_stopped", "")
                if stopped:
                    elapsed = self._format_elapsed(stopped)
                    status_display = f"{status_color}IDLE{self.NC}     {elapsed}"
                else:
                    status_display = f"{status_color}IDLE{self.NC}"

            print(f"{agent_id}  {status_display}")

    def cmd_log(self, args):
        """Show recent events"""
        # Parse arguments
        follow = "--follow" in args or "-f" in args
        agent_filter = None
        limit = 20

        # Parse --agent filter
        if "--agent" in args:
            idx = args.index("--agent")
            if idx + 1 < len(args):
                agent_filter = args[idx + 1]

        # Parse --tail limit
        if "--tail" in args:
            idx = args.index("--tail")
            if idx + 1 < len(args):
                try:
                    limit = int(args[idx + 1])
                except ValueError:
                    pass

        if follow:
            self._log_follow(agent_filter)
        else:
            events = self.event_logger.filter_events(agent_id=agent_filter, limit=limit)
            for event in events:
                self._print_event(event)

    def _log_follow(self, agent_filter: Optional[str]):
        """Follow events log (like tail -f)"""
        print(f"{self.DIM}Following events... (Ctrl-C to stop){self.NC}")

        # Get initial position
        if not self.context.events_log.exists():
            return

        with open(self.context.events_log) as f:
            # Seek to end
            f.seek(0, 2)

            try:
                while True:
                    line = f.readline()
                    if line:
                        if agent_filter:
                            if f" | {agent_filter} | " in line:
                                self._print_event(line)
                        else:
                            self._print_event(line)
                    else:
                        time.sleep(0.5)
            except KeyboardInterrupt:
                print()

    def _print_event(self, event_line: str):
        """Print formatted event line"""
        parts = event_line.strip().split(" | ")
        if len(parts) >= 3:
            timestamp = parts[0].split("T")[1][:8] if "T" in parts[0] else parts[0]
            agent = parts[1]
            event = parts[2]
            data = " | ".join(parts[3:]) if len(parts) > 3 else ""

            # Color by event type
            if "START" in event:
                event_color = self.GREEN
            elif "STOP" in event:
                event_color = self.YELLOW
            elif "HEARTBEAT" in event:
                event_color = self.DIM
            else:
                event_color = self.NC

            print(f"{self.DIM}{timestamp}{self.NC}  {event_color}{event:20}{self.NC}  {agent}  {data}")

    def cmd_work(self, args):
        """Show what each agent is currently working on (Phase 2)"""
        agents = self.state_manager.get_all_agents()
        active_jobs = self.job_metrics.get_active_jobs()

        if not agents:
            print(f"{self.DIM}No agents registered yet{self.NC}")
            return

        print(f"{self.BOLD}Current Work:{self.NC}")
        print()

        for agent_id, state in agents.items():
            status = state.get("status", "unknown")
            current_job = state.get("current_job")
            current_issue = state.get("current_issue")

            if current_job and current_job in active_jobs:
                job = active_jobs[current_job]
                job_state = job.get("state", "working")
                title = job.get("title", "")
                pr_number = job.get("pr_number")

                # Calculate elapsed time since claimed
                claimed_at = state.get("claimed_at", "")
                elapsed = self._format_elapsed(claimed_at) if claimed_at else ""

                # Format status
                if job_state == "pr_ready" and pr_number:
                    status_display = f"{self.YELLOW}pr_ready{self.NC}  (PR #{pr_number})"
                elif job_state == "working":
                    status_display = f"{self.GREEN}working{self.NC}  "
                else:
                    status_display = f"{self.CYAN}{job_state}{self.NC}  "

                print(f"{agent_id:12}  #{current_issue:<5}  {status_display}  {elapsed:6}  \"{title}\"")
            elif status == "working":
                # Working but no tracked job
                print(f"{agent_id:12}  {self.DIM}working (no tracked job){self.NC}")
            else:
                # Idle
                print(f"{agent_id:12}  {self.DIM}idle{self.NC}")

        print()

    def cmd_queue(self, args):
        """Show job queue status (Phase 2)"""
        # Parse subcommand
        subcommand = args[0] if args else "active"

        if subcommand == "pending":
            self._queue_pending()
        elif subcommand == "active":
            self._queue_active()
        elif subcommand == "done":
            self._queue_done()
        else:
            # Show overview
            active_jobs = self.job_metrics.get_active_jobs()
            completed = self.job_metrics.get_completed_jobs()

            # Count pending jobs from filesystem
            pending_path = self.context.state_dir / "jobs" / "pending"
            pending_count = len(list(pending_path.glob("*.yaml"))) if pending_path.exists() else 0

            print(f"{self.BOLD}Queue Overview:{self.NC}")
            print(f"  Pending: {pending_count}")
            print(f"  Active:  {len(active_jobs)}")
            print(f"  Done:    {len(completed)} (today)")
            print()
            print(f"Use: {self.BOLD}queue pending{self.NC}, {self.BOLD}queue active{self.NC}, {self.BOLD}queue done{self.NC}")
            print()

    def _queue_pending(self):
        """Show pending jobs from filesystem"""
        pending_path = self.context.state_dir / "jobs" / "pending"
        if not pending_path.exists():
            print(f"{self.DIM}No pending jobs{self.NC}")
            return

        pending_files = sorted(pending_path.glob("*.yaml"))
        if not pending_files:
            print(f"{self.DIM}No pending jobs{self.NC}")
            return

        print(f"{self.BOLD}Pending Jobs:{self.NC}")
        print()

        for job_file in pending_files:
            # Quick parse of YAML to get title
            try:
                with open(job_file) as f:
                    for line in f:
                        if line.startswith("id:"):
                            job_id = line.split(":", 1)[1].strip()
                        elif line.startswith("title:"):
                            title = line.split(":", 1)[1].strip().strip('"')
                            print(f"  {job_id}  \"{title}\"")
                            break
            except:
                pass

        print()

    def _queue_active(self):
        """Show active jobs"""
        active_jobs = self.job_metrics.get_active_jobs()

        if not active_jobs:
            print(f"{self.DIM}No active jobs{self.NC}")
            return

        print(f"{self.BOLD}Active Jobs:{self.NC}")
        print()

        for job_id, job in active_jobs.items():
            issue = job.get("issue")
            title = job.get("title", "")
            agent = job.get("agent", "unknown")
            state = job.get("state", "working")
            pr_number = job.get("pr_number")
            claimed_at = job.get("claimed_at", "")

            elapsed = self._format_elapsed(claimed_at) if claimed_at else ""

            if state == "pr_ready" and pr_number:
                status = f"{self.YELLOW}pr_ready{self.NC} (PR #{pr_number})"
            else:
                status = f"{self.GREEN}working{self.NC}"

            print(f"  {job_id}  {agent:12}  {elapsed:6}  {status}  #{issue} \"{title}\"")

        print()

    def _queue_done(self):
        """Show completed jobs"""
        completed = self.job_metrics.get_completed_jobs()

        if not completed:
            print(f"{self.DIM}No completed jobs today{self.NC}")
            return

        print(f"{self.BOLD}Completed Jobs (today):{self.NC}")
        print()

        for job in completed:
            job_id = job.get("job_id", "unknown")
            issue = job.get("issue")
            title = job.get("title", "")
            agent = job.get("agent", "unknown")
            pr_number = job.get("pr_number")
            total_time = job.get("total_time", "unknown")

            print(f"  {job_id}  {agent:12}  {total_time:8}  #{issue} \"{title}\" (PR #{pr_number})")

        print()

    def cmd_metrics(self, args):
        """Show performance metrics (Phase 2)"""
        completed = self.job_metrics.get_completed_jobs()

        if not completed:
            print(f"{self.DIM}No completed jobs today{self.NC}")
            return

        print(f"{self.BOLD}Metrics (today):{self.NC}")
        print()

        # Calculate averages
        time_to_pr_values = []
        time_to_merge_values = []
        total_time_values = []

        for job in completed:
            # Parse time strings like "42m" or "1h15m"
            if job.get("time_to_pr") and job["time_to_pr"] != "unknown":
                time_to_pr_values.append(self._parse_duration(job["time_to_pr"]))
            if job.get("time_to_merge") and job["time_to_merge"] != "unknown":
                time_to_merge_values.append(self._parse_duration(job["time_to_merge"]))
            if job.get("total_time") and job["total_time"] != "unknown":
                total_time_values.append(self._parse_duration(job["total_time"]))

        # Calculate averages
        avg_to_pr = sum(time_to_pr_values) // len(time_to_pr_values) if time_to_pr_values else 0
        avg_to_merge = sum(time_to_merge_values) // len(time_to_merge_values) if time_to_merge_values else 0
        avg_total = sum(total_time_values) // len(total_time_values) if total_time_values else 0

        print(f"  Completed: {len(completed)} jobs")
        print()
        if avg_to_pr > 0:
            print(f"  Avg time-to-PR:    {self._format_minutes(avg_to_pr)}")
        if avg_to_merge > 0:
            print(f"  Avg time-to-merge: {self._format_minutes(avg_to_merge)}")
        if avg_total > 0:
            print(f"  Avg total time:    {self._format_minutes(avg_total)}")
        print()

        # By agent breakdown
        agent_stats = {}
        for job in completed:
            agent = job.get("agent", "unknown")
            if agent not in agent_stats:
                agent_stats[agent] = {"count": 0, "jobs": []}
            agent_stats[agent]["count"] += 1
            agent_stats[agent]["jobs"].append(job)

        print(f"{self.BOLD}By Agent:{self.NC}")
        for agent, stats in sorted(agent_stats.items()):
            print(f"  {agent}: {stats['count']} completed")
        print()

    def _parse_duration(self, duration_str: str) -> int:
        """Parse duration string like '1h15m' or '42m' to minutes"""
        try:
            total_minutes = 0
            if 'h' in duration_str:
                parts = duration_str.split('h')
                total_minutes += int(parts[0]) * 60
                if 'm' in parts[1]:
                    total_minutes += int(parts[1].replace('m', ''))
            elif 'm' in duration_str:
                total_minutes = int(duration_str.replace('m', ''))
            return total_minutes
        except:
            return 0

    def _format_minutes(self, minutes: int) -> str:
        """Format minutes as '1h15m' or '42m'"""
        if minutes >= 60:
            hours = minutes // 60
            mins = minutes % 60
            return f"{hours}h{mins}m" if mins > 0 else f"{hours}h"
        else:
            return f"{minutes}m"

    # Phase 3B: Activity tracking commands
    def cmd_activity(self, args):
        """Show agent activity breakdown (Phase 3)"""
        # Parse agent filter
        agent_filter = args[0] if args else None

        if agent_filter:
            # Show specific agent activity
            agent = self.state_manager.get_agent(agent_filter)
            if not agent:
                print(f"{self.RED}Agent not found: {agent_filter}{self.NC}")
                return

            current_job_id = agent.get("current_job")
            if not current_job_id:
                print(f"{self.DIM}Agent {agent_filter} has no active job{self.NC}")
                return

            active_jobs = self.job_metrics.get_active_jobs()
            if current_job_id not in active_jobs:
                print(f"{self.DIM}Job {current_job_id} not found in active jobs{self.NC}")
                return

            job = active_jobs[current_job_id]
            print(f"{self.BOLD}Activity: {agent_filter}{self.NC}")
            print(f"Job: #{job.get('issue')} - {job.get('title')}")
            print()
            self._show_job_activity(job)
        else:
            # Show all agents
            agents = self.state_manager.get_all_agents()
            active_jobs = self.job_metrics.get_active_jobs()

            if not agents:
                print(f"{self.DIM}No agents registered{self.NC}")
                return

            print(f"{self.BOLD}Agent Activity:{self.NC}")
            print()

            for agent_id, state in agents.items():
                current_job_id = state.get("current_job")
                if current_job_id and current_job_id in active_jobs:
                    job = active_jobs[current_job_id]
                    print(f"{self.BOLD}{agent_id}{self.NC}")
                    self._show_job_activity(job)
                    print()

    def _show_job_activity(self, job: Dict):
        """Display activity breakdown for a job"""
        tasks_created = job.get("tasks_created", 0)
        tasks_completed = job.get("tasks_completed", 0)
        files_read = job.get("files_read", 0)
        files_edited = job.get("files_edited", 0)
        files_written = job.get("files_written", 0)
        lines_changed = job.get("lines_changed", 0)
        commits = job.get("commits", 0)
        test_runs = job.get("test_runs", 0)
        test_failures = job.get("test_failures", 0)
        bash_commands = job.get("bash_commands", 0)

        # Display counters
        if tasks_created > 0:
            print(f"  Tasks: {tasks_completed}/{tasks_created} completed")
        if files_read > 0 or files_edited > 0 or files_written > 0:
            print(f"  Files: {files_read} read, {files_edited} edited, {files_written} written")
        if lines_changed > 0:
            print(f"  Lines changed: {lines_changed}")
        if commits > 0:
            print(f"  Commits: {commits}")
        if test_runs > 0:
            status = f" ({test_failures} failed)" if test_failures > 0 else " (all passed)"
            print(f"  Test runs: {test_runs}{status}")
        if bash_commands > 0:
            print(f"  Bash commands: {bash_commands}")

        if all(v == 0 for v in [tasks_created, files_read, commits, test_runs]):
            print(f"  {self.DIM}No activity recorded yet{self.NC}")

    def cmd_timeline(self, args):
        """Show visual job timeline (Phase 3)"""
        if not args:
            print(f"{self.RED}Usage: timeline <job-id>{self.NC}")
            return

        job_id = args[0]

        # Get events for this job
        events = self.event_logger.filter_events(limit=1000)

        # Filter events related to this job
        job_events = []
        for event_line in events:
            if job_id in event_line:
                job_events.append(event_line)

        if not job_events:
            print(f"{self.DIM}No events found for job {job_id}{self.NC}")
            return

        print(f"{self.BOLD}Timeline: {job_id}{self.NC}")
        print()

        # Show simplified timeline
        for event_line in job_events:
            parts = event_line.strip().split(" | ")
            if len(parts) >= 3:
                timestamp = parts[0].split("T")[1][:8] if "T" in parts[0] else parts[0]
                event = parts[2]
                data = " | ".join(parts[3:]) if len(parts) > 3 else ""

                # Color by event type
                if "CLAIMED" in event or "START" in event:
                    event_color = self.GREEN
                elif "COMPLETE" in event or "PASSED" in event:
                    event_color = self.GREEN
                elif "FAILED" in event or "ERROR" in event:
                    event_color = self.RED
                elif "EDIT" in event or "WRITE" in event:
                    event_color = self.CYAN
                elif "PR" in event:
                    event_color = self.YELLOW
                else:
                    event_color = self.NC

                print(f"{self.DIM}{timestamp}{self.NC}  {event_color}{event:25}{self.NC}  {data}")

        print()

    # Phase 3C: Advanced analytics commands
    def cmd_bottlenecks(self, args):
        """Identify bottlenecks and slowdowns (Phase 3)"""
        print(f"{self.BOLD}Bottleneck Analysis:{self.NC}")
        print()

        # Check for stuck agents (no activity for > 15m)
        stuck_agents = []
        agents = self.state_manager.get_all_agents()
        threshold = datetime.now() - timedelta(minutes=15)

        for agent_id, state in agents.items():
            if state.get("status") == "working":
                last_heartbeat = state.get("last_heartbeat")
                if last_heartbeat:
                    try:
                        last_time = datetime.fromisoformat(last_heartbeat)
                        if last_time < threshold:
                            stuck_agents.append((agent_id, last_time))
                    except ValueError:
                        pass

        if stuck_agents:
            print(f"{self.RED}Stuck Agents:{self.NC}")
            for agent_id, last_time in stuck_agents:
                elapsed = datetime.now() - last_time
                minutes = int(elapsed.total_seconds() / 60)
                print(f"  {agent_id}: No activity for {minutes}m")
            print()
        else:
            print(f"{self.GREEN}✓ No stuck agents{self.NC}")
            print()

        # Check for repeated test failures
        active_jobs = self.job_metrics.get_active_jobs()
        high_failure_jobs = []

        for job_id, job in active_jobs.items():
            test_runs = job.get("test_runs", 0)
            test_failures = job.get("test_failures", 0)
            if test_runs > 0 and test_failures >= 2:
                high_failure_jobs.append((job_id, job, test_runs, test_failures))

        if high_failure_jobs:
            print(f"{self.YELLOW}High Test Failure Rate:{self.NC}")
            for job_id, job, runs, failures in high_failure_jobs:
                agent = job.get("agent", "unknown")
                issue = job.get("issue", "?")
                print(f"  {agent} (#{issue}): {failures}/{runs} test runs failed")
            print()
        else:
            print(f"{self.GREEN}✓ No excessive test failures{self.NC}")
            print()

        # Check for jobs with low activity
        low_activity_jobs = []
        for job_id, job in active_jobs.items():
            claimed_at = job.get("claimed_at")
            if claimed_at:
                try:
                    claimed_time = datetime.fromisoformat(claimed_at)
                    elapsed = datetime.now() - claimed_time
                    minutes_elapsed = int(elapsed.total_seconds() / 60)

                    # If job has been claimed for > 30m with minimal activity
                    if minutes_elapsed > 30:
                        total_activity = (
                            job.get("files_read", 0) +
                            job.get("files_edited", 0) +
                            job.get("commits", 0) +
                            job.get("test_runs", 0)
                        )
                        if total_activity < 3:
                            low_activity_jobs.append((job_id, job, minutes_elapsed))
                except ValueError:
                    pass

        if low_activity_jobs:
            print(f"{self.YELLOW}Low Activity Jobs:{self.NC}")
            for job_id, job, elapsed in low_activity_jobs:
                agent = job.get("agent", "unknown")
                issue = job.get("issue", "?")
                print(f"  {agent} (#{issue}): {elapsed}m with minimal activity")
            print()

    def cmd_compare(self, args):
        """Compare agent performance (Phase 3)"""
        completed = self.job_metrics.get_completed_jobs()

        if not completed:
            print(f"{self.DIM}No completed jobs to compare{self.NC}")
            return

        # Group by agent
        agent_stats = {}
        for job in completed:
            agent = job.get("agent", "unknown")
            if agent not in agent_stats:
                agent_stats[agent] = {
                    "jobs": 0,
                    "total_time_minutes": 0,
                    "test_runs": 0,
                    "successful": 0
                }

            agent_stats[agent]["jobs"] += 1

            # Parse total_time (e.g., "1h15m" or "42m")
            total_time = job.get("total_time", "unknown")
            if total_time != "unknown":
                minutes = self._parse_duration(total_time)
                agent_stats[agent]["total_time_minutes"] += minutes

            # Count test runs (from job metadata if available)
            # For now, assume successful completion
            agent_stats[agent]["successful"] += 1

        print(f"{self.BOLD}Agent Performance Comparison:{self.NC}")
        print()
        print(f"{'Agent':<15} {'Jobs':<6} {'Avg Time':<12} {'Success':<10}")
        print(f"{'-' * 15} {'-' * 6} {'-' * 12} {'-' * 10}")

        for agent, stats in sorted(agent_stats.items()):
            jobs = stats["jobs"]
            avg_time = stats["total_time_minutes"] // jobs if jobs > 0 else 0
            success_rate = f"{stats['successful']}/{jobs}" if jobs > 0 else "0/0"

            avg_time_str = self._format_minutes(avg_time) if avg_time > 0 else "-"

            print(f"{agent:<15} {jobs:<6} {avg_time_str:<12} {success_rate:<10}")

        print()

    def cmd_cleanup(self, args):
        """Remove stale agent entries"""
        # Parse arguments
        dry_run = "--dry-run" in args
        hours = 24  # Default threshold

        # Check for --hours argument
        if "--hours" in args:
            try:
                idx = args.index("--hours")
                if idx + 1 < len(args):
                    hours = int(args[idx + 1])
            except (ValueError, IndexError):
                print(f"{self.RED}Invalid --hours value{self.NC}")
                return

        state_manager = AgentStateManager(self.context)
        agents = state_manager.get_all_agents()

        if not agents:
            print("No agents to clean up")
            return

        now = datetime.now()
        threshold = timedelta(hours=hours)
        stale_agents = []

        for agent_id, data in agents.items():
            last_activity = None

            # Get most recent activity timestamp
            for field in ["last_stopped", "last_heartbeat", "started_at"]:
                if field in data and data[field]:
                    try:
                        last_activity = datetime.fromisoformat(data[field])
                        break
                    except:
                        continue

            if last_activity:
                age = now - last_activity
                if age > threshold:
                    stale_agents.append((agent_id, age))

        if not stale_agents:
            print(f"No stale agents found (threshold: {hours}h)")
            return

        # Show what will be/was cleaned
        print(f"{self.BOLD}Stale agents (inactive > {hours}h):{self.NC}")
        for agent_id, age in stale_agents:
            hours_ago = int(age.total_seconds() / 3600)
            print(f"  {agent_id:20s} (inactive {hours_ago}h)")

        if dry_run:
            print(f"\n{self.YELLOW}Dry run - no changes made{self.NC}")
            return

        # Remove stale agents
        for agent_id, _ in stale_agents:
            state_manager.remove_agent(agent_id)

        print(f"\n{self.GREEN}Removed {len(stale_agents)} stale agent(s){self.NC}")

    def cmd_help(self, args):
        """Show help"""
        print(f"{self.BOLD}Available commands:{self.NC}")
        print()
        print(f"  {self.BOLD}status{self.NC}              System overview")
        print(f"  {self.BOLD}agents{self.NC}              List all agents with status")
        print(f"  {self.BOLD}work{self.NC}                What is each agent working on? (Phase 2)")
        print(f"  {self.BOLD}queue{self.NC} [pending|active|done]  Job queue status (Phase 2)")
        print(f"  {self.BOLD}metrics{self.NC}             Performance statistics (Phase 2)")
        print(f"  {self.BOLD}activity{self.NC} [agent]    Activity breakdown (Phase 3)")
        print(f"  {self.BOLD}timeline{self.NC} <job-id>   Visual job progression (Phase 3)")
        print(f"  {self.BOLD}bottlenecks{self.NC}         Identify slowdowns and issues (Phase 3)")
        print(f"  {self.BOLD}compare{self.NC}             Agent performance comparison (Phase 3)")
        print(f"  {self.BOLD}cleanup{self.NC}             Remove stale agent entries")
        print(f"    --hours N         Inactivity threshold (default: 24)")
        print(f"    --dry-run         Preview without removing")
        print(f"  {self.BOLD}log{self.NC}                 Show recent events")
        print(f"    --tail N          Show last N events (default: 20)")
        print(f"    --agent <id>      Filter by agent")
        print(f"    --follow, -f      Follow events (live tail)")
        print(f"  {self.BOLD}help{self.NC}                Show this help")
        print(f"  {self.BOLD}quit{self.NC}, {self.BOLD}exit{self.NC}          Exit REPL")
        print()

    def _format_elapsed(self, timestamp_str: str) -> str:
        """Format elapsed time from ISO timestamp"""
        try:
            dt = datetime.fromisoformat(timestamp_str)
            elapsed = datetime.now() - dt

            minutes = int(elapsed.total_seconds() / 60)
            if minutes < 60:
                return f"{minutes}m"
            else:
                hours = minutes // 60
                mins = minutes % 60
                return f"{hours}h{mins}m"
        except:
            return ""

    def run(self):
        """Main REPL loop"""
        self.print_banner()

        while self.running:
            try:
                line = input(f"{self.BOLD}>{self.NC} ").strip()

                if not line:
                    continue

                parts = line.split()
                command = parts[0]
                args = parts[1:]

                if command in ("quit", "exit"):
                    break
                elif command == "status":
                    self.cmd_status(args)
                elif command == "agents":
                    self.cmd_agents(args)
                elif command == "work":
                    self.cmd_work(args)
                elif command == "queue":
                    self.cmd_queue(args)
                elif command == "metrics":
                    self.cmd_metrics(args)
                elif command == "activity":
                    self.cmd_activity(args)
                elif command == "timeline":
                    self.cmd_timeline(args)
                elif command == "bottlenecks":
                    self.cmd_bottlenecks(args)
                elif command == "compare":
                    self.cmd_compare(args)
                elif command == "cleanup":
                    self.cmd_cleanup(args)
                elif command == "log":
                    self.cmd_log(args)
                elif command == "help":
                    self.cmd_help(args)
                else:
                    print(f"{self.RED}Unknown command: {command}{self.NC}")
                    print(f"Type {self.BOLD}help{self.NC} for available commands")

            except KeyboardInterrupt:
                print()
                continue
            except EOFError:
                break

# =============================================================================
# CLI MODE (One-off Commands)
# =============================================================================

def run_cli_status(context: SwarmContext):
    """Quick status output"""
    state_manager = AgentStateManager(context)
    agents = state_manager.get_all_agents()
    working = state_manager.get_working_agents()
    idle = state_manager.get_idle_agents()

    print(f"Swarm: {context.repo_name}")
    print(f"  Agents: {len(agents)} total ({len(working)} working, {len(idle)} idle)")

def run_cli_agents(context: SwarmContext):
    """List agents"""
    state_manager = AgentStateManager(context)
    agents = state_manager.get_all_agents()

    if not agents:
        print("No agents registered yet")
        return

    for agent_id, state in agents.items():
        status = state.get("status", "unknown")
        print(f"{agent_id:12} {status:8}")

def run_cli_log(context: SwarmContext, args=None):
    """Show recent log with optional follow mode"""
    # Parse arguments (either passed in or from sys.argv for backward compat)
    if args is None:
        args = sys.argv[2:]  # Skip 'swarm-daemon' and 'log'

    follow = "--follow" in args or "-f" in args
    agent_filter = None
    limit = 20

    # Parse --agent filter
    if "--agent" in args:
        idx = args.index("--agent")
        if idx + 1 < len(args):
            agent_filter = args[idx + 1]

    # Parse --tail limit
    if "--tail" in args:
        idx = args.index("--tail")
        if idx + 1 < len(args):
            try:
                limit = int(args[idx + 1])
            except ValueError:
                pass

    event_logger = EventLogger(context)

    if follow:
        # Follow mode (like tail -f)
        print("\033[2mFollowing events... (Ctrl-C to stop)\033[0m")

        if not context.events_log.exists():
            return

        with open(context.events_log) as f:
            # Seek to end
            f.seek(0, 2)

            try:
                while True:
                    line = f.readline()
                    if line:
                        if agent_filter:
                            if f" | {agent_filter} | " in line:
                                print(line.rstrip())
                        else:
                            print(line.rstrip())
                    else:
                        time.sleep(0.5)
            except KeyboardInterrupt:
                print()
    else:
        # Normal mode - show recent events
        events = event_logger.filter_events(agent_id=agent_filter, limit=limit)
        for event in events:
            print(event.rstrip())

def run_cli_cleanup(context: SwarmContext, args=None):
    """Remove stale agent entries"""
    # Parse arguments (either passed in or from sys.argv for backward compat)
    if args is None:
        args = sys.argv[2:]  # Skip 'swarm-daemon' and 'cleanup'
    dry_run = "--dry-run" in args
    hours = 24  # Default threshold

    # Check for --hours argument
    if "--hours" in args:
        try:
            idx = args.index("--hours")
            if idx + 1 < len(args):
                hours = int(args[idx + 1])
        except (ValueError, IndexError):
            print("Error: Invalid --hours value", file=sys.stderr)
            sys.exit(1)

    state_manager = AgentStateManager(context)
    agents = state_manager.get_all_agents()

    if not agents:
        print("No agents to clean up")
        return

    now = datetime.now()
    threshold = timedelta(hours=hours)
    stale_agents = []

    for agent_id, data in agents.items():
        last_activity = None

        # Get most recent activity timestamp
        for field in ["last_stopped", "last_heartbeat", "started_at"]:
            if field in data and data[field]:
                try:
                    last_activity = datetime.fromisoformat(data[field])
                    break
                except:
                    continue

        if last_activity:
            age = now - last_activity
            if age > threshold:
                stale_agents.append((agent_id, age))

    if not stale_agents:
        print(f"No stale agents found (threshold: {hours}h)")
        return

    # Show what will be/was cleaned
    print(f"Stale agents (inactive > {hours}h):")
    for agent_id, age in stale_agents:
        hours_ago = int(age.total_seconds() / 3600)
        print(f"  {agent_id:20s} (inactive {hours_ago}h)")

    if dry_run:
        print("\nDry run - no changes made")
        return

    # Remove stale agents
    for agent_id, _ in stale_agents:
        state_manager.remove_agent(agent_id)

    print(f"\nRemoved {len(stale_agents)} stale agent(s)")

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

def print_usage():
    print(__doc__)
    print("\nCommands:")
    print("  daemon              Run in background (monitoring mode)")
    print("  repl                Interactive investigation shell")
    print("  status              Quick status overview")
    print("  agents              List agent status")
    print("  cleanup             Remove stale agent entries")
    print("                      Options: --hours N (default: 24), --dry-run")
    print("  log                 Show recent events")
    print("                      Options: -f/--follow, --agent <id>, --tail <N>")
    print("  hook <EVENT> [...]  Record event (called by agents)")
    print()
    print("Options:")
    print("  -h, --help          Show this help")
    print("  --context <repo>    Specify context (repo name) instead of auto-detect")
    print("                      Useful for running daemon outside git repo")
    print()
    print("Environment:")
    print("  POLL_INTERVAL       Polling interval in seconds (default: 5)")
    print("  AGENT_ID            Agent identifier (for hook calls)")
    print("  AGENT_CONTEXT       Context (repo name) for this agent")

def main():
    global log

    if len(sys.argv) < 2:
        print_usage()
        sys.exit(0)

    # Known commands for flexible parsing
    known_commands = ["daemon", "repl", "status", "agents", "cleanup", "log", "hook"]

    # Parse arguments flexibly (flags can appear anywhere)
    context_override = None
    command = None
    command_args = []
    i = 1

    while i < len(sys.argv):
        arg = sys.argv[i]

        if arg == "--context":
            if i + 1 < len(sys.argv):
                context_override = sys.argv[i + 1]
                i += 2  # Skip both --context and its value
            else:
                print("Error: --context requires a repository name", file=sys.stderr)
                sys.exit(1)
        elif arg in ("-h", "--help"):
            print_usage()
            sys.exit(0)
        elif command is None and arg in known_commands:
            # First known command we encounter is THE command
            command = arg
            i += 1
        else:
            # Everything else (flags, args) goes to the command
            command_args.append(arg)
            i += 1

    # Check if we found a command
    if not command:
        print_usage()
        sys.exit(0)

    # Initialize context
    context = SwarmContext(context_override=context_override)

    # Route to appropriate mode
    if command == "daemon":
        log = setup_logging(daemon_mode=True, context=context)
        daemon = SwarmDaemon(context)
        daemon.run()

    elif command == "repl":
        log = setup_logging(daemon_mode=False, context=context)
        repl = SwarmREPL(context)
        repl.run()

    elif command == "status":
        log = setup_logging(daemon_mode=False, context=context)
        run_cli_status(context)

    elif command == "agents":
        log = setup_logging(daemon_mode=False, context=context)
        run_cli_agents(context)

    elif command == "cleanup":
        log = setup_logging(daemon_mode=False, context=context)
        run_cli_cleanup(context, command_args)

    elif command == "log":
        log = setup_logging(daemon_mode=False, context=context)
        run_cli_log(context, command_args)

    elif command == "hook":
        # Hook mode - MUST BE FAST
        log = setup_logging(daemon_mode=True, context=context)
        if len(command_args) < 1:
            print("Usage: swarm-daemon hook <EVENT_TYPE> [args...]", file=sys.stderr)
            sys.exit(1)

        event_type = command_args[0]
        args = command_args[1:]
        handle_hook(context, event_type, args)

    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print_usage()
        sys.exit(1)

if __name__ == "__main__":
    main()
