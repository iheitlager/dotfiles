#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "rich>=13.0.0",
#   "pyyaml>=6.0",
#   "jsonschema>=4.0.0",
# ]
# ///
#
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0
#
# arch - Grounded C4 Architecture Modeling Tool
#
# A tool for modeling, validating, and visualizing software architecture
# using the Grounded C4 approach (concrete resources, progressive zoom,
# behavioral modeling with sequences and state machines).
#
# Part of the OpenSpec system for specification-driven development.

"""
Grounded C4 Architecture Modeling Tool

Commands:
    arch              Interactive fzf browser (default)
    arch init         Initialize architecture directory structure
    arch list         List all resources
    arch landscape    Show system landscape view
    arch validate     Validate architecture model
    arch diagram      Generate diagrams
    arch coverage     Check architecture coverage
    arch reverse-engineer  Extract architecture from code
    arch deps         Show dependencies
    arch impact       Analyze impact of changes
    arch adr          Show related ADRs
"""

import sys
import os
import argparse
from pathlib import Path

# Add local/lib to path for importing arch modules
SCRIPT_DIR = Path(__file__).parent
LIB_DIR = SCRIPT_DIR.parent / "lib"
if str(LIB_DIR) not in sys.path:
    sys.path.insert(0, str(LIB_DIR))

VERSION = "0.1.0"


def find_architecture_dir(start_path=None):
    """
    Find the architecture directory (.openspec/architecture).

    Search order:
    1. Explicit start path (if provided)
    2. Git repository root (if inside a git repo)
    3. Current directory and parents (walk up)

    Returns:
        Path to .openspec/architecture directory, or None if not found
    """
    if start_path:
        arch_dir = Path(start_path) / ".openspec" / "architecture"
        if arch_dir.exists():
            return arch_dir
        return None

    # Try git root
    try:
        import subprocess
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=False
        )
        if result.returncode == 0:
            git_root = Path(result.stdout.strip())
            arch_dir = git_root / ".openspec" / "architecture"
            if arch_dir.exists():
                return arch_dir
    except Exception:
        pass

    # Walk up directory tree
    current = Path.cwd()
    while current != current.parent:
        arch_dir = current / ".openspec" / "architecture"
        if arch_dir.exists():
            return arch_dir
        current = current.parent

    return None


def cmd_list(args):
    """List all resources in the architecture model."""
    arch_dir = find_architecture_dir(args.root)

    if not arch_dir:
        print("âŒ Error: No architecture directory found", file=sys.stderr)
        print("   Searched for: .openspec/architecture", file=sys.stderr)
        if args.root:
            print(f"   In: {args.root}", file=sys.stderr)
        else:
            print(f"   From: {Path.cwd()} (git root or walking up)", file=sys.stderr)
        return 1

    try:
        from arch.loader import load_architecture, LoadError
        from arch.path_resolver import PathResolver
        from arch.commands.list import render_list

        # Load model
        model = load_architecture(arch_dir)

        # Build path resolver
        resolver = PathResolver(model)

        # Render tree structure
        render_list(
            model,
            resolver,
            resource_type=getattr(args, 'type', None),
            tag=getattr(args, 'tag', None),
            query=getattr(args, 'query', None),
            protocol=getattr(args, 'protocol', None),
        )

        return 0

    except LoadError as e:
        print(f"\nâŒ Load error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"\nâŒ Unexpected error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def cmd_validate(args):
    """Validate architecture model for schema and referential integrity."""
    arch_dir = find_architecture_dir(args.root)

    if not arch_dir:
        print("âŒ Error: No architecture directory found", file=sys.stderr)
        return 1

    try:
        from arch.loader import load_architecture, LoadError
        from arch.validator import ArchitectureValidator
        from arch.commands.validate import render_validate
        from rich.console import Console

        console = Console()

        # Load model (includes schema validation)
        console.print(f"ðŸ“¦ Loading architecture from: {arch_dir}")
        model = load_architecture(arch_dir, validate_schema=True)

        console.print(f"âœ… Schema validation passed\n")

        # Run referential integrity validation
        console.print("ðŸ” Checking referential integrity...")
        validator = ArchitectureValidator(model)
        result = validator.validate()

        # Render results and get exit code
        return render_validate(model, result)

    except LoadError as e:
        print(f"\nâŒ Load error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"\nâŒ Unexpected error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def cmd_diagram(args):
    """Generate diagrams from architecture model."""
    arch_dir = find_architecture_dir(args.root)

    if not arch_dir:
        print("âŒ Error: No architecture directory found", file=sys.stderr)
        return 1

    try:
        from arch.loader import load_architecture, LoadError
        from arch.path_resolver import PathResolver
        from arch.commands.diagram import render_diagram

        # Load model
        model = load_architecture(arch_dir)
        resolver = PathResolver(model)

        # Generate diagram
        return render_diagram(
            model,
            resolver,
            format=args.format,
            zoom=args.zoom,
            output=args.output,
            preview=args.preview,
        )

    except LoadError as e:
        print(f"\nâŒ Load error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"\nâŒ Unexpected error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def cmd_coverage(args):
    """Check architecture coverage against codebase."""
    arch_dir = find_architecture_dir(args.root)

    if not arch_dir:
        print("âŒ Error: No architecture directory found", file=sys.stderr)
        return 1

    print(f"ðŸ“¦ Checking coverage: {arch_dir}")
    if args.source:
        print(f"   Source: {args.source}")
    print("\nâš ï¸  Not yet implemented")
    print("   This command will:")
    print("   - Scan codebase for resources (scripts, configs, services)")
    print("   - Compare against architecture model")
    print("   - Report: documented, undocumented, orphaned")
    return 0


def cmd_reverse_engineer(args):
    """Extract architecture from existing codebase."""
    from arch.commands.reverse_engineer import run_reverse_engineer

    # Determine source directory
    source = Path(args.source) if args.source else Path.cwd()

    # Determine output path
    output = None
    if args.output:
        output = Path(args.output)
    else:
        # Default: save to architecture directory if it exists
        arch_dir = find_architecture_dir(args.root)
        if arch_dir:
            output = arch_dir / "extracted.yaml"

    # Run reverse engineering
    return run_reverse_engineer(
        source=source,
        output=output,
        interactive=args.interactive if hasattr(args, 'interactive') else False,
        recursive=True
    )


def cmd_init(args):
    """Initialize architecture directory structure."""
    cwd = Path.cwd()

    # Step 1: Determine OpenSpec directory
    # Check for openspec/ (no dot)
    if (cwd / "openspec").exists():
        openspec_dir = cwd / "openspec"
        print(f"âœ… Found existing: openspec/")
    # Check for .openspec/ (with dot)
    elif (cwd / ".openspec").exists():
        openspec_dir = cwd / ".openspec"
        print(f"âœ… Found existing: .openspec/")
    # Create .openspec/ (default)
    else:
        openspec_dir = cwd / ".openspec"
        openspec_dir.mkdir(exist_ok=True)
        print(f"ðŸ“ Created: .openspec/")

    # Step 2: Check if architecture already exists
    arch_dir = openspec_dir / "architecture"
    if arch_dir.exists():
        print(f"âŒ Error: {arch_dir.relative_to(cwd)} already exists")
        return 1

    # Step 3: Create architecture structure
    print(f"ðŸ“¦ Initializing architecture in: {arch_dir.relative_to(cwd)}/")
    arch_dir.mkdir()

    # Create subdirectories
    (arch_dir / "resources").mkdir()
    (arch_dir / "sequences").mkdir()
    (arch_dir / "state-machines").mkdir()
    (arch_dir / "decisions").mkdir()

    # Create template landscape.yaml
    landscape_template = """# System Landscape
# Top-level view of your system and its external dependencies

landscape:
  id: my-system
  name: My System
  description: |
    Brief description of your system

resources:
  # Define your top-level systems and external dependencies here
  # Example:
  # - id: main-app
  #   name: Main Application
  #   type: system
  #   abstract: true
  #   children: []

relationships: []
"""

    (arch_dir / "landscape.yaml").write_text(landscape_template)

    # Create .gitkeep files
    for subdir in ["resources", "sequences", "state-machines", "decisions"]:
        (arch_dir / subdir / ".gitkeep").touch()

    print("\nâœ… Architecture initialized!")
    print(f"\nNext steps:")
    print(f"  1. Edit {arch_dir.relative_to(cwd)}/landscape.yaml")
    print(f"  2. Add resources to {arch_dir.relative_to(cwd)}/resources/")
    print(f"  3. Run: arch validate")
    print(f"\nSee: docs/grounded-c4.md for modeling guide")

    return 0


def cmd_browse(args):
    """Interactive fzf browser for architecture."""
    arch_dir = find_architecture_dir(args.root)

    if not arch_dir:
        print("âŒ Error: No architecture directory found", file=sys.stderr)
        print("   Searched for: .openspec/architecture", file=sys.stderr)
        if args.root:
            print(f"   In: {args.root}", file=sys.stderr)
        else:
            print(f"   From: {Path.cwd()} (git root or walking up)", file=sys.stderr)
        return 1

    try:
        from arch.loader import load_architecture, LoadError
        from arch.path_resolver import PathResolver
        from arch.commands.browse import render_browser

        model = load_architecture(arch_dir)
        resolver = PathResolver(model)

        return render_browser(model, resolver)

    except LoadError as e:
        print(f"âŒ Load Error: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"âŒ Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="Grounded C4 Architecture Modeling Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  arch init               Initialize architecture directory
  arch                    Interactive browser
  arch list               List all resources
  arch validate           Validate architecture model
  arch diagram --zoom=landscape --format=mermaid
  arch coverage --source=script/
  arch reverse-engineer --source=script/ --output=architecture/

For more information, see:
  - Design doc: docs/grounded-c4.md
  - Specification: .openspec/specs/008-grounded-c4-architecture/spec.md
  - Proposal: .openspec/changes/grounded-c4-architecture/proposal.md
        """
    )

    parser.add_argument(
        "--version",
        action="version",
        version=f"arch {VERSION}"
    )

    parser.add_argument(
        "-r", "--root",
        help="Explicit root directory to search for .openspec/architecture"
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # init command
    parser_init = subparsers.add_parser("init", help="Initialize architecture directory structure")

    # list command
    parser_list = subparsers.add_parser("list", help="List all resources")
    parser_list.add_argument(
        "--type",
        help="Filter by resource type (e.g., go-service, bash-script)"
    )
    parser_list.add_argument(
        "--tag",
        help="Filter by tag"
    )
    parser_list.add_argument(
        "--query",
        help="Search by name or description"
    )
    parser_list.add_argument(
        "--protocol",
        help="Filter interfaces by protocol (e.g., https, kafka)"
    )

    # validate command
    parser_validate = subparsers.add_parser("validate", help="Validate architecture model")

    # browse command
    parser_browse = subparsers.add_parser("browse", help="Interactive fzf browser for architecture")

    # diagram command
    parser_diagram = subparsers.add_parser("diagram", help="Generate diagrams")
    parser_diagram.add_argument(
        "--format",
        choices=["mermaid", "plantuml"],
        default="mermaid",
        help="Diagram format (default: mermaid)"
    )
    parser_diagram.add_argument(
        "--zoom",
        choices=["landscape", "domain", "service", "interface"],
        default="landscape",
        help="Zoom level (default: landscape)"
    )
    parser_diagram.add_argument(
        "--output",
        help="Output file path (default: stdout)"
    )
    parser_diagram.add_argument(
        "--preview",
        action="store_true",
        help="Preview in terminal with glow/bat"
    )

    # coverage command
    parser_coverage = subparsers.add_parser("coverage", help="Check architecture coverage")
    parser_coverage.add_argument(
        "--source",
        help="Source directory to scan (default: current directory)"
    )
    parser_coverage.add_argument(
        "--format",
        choices=["table", "json"],
        default="table",
        help="Output format (default: table)"
    )

    # reverse-engineer command
    parser_reverse = subparsers.add_parser(
        "reverse-engineer",
        help="Extract architecture from code"
    )
    parser_reverse.add_argument(
        "--source",
        help="Source directory to analyze"
    )
    parser_reverse.add_argument(
        "--format",
        choices=["bash", "docker-compose", "kubernetes"],
        help="Source format hint"
    )
    parser_reverse.add_argument(
        "--output",
        help="Output directory for generated YAML (default: .openspec/architecture/)"
    )
    parser_reverse.add_argument(
        "--interactive",
        action="store_true",
        help="Confirm before writing files"
    )

    # Parse arguments
    args = parser.parse_args()

    # Default to browse if no command specified
    if not args.command:
        args.command = "browse"

    # Route to command handlers
    if args.command == "init":
        return cmd_init(args)
    elif args.command == "list":
        return cmd_list(args)
    elif args.command == "validate":
        return cmd_validate(args)
    elif args.command == "diagram":
        return cmd_diagram(args)
    elif args.command == "coverage":
        return cmd_coverage(args)
    elif args.command == "reverse-engineer":
        return cmd_reverse_engineer(args)
    elif args.command == "browse":
        return cmd_browse(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    # Special handler for __preview__ command (called by fzf preview script)
    if len(sys.argv) >= 4 and sys.argv[1] == "__preview__":
        entry_type = sys.argv[2]
        full_path = sys.argv[3]

        # Find architecture directory
        arch_dir = find_architecture_dir()
        if not arch_dir:
            print("Error: No architecture directory found", file=sys.stderr)
            sys.exit(1)

        try:
            from arch.loader import load_architecture
            from arch.path_resolver import PathResolver
            from arch.commands.browse import render_preview

            model = load_architecture(arch_dir)
            resolver = PathResolver(model)
            render_preview(entry_type, full_path, model, resolver)
            sys.exit(0)
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)

    # Normal command handling
    sys.exit(main())
