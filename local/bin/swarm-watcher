#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

# swarm-watcher - Job queue monitor daemon for agent swarm
# Version: 2.0.0
#
# Monitors job queue and broadcasts notifications to agents:
# - New jobs: notifies capable agents
# - Claimed jobs: logs pickup
# - Completed jobs: broadcasts to all, checks unblocked
# Ctrl-C triggers graceful swarm shutdown.

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Poll interval in seconds
POLL_INTERVAL="${POLL_INTERVAL:-5}"

# Get project context
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo -e "${RED}Error: Not in a git repository${NC}" >&2
    exit 1
}

# Handle worktree paths
local_repo_name=$(basename "$REPO_ROOT")
local_repo_parent=$(dirname "$REPO_ROOT")

if [[ "$local_repo_parent" =~ ^(.+)-worktree$ ]]; then
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
elif [[ "$local_repo_name" =~ ^(.+)-worktree$ ]]; then
    REPO_NAME=$(basename "${BASH_REMATCH[1]}")
else
    REPO_NAME="$local_repo_name"
fi

# Sanitize session name: tmux doesn't allow dots
SESSION="claude-${REPO_NAME//[.]/_}"
SHARED_CONTEXT="$HOME/.local/state/agent-context/$REPO_NAME"
PENDING_DIR="$SHARED_CONTEXT/jobs/pending"
ACTIVE_DIR="$SHARED_CONTEXT/jobs/active"
DONE_DIR="$SHARED_CONTEXT/jobs/done"
EVENTS_LOG="$SHARED_CONTEXT/events.log"

# Track seen jobs to avoid duplicate notifications
declare -A SEEN_JOBS
declare -A ACTIVE_JOBS
declare -A DONE_JOBS

# Model capability tiers
get_model_tier() {
    case "$1" in
        opus)       echo 3 ;;
        sonnet)     echo 2 ;;
        haiku)      echo 1 ;;
        5.1-codex)  echo 2 ;;
        gemini-pro) echo 2 ;;
        *)          echo 2 ;;
    esac
}

# Extract field from YAML
yaml_get() {
    local file="$1"
    local field="$2"
    grep "^${field}:" "$file" 2>/dev/null | sed "s/^${field}:[[:space:]]*//" | tr -d '"'
}

# Get job's required tier
get_job_tier() {
    local job_file="$1"
    local recommended=$(yaml_get "$job_file" "recommended_model")
    local complexity=$(yaml_get "$job_file" "complexity")

    if [[ -n "$recommended" ]]; then
        get_model_tier "$recommended"
    else
        case "$complexity" in
            complex)  echo 3 ;;
            moderate) echo 2 ;;
            simple)   echo 1 ;;
            *)        echo 2 ;;
        esac
    fi
}

# Get agents capable of handling a task
get_capable_agents() {
    local task_tier="$1"
    local capable=""

    # Check each agent pane in tmux
    local pane_count=$(tmux list-panes -t "$SESSION:agents" 2>/dev/null | wc -l | tr -d ' ')

    for i in $(seq 1 $pane_count); do
        # Get agent's model from environment (captured during setup)
        local agent_model=$(tmux show-environment -t "$SESSION" "AGENT_${i}_MODEL" 2>/dev/null | cut -d= -f2)

        # Fallback: infer from agent count and position
        if [[ -z "$agent_model" ]]; then
            case $pane_count in
                2) agent_model="opus" ;;
                3) [[ $i -eq 1 ]] && agent_model="opus" || agent_model="sonnet" ;;
                4)
                    case $i in
                        1|2) agent_model="opus" ;;
                        3)   agent_model="sonnet" ;;
                        4)   agent_model="haiku" ;;
                    esac
                    ;;
                6)
                    case $i in
                        1|2) agent_model="opus" ;;
                        3|4) agent_model="sonnet" ;;
                        5)   agent_model="5.1-codex" ;;
                        6)   agent_model="gemini-pro" ;;
                    esac
                    ;;
            esac
        fi

        local agent_tier=$(get_model_tier "$agent_model")

        # Agent can handle task if their tier >= task tier
        if [[ $agent_tier -ge $task_tier ]]; then
            capable="$capable $i"
        fi
    done

    echo $capable
}

# Notify specific agents about a new job
notify_agents() {
    local job_id="$1"
    local job_file="$2"
    local agents="$3"

    local title=$(yaml_get "$job_file" "title")
    local priority=$(yaml_get "$job_file" "priority")

    for agent in $agents; do
        # Send notification to agent via tmux
        # Use Escape first in case agent is idle, then message
        tmux send-keys -t "$SESSION:agents.$agent" Escape 2>/dev/null || true
        sleep 0.1
        tmux send-keys -t "$SESSION:agents.$agent" \
            "New job available: $job_id [$priority] - $title. Run: swarm-job claim $job_id" Enter 2>/dev/null || true
        tmux send-keys -t "$SESSION:agents.$agent" Enter 2>/dev/null || true
    done
}

# Broadcast message to ALL agents (pub/sub style)
broadcast_all() {
    local message="$1"

    local pane_count=$(tmux list-panes -t "$SESSION:agents" 2>/dev/null | wc -l | tr -d ' ')

    for i in $(seq 1 $pane_count); do
        tmux send-keys -t "$SESSION:agents.$i" Escape 2>/dev/null || true
        sleep 0.05
        tmux send-keys -t "$SESSION:agents.$i" "$message" Enter 2>/dev/null || true
        tmux send-keys -t "$SESSION:agents.$i" Enter 2>/dev/null || true
    done
}

# Log message with timestamp
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%H:%M:%S')

    case "$level" in
        INFO)    echo -e "${DIM}[$timestamp]${NC} ${CYAN}INFO${NC}    $message" ;;
        TASK)    echo -e "${DIM}[$timestamp]${NC} ${GREEN}TASK${NC}    $message" ;;
        CLAIMED) echo -e "${DIM}[$timestamp]${NC} ${YELLOW}CLAIMED${NC} $message" ;;
        DONE)    echo -e "${DIM}[$timestamp]${NC} ${GREEN}DONE${NC}    $message" ;;
        UNBLOCK) echo -e "${DIM}[$timestamp]${NC} ${CYAN}UNBLOCK${NC} $message" ;;
        NOTIFY)  echo -e "${DIM}[$timestamp]${NC} ${BLUE}NOTIFY${NC}  $message" ;;
        WARN)    echo -e "${DIM}[$timestamp]${NC} ${YELLOW}WARN${NC}    $message" ;;
        ERROR)   echo -e "${DIM}[$timestamp]${NC} ${RED}ERROR${NC}   $message" ;;
    esac
}

# Log to events.log
log_event() {
    local action="$1"
    local job_id="$2"
    local summary="$3"
    local timestamp=$(date -Iseconds)

    echo "$timestamp | job-watcher | $action | $job_id | $summary" >> "$EVENTS_LOG"
}

# Graceful shutdown handler
shutdown_handler() {
    echo ""
    log INFO "Shutdown requested - stopping swarm..."
    log_event "SHUTDOWN" "-" "Job watcher initiated swarm shutdown"

    # Give a moment for the log to be written
    sleep 0.5

    # Trigger swarm shutdown
    exec launch-agents --force stop
}

# Set up signal handler
trap shutdown_handler SIGINT SIGTERM

# Check a single job
check_job() {
    local job_file="$1"
    local job_id=$(basename "$job_file" .yaml)

    # Skip if already seen
    if [[ -n "${SEEN_JOBS[$job_id]}" ]]; then
        return
    fi

    # Mark as seen
    SEEN_JOBS[$job_id]=1

    local title=$(yaml_get "$job_file" "title")
    local priority=$(yaml_get "$job_file" "priority")
    local complexity=$(yaml_get "$job_file" "complexity")
    local job_tier=$(get_job_tier "$job_file")

    log TASK "New: ${BOLD}$job_id${NC} [$priority/$complexity] $title"
    log_event "DETECTED" "$job_id" "$title"

    # Find capable agents
    local capable=$(get_capable_agents $job_tier)

    if [[ -n "$capable" ]]; then
        local agent_list=$(echo $capable | tr ' ' ',')
        log NOTIFY "Notifying agents:$capable (tier >= $job_tier)"
        notify_agents "$job_id" "$job_file" "$capable"
        log_event "NOTIFIED" "$job_id" "Agents: $agent_list"
    else
        log WARN "No capable agents for tier $job_tier job"
    fi
}

# Check for newly claimed (active) jobs
check_claimed_job() {
    local job_file="$1"
    local job_id=$(basename "$job_file" .yaml)

    # Skip if already seen as active
    if [[ -n "${ACTIVE_JOBS[$job_id]}" ]]; then
        return
    fi

    # Mark as seen
    ACTIVE_JOBS[$job_id]=1

    local title=$(yaml_get "$job_file" "title")
    local claimed_by=$(yaml_get "$job_file" "claimed_by")

    log CLAIMED "${BOLD}$job_id${NC} picked up by ${BOLD}$claimed_by${NC}"
    log_event "PICKED_UP" "$job_id" "Agent: $claimed_by - $title"
}

# Check for newly completed jobs
check_completed_job() {
    local job_file="$1"
    local job_id=$(basename "$job_file" .yaml)

    # Skip if already seen as done
    if [[ -n "${DONE_JOBS[$job_id]}" ]]; then
        return
    fi

    # Mark as seen
    DONE_JOBS[$job_id]=1

    local title=$(yaml_get "$job_file" "title")
    local claimed_by=$(yaml_get "$job_file" "claimed_by")
    local result=$(yaml_get "$job_file" "result")

    log DONE "${BOLD}$job_id${NC} completed by ${BOLD}${claimed_by:-unknown}${NC} [${result:-success}]"
    log_event "COMPLETED_SEEN" "$job_id" "By: $claimed_by - $title"

    # Broadcast completion to all agents
    broadcast_all "[swarm] Job completed: $job_id by ${claimed_by:-unknown}. Check queue: swarm-job list pending"

    # Check for jobs that might be unblocked
    check_unblocked_jobs "$job_id"
}

# Check if a job's dependencies are all resolved
job_is_unblocked() {
    local job_file="$1"

    # Get depends_on list (simple parsing)
    local depends=$(grep -A 100 "^depends_on:" "$job_file" 2>/dev/null | grep "^  - " | sed 's/^  - //')

    if [[ -z "$depends" ]]; then
        return 0  # No dependencies = unblocked
    fi

    # Check each dependency
    for dep_id in $depends; do
        # Dependency resolved if it's in done
        if [[ ! -f "$DONE_DIR/${dep_id}.yaml" ]]; then
            return 1  # Still blocked
        fi
    done

    return 0  # All dependencies resolved
}

# Check for jobs unblocked by a completion
check_unblocked_jobs() {
    local completed_id="$1"

    # Scan pending jobs for ones that depend on the completed job
    for job_file in "$PENDING_DIR"/*.yaml; do
        [[ -f "$job_file" ]] || continue

        local job_id=$(basename "$job_file" .yaml)

        # Check if this job depends on the completed one
        if grep -q "  - $completed_id" "$job_file" 2>/dev/null; then
            # Check if ALL dependencies are now resolved
            if job_is_unblocked "$job_file"; then
                local title=$(yaml_get "$job_file" "title")
                local job_tier=$(get_job_tier "$job_file")

                log UNBLOCK "${BOLD}$job_id${NC} is now unblocked: $title"
                log_event "UNBLOCKED" "$job_id" "Unblocked by $completed_id - $title"

                # Notify capable agents
                local capable=$(get_capable_agents $job_tier)
                if [[ -n "$capable" ]]; then
                    local agent_list=$(echo $capable | tr ' ' ',')
                    log NOTIFY "Notifying agents:$capable about unblocked job"
                    notify_agents "$job_id" "$job_file" "$capable"
                fi
            fi
        fi
    done
}

# Main watch loop
watch_loop() {
    log INFO "Watching: $PENDING_DIR"
    log INFO "Session: $SESSION"
    log INFO "Poll interval: ${POLL_INTERVAL}s"
    log INFO "Press Ctrl-C to stop swarm"
    echo ""

    # Initial scan - mark existing jobs as seen (don't notify)
    shopt -s nullglob
    for job_file in "$PENDING_DIR"/*.yaml; do
        [[ -f "$job_file" ]] || continue
        local job_id=$(basename "$job_file" .yaml)
        SEEN_JOBS[$job_id]=1
        log INFO "Existing job: $job_id"
    done
    shopt -u nullglob

    # Initial scan of active jobs - mark as seen (don't notify)
    if [[ -d "$ACTIVE_DIR" ]]; then
        for job_file in "$ACTIVE_DIR"/*.yaml; do
            [[ -f "$job_file" ]] || continue
            local job_id=$(basename "$job_file" .yaml)
            ACTIVE_JOBS[$job_id]=1
            local claimed_by=$(yaml_get "$job_file" "claimed_by")
            log INFO "Active job: $job_id (${claimed_by:-unknown})"
        done
    fi

    # Initial scan of done jobs - mark as seen (don't notify)
    if [[ -d "$DONE_DIR" ]]; then
        local done_count=0
        for job_file in "$DONE_DIR"/*.yaml; do
            [[ -f "$job_file" ]] || continue
            local job_id=$(basename "$job_file" .yaml)
            DONE_JOBS[$job_id]=1
            ((done_count++)) || true
        done
        if [[ $done_count -gt 0 ]]; then
            log INFO "Completed jobs: $done_count"
        fi
    fi

    echo ""
    log INFO "Monitoring for new jobs..."

    while true; do
        # Check for new pending jobs
        shopt -s nullglob
        for job_file in "$PENDING_DIR"/*.yaml; do
            [[ -f "$job_file" ]] || continue
            check_job "$job_file"
        done

        # Check for newly claimed (active) jobs
        if [[ -d "$ACTIVE_DIR" ]]; then
            for job_file in "$ACTIVE_DIR"/*.yaml; do
                [[ -f "$job_file" ]] || continue
                check_claimed_job "$job_file"
            done
        fi

        # Check for newly completed jobs
        if [[ -d "$DONE_DIR" ]]; then
            for job_file in "$DONE_DIR"/*.yaml; do
                [[ -f "$job_file" ]] || continue
                check_completed_job "$job_file"
            done
        fi
        shopt -u nullglob

        # Clean up seen jobs that were claimed (no longer in pending)
        for job_id in "${!SEEN_JOBS[@]}"; do
            if [[ ! -f "$PENDING_DIR/${job_id}.yaml" ]]; then
                unset "SEEN_JOBS[$job_id]"
            fi
        done

        # Clean up active jobs that were completed (no longer in active)
        for job_id in "${!ACTIVE_JOBS[@]}"; do
            if [[ ! -f "$ACTIVE_DIR/${job_id}.yaml" ]]; then
                unset "ACTIVE_JOBS[$job_id]"
            fi
        done

        sleep "$POLL_INTERVAL"
    done
}

# Show help
show_help() {
    cat << EOF
Usage: swarm-watcher [OPTIONS]

Monitor the job queue and notify capable agents.

Options:
    -i, --interval SEC   Poll interval in seconds (default: 5)
    -h, --help           Show this help

Environment:
    POLL_INTERVAL        Poll interval (default: 5)

Behavior:
    - Monitors jobs/pending/ for new job files
    - Notifies capable agents via tmux based on job complexity
    - Logs activity to events.log
    - Ctrl-C triggers 'launch-agents --force stop' (swarm shutdown)

EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -i|--interval)
            POLL_INTERVAL="$2"
            shift 2
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            exit 1
            ;;
    esac
done

# Verify environment
if ! tmux has-session -t "$SESSION" 2>/dev/null; then
    echo -e "${RED}Error: No tmux session '$SESSION' found${NC}" >&2
    echo "Run 'launch-agents start' first" >&2
    exit 1
fi

if [[ ! -d "$PENDING_DIR" ]]; then
    mkdir -p "$PENDING_DIR"
fi

if [[ ! -d "$ACTIVE_DIR" ]]; then
    mkdir -p "$ACTIVE_DIR"
fi

if [[ ! -d "$DONE_DIR" ]]; then
    mkdir -p "$DONE_DIR"
fi

# Banner
echo -e "${BOLD}${CYAN}"
echo "  ╔═══════════════════════════════════════╗"
echo "  ║          JOB WATCHER DAEMON           ║"
echo "  ║     Ctrl-C = Graceful Shutdown        ║"
echo "  ╚═══════════════════════════════════════╝"
echo -e "${NC}"

# Start watching
watch_loop
