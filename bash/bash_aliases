#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0


alias more=$PAGER # bypass more to default $PAGER
#export GREP_COLOR="1;32"
export GREP_COLORS='ms=01;32:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36'
export GREP_OPTIONS="--color=auto -i"

# Universal help formatter
help() {
    if [ $# -eq 0 ]; then
        # Show shell built-in help
        builtin help | bat --plain --language=help
    elif [ "$1" = "shortcuts" ]; then
        # Handle "help shortcuts" specially
        shift
        # If no args, show help; otherwise pass through
        if [ $# -eq 0 ]; then
            shortcuts --help
        else
            shortcuts "$@"
        fi
    elif [ "$1" = "aliases" ]; then
        # Handle "help aliases" specially
        shift
        # If no args, show help; otherwise pass through
        if [ $# -eq 0 ]; then
            aliases --help
        else
            aliases "$@"
        fi
    else
        # Format command help
        "$@" --help 2>&1 | bat --plain --language=help
    fi
}

alias path='echo -e ${PATH//:/\\n}' # show path nicely
alias now='date +"%Y-%m-%d_%H-%M-%S"'
alias today='date +"%Y-%m-%d"'
alias week='date +%V'
alias sizeof='du -sh'

alias t='tail -n 50'
alias tf='tail -f'
alias x='exit'

# List aliases, optionally filtered
_alias() {
    if [ $# -eq 0 ]; then
        alias | sort | bat --plain --language=bash
    else
        alias | sort | grep "$1" | bat --plain --language=bash
    fi
}
alias a="_alias"

alias c='clear'
alias e='env | sort | bat --plain --language=bash' # make sure env is always sorted
alias reload='source ~/.bashrc && echo "Reloaded ~/.bashrc"'
alias r='reload'
alias sc='shortcuts'
alias al='aliases'

alias ls='eza --color=always --group-directories-first'
alias ll='eza -la --color=always --group-directories-first --git --header'
alias la='eza -a --color=always --group-directories-first'
alias lt='eza --tree --color=always --git-ignore --level=3'
alias l='eza -F --color=always'

lsort() {
  local col=${2:-5}  # Default column 5 (date), or pass as second arg
  eza -la --color=always --header --git "$1" | (read header; echo "$header"; sort -h -k "$col")
}

# Traditional ls with enhanced colors (fallback)
alias lsold='/bin/ls --color=always'
export LSCOLORS="GxFxCxDxBxegedabagaced"
alias lr="ls -lAt | head"

alias info="tldr"

# Navigation - zoxide handles smart cd, these handle the rest
alias b='popd 2> /dev/null || cd -' # back to previous dir (directory stack)
alias cdi='cdi'                     # interactive directory picker (fzf)
alias ..='cd ../'
alias ...='cd ../..'
alias ....='cd ../../..'
alias cd..='cd ../'
alias ~='cd ~'
alias pwdc='pwd | pbcopy'  # current dir to buffer
alias cdp='cd $(pbpaste)'  # cd buffer

_mk_cddir () { mkdir -p "$@" && cd "$_" || return ; } # create a go into dir
alias mkcd=_mk_cddir
alias rd='rm -rf'

lkill () { ps | grep -v grep | grep "$@" | awk '{print $1}' | xargs kill; }

cheat() {
    curl -s "cheat.sh/$1" | bat --plain --language=help
}


alias first='head -n1'
alias second="awk 'NR==2'"
alias third="awk 'NR==3'"

# This should be here to make history available in the script
_bash_history() {
    local HELP_CMD="cat"
    if command -v bat >/dev/null 2>&1; then
        HELP_CMD="bat --plain --language=help"
    fi

    # Function to show usage
    show_usage() {
        $HELP_CMD << 'EOF'
Usage: _bash_history [OPTIONS] [HISTORY_OPTIONS]

A sophisticated history viewer with syntax highlighting, search, and selection capabilities.

OPTIONS:
    -s, --select        Use fzf to interactively select and execute a command by parsing the command text
    -g, --grep PATTERN  Grep history for PATTERN (supports regex)
    -h, --help          Show this help message

HISTORY_OPTIONS:
    Any valid history command options are passed through:
    -c                  Clear the history list
    -d OFFSET           Delete history entry at position OFFSET  
    -a                  Append new history lines to history file
    -n                  Append history lines not already read from history file
    -r                  Read history file and append to history list
    -w                  Write current history to history file
    -p                  Perform history expansion and print result
    -s                  Store ARGS in history as if they had been entered at command line
    NUMBER              Show only the last NUMBER entries

EXAMPLES:
    _bash_history                   # Show last 10 commands with syntax highlighting
    _bash_history 50                # Show last 50 commands
    _bash_history -g "git"          # Show ALL commands containing "git" (full history)
    _bash_history -g "^sudo"        # Show ALL commands starting with "sudo" (full history)
    _bash_history 50 -g "cat"       # Show last 50 commands containing "cat"
    _bash_history -s                # Interactive selection with fzf (from last 10)
    _bash_history -s -g "docker"    # Interactive selection of ALL docker commands
    _bash_history -g "npm" -s       # Interactive selection of ALL npm commands
    _bash_history -w                # Write current session to history file
    _bash_history -d 1050           # Delete history entry 1050

NOTE:
    Default behavior shows the last 10 history entries for better readability.
    When using -g/--grep, searches through FULL history unless a number is specified.
    Use a number argument to limit: _bash_history 100 or _bash_history 50 -g "pattern"
    
    The -s option extracts and executes the actual command from the selected
    history line, preserving the exact command text as displayed.
    
    Output: Regular history uses bat syntax highlighting. Grep results use grep's
    own coloring to highlight matches. This preserves search result readability.

DEPENDENCIES:
    bat     - For syntax highlighting (optional, falls back to cat)
    fzf     - For interactive selection (required for -s option)

EOF
    }

    # Parse arguments with better logic for mixed options and positional args
    local use_fzf=false
    local grep_pattern=""
    local history_args=()
    
    # First pass: extract our special options (-s, -g, -h) regardless of position
    local temp_args=("$@")
    local filtered_args=()
    local i=0
    
    while [[ $i -lt ${#temp_args[@]} ]]; do
        case "${temp_args[$i]}" in
            -h|--help)
                show_usage
                return 0
                ;;
            -s|--select)
                use_fzf=true
                ;;
            -g|--grep)
                if [[ $((i+1)) -lt ${#temp_args[@]} ]]; then
                    grep_pattern="${temp_args[$((i+1))]}"
                    i=$((i+1))  # Skip next argument (the pattern)
                else
                    echo "Error: -g/--grep requires a pattern argument" >&2
                    echo "Use _bash_history --help for usage information" >&2
                    return 1
                fi
                ;;
            *)
                # Keep this argument for further processing
                filtered_args+=("${temp_args[$i]}")
                ;;
        esac
        i=$((i+1))
    done
    
    # Second pass: handle remaining arguments
    for arg in "${filtered_args[@]}"; do
        if [[ "$arg" =~ ^[0-9]+$ ]]; then
            # Numeric argument goes to history
            history_args+=("$arg")
        elif [[ "$arg" == -* ]]; then
            # Other options go to history  
            history_args+=("$arg")
        elif [[ -z "$grep_pattern" ]]; then
            # Non-option argument becomes grep pattern if none set
            grep_pattern="$arg"
        else
            # Additional non-option args go to history
            history_args+=("$arg")
        fi
    done

    # Check dependencies
    if [[ "$use_fzf" == true ]] && ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf is required for -s/--select option" >&2
        echo "Install with: brew install fzf" >&2
        return 1
    fi

    # Determine output command
    local output_cmd="cat"
    if command -v bat >/dev/null 2>&1; then
        output_cmd="bat --plain --language=bash"
    fi

    # Build the pipeline
    local cmd_pipeline=""
    
    # Start with history command
    if [[ ${#history_args[@]} -eq 0 ]]; then
        if [[ -n "$grep_pattern" ]]; then
            cmd_pipeline="history"  # Use full history when grepping
        else
            cmd_pipeline="history 20"  # Default to last 10 entries when not grepping
        fi
    else
        cmd_pipeline="history ${history_args[*]}"
    fi
    
    # Add grep if pattern specified
    if [[ -n "$grep_pattern" ]]; then
        # Use grep with auto coloring - colors when output to terminal, plain when piped
        cmd_pipeline="$cmd_pipeline | command grep --color=auto -i -E '$grep_pattern'"
    fi
    
    # Handle fzf selection vs normal output
    if [[ "$use_fzf" == true ]]; then
        # Use fzf for selection
        local selected_line
        selected_line=$(eval "$cmd_pipeline" | fzf \
            --height=50% \
            --layout=reverse \
            --border \
            --preview 'echo {}' \
            --preview-window=up:3:wrap \
            --bind 'enter:accept,ctrl-c:abort' \
            --header='Select command to execute (Enter=execute, Ctrl+C=cancel)' \
            --prompt='History> ' \
            --color='header:italic:underline' \
        )
        
        if [[ -n "$selected_line" ]]; then
            # Extract the actual command from the selected line
            # Format: "  487  [11/23/25T10:20:03] hg cat"
            # Remove: leading spaces, number, spaces, timestamp in brackets, spaces
            local clean_cmd
            clean_cmd=$(echo "$selected_line" | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]*\[[^]]+\][[:space:]]*//')
            
            if [[ -n "$clean_cmd" ]]; then
                echo "Executing: $clean_cmd"
                
                # Add to history and execute
                history -s "$clean_cmd"
                eval "$clean_cmd"
            else
                echo "Error: Could not extract command from: $selected_line" >&2
                return 1
            fi
        else
            echo "No command selected."
            return 1
        fi
    else
        # Normal output - use bat for syntax highlighting only if NOT using grep
        if [[ -n "$grep_pattern" ]]; then
            # For grep output, use plain output to preserve grep's own coloring
            eval "$cmd_pipeline"
        else
            # For regular history output, use bat for syntax highlighting
            eval "$cmd_pipeline | $output_cmd"
        fi
    fi
}

# Create convenient aliases
alias h='_bash_history'
alias hs='_bash_history -s'
alias hg='_bash_history -g'
