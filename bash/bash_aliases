#!/usr/bin/env bash

alias more=$PAGER # bypass more to default $PAGER
#export GREP_COLOR="1;32"
export GREP_COLORS='ms=01;32:mc=01;31:sl=:cx=:fn=35:ln=32:bn=32:se=36'
export GREP_OPTIONS="--color=always -i"

# Universal help formatter
help() {
    if [ $# -eq 0 ]; then
        # Show shell built-in help
        builtin help | bat --plain --language=help
    else
        # Format command help
        "$@" --help 2>&1 | bat --plain --language=help
    fi
}

alias path='echo -e ${PATH//:/\\n}' # show path nicely
alias now='date +"%Y-%m-%d_%H-%M-%S"'
alias today='date +"%Y-%m-%d"'
alias week='date +%V'
alias sizeof='du -sh'

alias t='tail -n 50'
alias tf='tail -f'
alias x='exit'
alias a='alias | sort | bat --plain --language=bash'
alias c='clear'
alias e='env | sort | bat --plain --language=bash' # make sure env is always sorted

alias ls='eza --color=always --group-directories-first'
alias ll='eza -la --color=always --group-directories-first --git --header'
alias la='eza -a --color=always --group-directories-first'
alias lt='eza --tree --color=always --git-ignore --level=3'
alias l='eza -F --color=always'

# Traditional ls with enhanced colors (fallback)
alias lsold='/bin/ls --color=always'
export LSCOLORS="GxFxCxDxBxegedabagaced"
alias lr="ls -lAt | head"

alias info="tldr"

alias b='popd' # back to previous dir
alias e.='pushd $DOTFILES' # go straight to dotfiles folder
alias ..='cd ../'
alias ...='cd ../..'
alias ....='cd ../../..'
alias -- -='cd -'  # go back to previous directory
alias cd..='cd ../'
alias ~='cd ~'

_mk_cddir () { mkdir -p "$@" && cd "$_" || return ; } # create a go into dir
alias mkcd=_mk_cddir
alias rd='rm -rf'

lkill () { ps | grep -v grep | grep "$@" | awk '{print $1}' | xargs kill; }

cheat() {
    curl -s "cheat.sh/$1" | bat --plain --language=help
}


alias first='head -n1'
alias second="awk 'NR==2'"
alias third="awk 'NR==3'"

__bash_history() {
    local HELP_CMD="cat"
    if command -v bat >/dev/null 2>&1; then
        HELP_CMD="bat --plain --language=help"
    fi

    # Function to show usage
    show_usage() {
        $HELP_CMD << 'EOF'
Usage: __bash_history [OPTIONS] [HISTORY_OPTIONS]

A sophisticated history viewer with syntax highlighting, search, and selection capabilities.

OPTIONS:
    -s, --select        Use fzf to interactively select and execute a command by parsing the command text
    -g, --grep PATTERN  Grep history for PATTERN (supports regex)
    -h, --help          Show this help message

HISTORY_OPTIONS:
    Any valid history command options are passed through:
    -c                  Clear the history list
    -d OFFSET           Delete history entry at position OFFSET  
    -a                  Append new history lines to history file
    -n                  Append history lines not already read from history file
    -r                  Read history file and append to history list
    -w                  Write current history to history file
    -p                  Perform history expansion and print result
    -s                  Store ARGS in history as if they had been entered at command line
    NUMBER              Show only the last NUMBER entries

EXAMPLES:
    __bash_history                    # Show last 10 commands with syntax highlighting
    __bash_history 50                # Show last 50 commands
    __bash_history -g "git"          # Show ALL commands containing "git" (full history)
    __bash_history -g "^sudo"        # Show ALL commands starting with "sudo" (full history)
    __bash_history 50 -g "cat"       # Show last 50 commands containing "cat"
    __bash_history -s                # Interactive selection with fzf (from last 10)
    __bash_history -s -g "docker"    # Interactive selection of ALL docker commands
    __bash_history -g "npm" -s       # Interactive selection of ALL npm commands
    __bash_history -w                # Write current session to history file
    __bash_history -d 1050           # Delete history entry 1050

NOTE:
    Default behavior shows the last 10 history entries for better readability.
    When using -g/--grep, searches through FULL history unless a number is specified.
    Use a number argument to limit: __bash_history 100 or __bash_history 50 -g "pattern"
    
    The -s option extracts and executes the actual command from the selected
    history line, preserving the exact command text as displayed.
    
    Output: Regular history uses bat syntax highlighting. Grep results use grep's
    own coloring to highlight matches. This preserves search result readability.

DEPENDENCIES:
    bat     - For syntax highlighting (optional, falls back to cat)
    fzf     - For interactive selection (required for -s option)

EOF
    }

    # Parse arguments with better logic for mixed options and positional args
    local use_fzf=false
    local grep_pattern=""
    local history_args=()
    
    # First pass: extract our special options (-s, -g, -h) regardless of position
    local temp_args=("$@")
    local filtered_args=()
    local i=0
    
    while [[ $i -lt ${#temp_args[@]} ]]; do
        case "${temp_args[$i]}" in
            -h|--help)
                show_usage
                return 0
                ;;
            -s|--select)
                use_fzf=true
                ;;
            -g|--grep)
                if [[ $((i+1)) -lt ${#temp_args[@]} ]]; then
                    grep_pattern="${temp_args[$((i+1))]}"
                    i=$((i+1))  # Skip next argument (the pattern)
                else
                    echo "Error: -g/--grep requires a pattern argument" >&2
                    echo "Use __bash_history --help for usage information" >&2
                    return 1
                fi
                ;;
            *)
                # Keep this argument for further processing
                filtered_args+=("${temp_args[$i]}")
                ;;
        esac
        i=$((i+1))
    done
    
    # Second pass: handle remaining arguments
    for arg in "${filtered_args[@]}"; do
        if [[ "$arg" =~ ^[0-9]+$ ]]; then
            # Numeric argument goes to history
            history_args+=("$arg")
        elif [[ "$arg" == -* ]]; then
            # Other options go to history  
            history_args+=("$arg")
        elif [[ -z "$grep_pattern" ]]; then
            # Non-option argument becomes grep pattern if none set
            grep_pattern="$arg"
        else
            # Additional non-option args go to history
            history_args+=("$arg")
        fi
    done

    # Check dependencies
    if [[ "$use_fzf" == true ]] && ! command -v fzf >/dev/null 2>&1; then
        echo "Error: fzf is required for -s/--select option" >&2
        echo "Install with: brew install fzf" >&2
        return 1
    fi

    # Determine output command
    local output_cmd="cat"
    if command -v bat >/dev/null 2>&1; then
        output_cmd="bat --plain --language=bash"
    fi

    # Build the pipeline
    local cmd_pipeline=""
    
    # Start with history command
    if [[ ${#history_args[@]} -eq 0 ]]; then
        if [[ -n "$grep_pattern" ]]; then
            cmd_pipeline="history"  # Use full history when grepping
        else
            cmd_pipeline="history 20"  # Default to last 10 entries when not grepping
        fi
    else
        cmd_pipeline="history ${history_args[*]}"
    fi
    
    # Add grep if pattern specified
    if [[ -n "$grep_pattern" ]]; then
        # Use grep with auto coloring - colors when output to terminal, plain when piped
        cmd_pipeline="$cmd_pipeline | command grep --color=auto -i -E '$grep_pattern'"
    fi
    
    # Handle fzf selection vs normal output
    if [[ "$use_fzf" == true ]]; then
        # Use fzf for selection
        local selected_line
        selected_line=$(eval "$cmd_pipeline" | fzf \
            --height=50% \
            --layout=reverse \
            --border \
            --preview 'echo {}' \
            --preview-window=up:3:wrap \
            --bind 'enter:accept,ctrl-c:abort' \
            --header='Select command to execute (Enter=execute, Ctrl+C=cancel)' \
            --prompt='History> ' \
            --color='header:italic:underline' \
        )
        
        if [[ -n "$selected_line" ]]; then
            # Extract the actual command from the selected line
            # Format: "  487  [11/23/25T10:20:03] hg cat"
            # Remove: leading spaces, number, spaces, timestamp in brackets, spaces
            local clean_cmd
            clean_cmd=$(echo "$selected_line" | sed -E 's/^[[:space:]]*[0-9]+[[:space:]]*\[[^]]+\][[:space:]]*//')
            
            if [[ -n "$clean_cmd" ]]; then
                echo "Executing: $clean_cmd"
                
                # Add to history and execute
                history -s "$clean_cmd"
                eval "$clean_cmd"
            else
                echo "Error: Could not extract command from: $selected_line" >&2
                return 1
            fi
        else
            echo "No command selected."
            return 1
        fi
    else
        # Normal output - use bat for syntax highlighting only if NOT using grep
        if [[ -n "$grep_pattern" ]]; then
            # For grep output, use plain output to preserve grep's own coloring
            eval "$cmd_pipeline"
        else
            # For regular history output, use bat for syntax highlighting
            eval "$cmd_pipeline | $output_cmd"
        fi
    fi
}

# Create convenient aliases
alias h='__bash_history'
alias hs='__bash_history -s'
alias hg='__bash_history -g'
