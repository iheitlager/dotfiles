#!/usr/bin/env bash
export DOTFILES=$HOME/.dotfiles

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export BASH_SILENCE_DEPRECATION_WARNING=1

# Disable the default virtual environment prompt modification
export VIRTUAL_ENV_DISABLE_PROMPT=1

# Configure git prompt to show all the information
export GIT_PS1_SHOWDIRTYSTATE=1      # * and + for unstaged/staged changes
export GIT_PS1_SHOWSTASHSTATE=1      # $ for stashes
export GIT_PS1_SHOWUNTRACKEDFILES=1  # % for untracked files
#export GIT_PS1_SHOWUPSTREAM="auto"   # <, >, = for upstream comparison
export GIT_PS1_SHOWCOLORHINTS=1      # Enable color hints

export PAGER=`which delta`
export EDITOR=`which vim`

export HISTCONTROL=ignoreboth:erasedups
export HISTSIZE=5000
export HISTFILESIZE=1000
export HISTIGNORE="&:ls:ll:la:l.:h:a:b:f:pwd:exit:c:x:clear"
export HISTTIMEFORMAT="[%DT%T] " 

shopt -s cdspell #fix spelling
shopt -s histappend # Append to history rather than overwrite
shopt -s checkwinsize   # Check window after each command
shopt -s dotglob    # files beginning with . to be returned in the results of path-name expansion.
shopt -s extglob # turn on extended globbing

# Tab complete for sudo
complete -cf sudo

#prevent overwriting files with cat
set -o noclobber

#stops ctrl+d from logging me out
set -o ignoreeof

REMOTE_PROMPT="\e[0;31m[\u@\h \W]\$ \e[m "

path_munge() {
    if [ -d "$1" ]; then
        PATH=${PATH//":$1:"/:} #delete all instances in the middle
        PATH=${PATH/%":$1"/} #delete any instance at the end
        PATH=${PATH/#"$1:"/} #delete any instance at the beginning
        if [ "$2" = "after" ] ; then
            PATH=$PATH:$1
        else
            PATH=$1:$PATH
        fi
    fi
}

# set path, make /usr/local/bin preference
# export PATH=`echo ":$PATH:" | sed -e "s#:/usr/local/bin:#:#g" -e "s/^://" -e "s/:$//"`
# export PATH=$DOTFILES/bin:/usr/local/bin:$PATH
export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
export PATH="/opt/local/bin:/opt/local/sbin:$PATH"

source_files () {
    local alias_file
    for alias_file in $DOTFILES/**/$1; do
        source "$alias_file"
    done
}

# use .localrc for SUPER SECRET CRAP that you don't
# want in your public, versioned repo.
if [ -e ~/.localrc ] ; then
  source ~/.localrc
fi


# path_munge "/opt/homebrew/bin"
path_munge "$DOTFILES/bin"
eval "$(/opt/homebrew/bin/brew shellenv)"
# do this for UV
export PATH="$HOME/.local/bin:$PATH"     # for uv
export PATH="$PATH:/Library/TeX/texbin"  # for pdflatex/mactex
#eval "$(/usr/libexec/path_helper)"

#ssh-add -A 2>/dev/null;

source_files "bash_aliases"
source_files "bash_env"

[[ -r "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh" ]] && . "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
# Source the git prompt script from Homebrew
source "$HOMEBREW_PREFIX/etc/bash_completion.d/git-prompt.sh"

source_files "bash_completion"

unset source_files

update_prompt() {
    # Color codes
    local GREEN='\[\033[32m\]'
    local BLUE='\[\033[34m\]'
    local YELLOW='\[\033[33m\]'
    local RED='\[\033[31m\]'
    local CYAN='\[\033[36m\]'
    local RESET='\[\033[0m\]'
    
    # First line components
    local venv_info=""
    local python_info=""
    local git_info=""
    local uv_info=""
    
    # Virtual environment with snake icon - use current directory name
    if [[ -n "$VIRTUAL_ENV" ]]; then
        local project_name=$(basename "$PWD")
        venv_info="${GREEN}ðŸ“¦ ${VIRTUAL_ENV_PROMPT}${RESET} "
    fi
    
    # Python version (only show if python is available)
    if command -v python &> /dev/null; then
        local py_version=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
        python_info="${BLUE}ðŸ py${py_version}${RESET} "
    fi
    
    # Git information
    if git rev-parse --git-dir > /dev/null 2>&1; then
        local git_prompt="$(__git_ps1 "âŽ‡ %s")"
        
        # Add numeric counts to existing symbols
        if git rev-parse --abbrev-ref @{upstream} &>/dev/null; then
            local ahead=$(git rev-list --count @{upstream}..HEAD 2>/dev/null || echo "0")
            local behind=$(git rev-list --count HEAD..@{upstream} 2>/dev/null || echo "0")
            
            if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} [${RED}${behind} behind${RESET}/${GREEN}${ahead} ahead${RESET}]"  # e.g. "âŽ‡ main<> 2/3"
            elif [[ "$ahead" -gt 0 ]]; then
                git_prompt="${git_prompt} [${GREEN}${ahead} ahead${RESET}]"            # e.g. "âŽ‡ main> 2"
            elif [[ "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} [${RED}${behind} behind${RESET}]"           # e.g. "âŽ‡ main< 3"
            fi
        fi
        
        git_info="${YELLOW}${git_prompt}${RESET}"
    fi
    
    if [[ -f "uv.lock" ]] || ([[ -f "pyproject.toml" ]] && grep -q "uv" pyproject.toml 2>/dev/null); then
        uv_info="âš¡"
    fi 
    # Build the first line
    local first_line="${uv_info}${venv_info}${python_info}${git_info}"
    
    # Only show first line if there's content
    if [[ -n "$first_line" ]]; then
        PS1="${first_line}\n${CYAN}[\W] >${RESET} "
    else
        PS1="${CYAN}[\W] >${RESET} "
    fi
}

PROMPT_COMMAND=update_prompt


export MANPATH="/opt/local/share/man:$MANPATH"
# Finished adapting your MANPATH environment variable for use with MacPorts.

export SSH_AUTH_SOCK=~/Library/Group\ Containers/2BUA8C4S2C.com.1password/t/agent.sock
