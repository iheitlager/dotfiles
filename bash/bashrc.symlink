#!/usr/bin/env bash
# Interactive shell configuration - sourced for every interactive shell
# Aliases, shell options, completions, and prompt go here

# Exit if not running interactively
[[ $- != *i* ]] && return

# Shell options
shopt -s cdspell        # Fix spelling errors in cd
shopt -s histappend     # Append to history rather than overwrite
shopt -s checkwinsize   # Check window after each command
shopt -s dotglob        # Include dotfiles in glob expansion
shopt -s extglob        # Extended globbing

# Bash 4+ options
if ((BASH_VERSINFO[0] >= 4)); then
    shopt -s autocd     # cd by typing directory name
    shopt -s globstar   # ** recursive glob
fi

# Shell settings
set -o noclobber        # Prevent overwriting files with >
set -o ignoreeof        # Prevent Ctrl+D from logging out

# Tab complete for sudo
complete -cf sudo

# Cache helper: regenerate file list only when dotfiles change
# (defined here too for non-login interactive shells)
if ! declare -f _dotfiles_cached_source &>/dev/null; then
    _dotfiles_cached_source() {
        local type="$1" cache="$XDG_CACHE_HOME/dotfiles/${type}.list"
        mkdir -p "$XDG_CACHE_HOME/dotfiles"
        
        # Regenerate cache if missing or dotfiles dir is newer
        if [[ ! -f "$cache" ]] || [[ "$DOTFILES" -nt "$cache" ]]; then
            printf '%s\n' $DOTFILES/*/"$type" > "$cache" 2>/dev/null
        fi
        
        # Source each file from cache
        while IFS= read -r f; do
            [[ -f "$f" ]] && source "$f"
        done < "$cache"
    }
fi

# Source aliases from modules (cached)
_dotfiles_cached_source bash_aliases

# Bash completion
[[ -r "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh" ]] && . "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
source "$HOMEBREW_PREFIX/etc/bash_completion.d/git-prompt.sh"

# Source completions from modules (cached)
_dotfiles_cached_source bash_completion

# Ghostty shell integration (cmd+click files, command markers, etc.)
if [[ "$TERM_PROGRAM" == "ghostty" ]]; then
    source /Applications/Ghostty.app/Contents/Resources/ghostty/shell-integration/bash/ghostty.bash
fi

# Prompt configuration
REMOTE_PROMPT="\e[0;31m[\u@\h \W]\$ \e[m "

# Cache for Python version (avoid spawning Python on every prompt)
_cached_venv=""
_cached_py_version=""

update_prompt() {
    # Color codes
    local GREEN='\[\033[32m\]'
    local BLUE='\[\033[34m\]'
    local YELLOW='\[\033[33m\]'
    local RED='\[\033[31m\]'
    local CYAN='\[\033[36m\]'
    local RESET='\[\033[0m\]'
    local MAGENTA='\[\033[35m\]'
    
    # First line components
    local venv_info=""
    local python_info=""
    local git_info=""

    # Virtual environment with package icon
    if [[ -n "$VIRTUAL_ENV" ]]; then
        local git_root="${VIRTUAL_ENV%/*}"
        local project_name="${git_root##*/}"  # Faster than $(basename ...)
        venv_info="${YELLOW}ðŸ“¦ ${project_name}${RESET} "
        # Just check for uv.lock (skip grep)
        [[ -f "$git_root/uv.lock" ]] && venv_info="âš¡$venv_info"
    fi
    
    # Python version - only recalculate when venv changes
    if [[ "$VIRTUAL_ENV" != "$_cached_venv" ]]; then
        _cached_venv="$VIRTUAL_ENV"
        if command -v python &> /dev/null; then
            _cached_py_version=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
        else
            _cached_py_version=""
        fi
    fi
    [[ -n "$_cached_py_version" ]] && python_info="${RED}ðŸ py${_cached_py_version}${RESET} "
    
    # Git information - __git_ps1 already checks if we're in a repo
    local git_prompt="$(__git_ps1 "âŽ‡ %s")"
    
    if [[ -n "$git_prompt" ]]; then
        # Get ahead/behind in one call (fails silently if no upstream)
        local counts
        if counts=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null); then
            local behind=${counts%%	*}  # Tab-separated
            local ahead=${counts##*	}
            
            if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} [${RED}${behind} behind${RESET}/${GREEN}${ahead} ahead${RESET}]"
            elif [[ "$ahead" -gt 0 ]]; then
                git_prompt="${git_prompt} [${GREEN}${ahead} ahead${RESET}]"
            elif [[ "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} [${RED}${behind} behind${RESET}]"
            fi
        fi
    fi
    
    # Build the first line
    local first_line="${venv_info}${python_info}"
    if [[ -n "$git_prompt" ]]; then
        first_line="${first_line}\[${git_prompt}\]"
    fi
    
    # Only show first line if there's content
    if [[ -n "$first_line" ]]; then
        PS1="${first_line}\n${MAGENTA}\w>${RESET} "
    else
        PS1="${CYAN}[\W] >${RESET} "
    fi

    # Tell terminal the current directory (OSC 7) for new tab/window behavior
    printf '\e]7;file://%s%s\e\\' "${HOSTNAME}" "${PWD// /%20}"
}

PROMPT_COMMAND=update_prompt
