#!/usr/bin/env bash
# Copyright 2026 Ilja Heitlager
# SPDX-License-Identifier: Apache-2.0

# Interactive shell configuration - sourced for every interactive shell
# Aliases, shell options, completions, and prompt go here

# Exit if not running interactively
[[ $- != *i* ]] && return

# Ensure XDG and HISTFILE are set for non-login shells (e.g., subshells, scripts)
# This prevents ~/.bash_history from being created
export XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
export HISTFILE="${HISTFILE:-$XDG_STATE_HOME/bash/history}"
mkdir -p "$(dirname "$HISTFILE")" 2>/dev/null

# Shell options
shopt -s cdspell        # Fix spelling errors in cd
shopt -s histappend     # Append to history rather than overwrite
shopt -s checkwinsize   # Check window after each command
shopt -s dotglob        # Include dotfiles in glob expansion
shopt -s extglob        # Extended globbing

# Bash 4+ options
if ((BASH_VERSINFO[0] >= 4)); then
    shopt -s autocd     # cd by typing directory name
    shopt -s globstar   # ** recursive glob
fi

# Shell settings
set -o noclobber        # Prevent overwriting files with >
set -o ignoreeof        # Prevent Ctrl+D from logging out

# Tab complete for sudo
complete -cf sudo

# Cache helpers (defined here too for non-login interactive shells)
if ! declare -f _dotfiles_cached_eval &>/dev/null; then
    _dotfiles_cached_eval() {
        local tool="$1"
        shift
        local cmd="$*"
        local bin cache
        bin="$(command -v "$tool" 2>/dev/null)" || return 0
        cache="$XDG_CACHE_HOME/dotfiles/eval_${tool}.sh"
        if [[ ! -f "$cache" ]] || [[ "$bin" -nt "$cache" ]]; then
            eval "$cmd" >| "$cache" 2>/dev/null
        fi
        source "$cache"
    }
fi
if ! declare -f _dotfiles_cached_source &>/dev/null; then
    _dotfiles_cached_source() {
        local type="$1"
        local cache="$XDG_CACHE_HOME/dotfiles/${type}.sh"
        mkdir -p "$XDG_CACHE_HOME/dotfiles"
        
        # Regenerate cache if missing or dotfiles dir is newer
        if [[ ! -f "$cache" ]] || [[ "$DOTFILES" -nt "$cache" ]]; then
            # Concatenate all module files with origin comments
            : >| "$cache"  # Truncate/create (>| overrides noclobber)
            for f in $DOTFILES/*/"$type"; do
                if [[ -f "$f" ]]; then
                    printf '\n# >>> %s\n' "${f#$DOTFILES/}" >> "$cache"
                    cat "$f" >> "$cache"
                    # Ensure trailing newline (some files may lack one)
                    [[ -n "$(tail -c 1 "$f")" ]] && echo >> "$cache"
                    printf '# <<< %s\n' "${f#$DOTFILES/}" >> "$cache"
                fi
            done
        fi
        
        # Source single cached file
        source "$cache"
    }
fi

# Source aliases from modules (cached)
_dotfiles_cached_source bash_aliases

# Bash completion
[[ -r "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh" ]] && . "$HOMEBREW_PREFIX/etc/profile.d/bash_completion.sh"
source "$HOMEBREW_PREFIX/etc/bash_completion.d/git-prompt.sh"

# Source completions from modules (cached)
_dotfiles_cached_source bash_completion

# Ghostty shell integration (cmd+click files, command markers, etc.)
if [[ "$TERM_PROGRAM" == "ghostty" ]]; then
    source /Applications/Ghostty.app/Contents/Resources/ghostty/shell-integration/bash/ghostty.bash
fi

# Prompt configuration
REMOTE_PROMPT="\e[0;31m[\u@\h \W]\$ \e[m "

# Cache for Python version (avoid spawning Python on every prompt)
_cached_venv=""
_cached_py_version=""

update_prompt() {
    # Color codes
    local GREEN='\[\033[32m\]'
    local BLUE='\[\033[34m\]'
    local YELLOW='\[\033[33m\]'
    local RED='\[\033[31m\]'
    local CYAN='\[\033[36m\]'
    local RESET='\[\033[0m\]'
    local MAGENTA='\[\033[35m\]'
    
    # First line components
    local venv_info=""
    local python_info=""
    local git_info=""

    # Virtual environment with package icon
    if [[ -n "$VIRTUAL_ENV" ]]; then
        local git_root="${VIRTUAL_ENV%/*}"
        local project_name="${git_root##*/}"  # Faster than $(basename ...)
        venv_info="${GREEN}ðŸ“¦ ${project_name}${RESET} "
        # Just check for uv.lock (skip grep)
        [[ -f "$git_root/uv.lock" ]] && venv_info="âš¡$venv_info"
    fi
    
    # Python version - only recalculate when venv changes
    if [[ "$VIRTUAL_ENV" != "$_cached_venv" ]]; then
        _cached_venv="$VIRTUAL_ENV"
        if command -v python &> /dev/null; then
            _cached_py_version=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
        else
            _cached_py_version=""
        fi
    fi
    [[ -n "$_cached_py_version" ]] && python_info="${BLUE}ðŸ py${_cached_py_version}${RESET} "
    
    # Git information - __git_ps1 already checks if we're in a repo
    # Use raw ANSI codes (not PS1 escapes) since git_prompt is printed via \[...\]
    local Y=$'\033[33m'  # Yellow
    local R=$'\033[31m'  # Red
    local G=$'\033[32m'  # Green  
    local N=$'\033[0m'   # Reset
    
    local git_prompt="$(__git_ps1 "${Y}âŽ‡ %s${N}")"
    
    if [[ -n "$git_prompt" ]]; then
        # Get ahead/behind in one call (fails silently if no upstream)
        local counts
        if counts=$(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null); then
            local behind=${counts%%	*}  # Tab-separated
            local ahead=${counts##*	}
            
            if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} ${R}â†“${behind}${N} ${G}â†‘${ahead}${N}"
            elif [[ "$ahead" -gt 0 ]]; then
                git_prompt="${git_prompt} ${G}â†‘${ahead}${N}"
            elif [[ "$behind" -gt 0 ]]; then
                git_prompt="${git_prompt} ${R}â†“${behind}${N}"
            fi
        fi
    fi
    
    # Build the first line
    local first_line="${venv_info}${python_info}"
    if [[ -n "$git_prompt" ]]; then
        first_line="${first_line}\[${git_prompt}\]"
    fi
    
    # Only show first line if there's content
    if [[ -n "$first_line" ]]; then
        PS1="${first_line}\n${MAGENTA}\w>${RESET} "
    else
        PS1="${CYAN}[\W] >${RESET} "
    fi

    # Tell terminal the current directory (OSC 7) for new tab/window behavior
    printf '\e]7;file://%s%s\e\\' "${HOSTNAME}" "${PWD// /%20}"
    
    # Share history across terminals: append new commands, then reload
    history -a  # Append new lines to history file
    history -n  # Read new lines from history file
}

PROMPT_COMMAND="update_prompt${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
